<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jsocketpp: Address Reuse in Sockets: &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; vs &lt;tt&gt;SO_EXCLUSIVEADDRUSE&lt;/tt&gt;</title>
<link rel="icon" href="logo55px.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo55px.png"/></td>
  <td id="projectalign">
   <div id="projectname">jsocketpp<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A cross-platform C++20 socket library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__address__reuse.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Address Reuse in Sockets: <span class="tt">SO_REUSEADDR</span> vs <span class="tt">SO_EXCLUSIVEADDRUSE</span> <div class="ingroups"><a class="el" href="group__docs.html">User Guides</a></div></div></div>
</div><!--header-->
<div class="contents">
<p>Cross-platform socket programming requires careful handling of address reuse settings to avoid unexpected behavior, especially when dealing with server sockets that are frequently restarted.</p>
<p>This article explains the behavior and usage of <span class="tt">SO_REUSEADDR</span>, <span class="tt">SO_EXCLUSIVEADDRUSE</span>, and <span class="tt">SO_REUSEPORT</span> on different operating systems, highlights the key differences, analyzes Java‚Äôs design decisions, and proposes a robust strategy for use in this cross-platform C++ socket library.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md94"></a>
üîç In-Depth Overview of Address Reuse Options</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md95"></a>
<span class="tt">SO_REUSEADDR</span></h2>
<ul>
<li><b>Definition</b>: Allows a socket to bind to an address that is in the <span class="tt">TIME_WAIT</span> state or may still be lingering. See <a class="el" href="socket__states_8md.html">socket_states.md</a> to learn about socket states.</li>
<li><b>Purpose</b>: Enables servers to restart and bind to the same port without waiting for previous connections to fully terminate.</li>
<li><b>Platform-Specific Behavior</b>:</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md96"></a>
On Unix/Linux:</h3>
<p><span class="tt">SO_REUSEADDR</span> on Unix-like systems behaves differently than on Windows and is generally considered safe and useful ‚Äî but only when its semantics are well understood.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md97"></a>
üîÑ What it actually does</h4>
<ul>
<li><span class="tt">SO_REUSEADDR</span> allows a socket to <b>bind</b> to an address even if:<ul>
<li>A previous socket bound to the same address is in the <span class="tt">TIME_WAIT</span> state.</li>
<li>The same port is already bound <b>by another socket</b>, but only under specific conditions.</li>
</ul>
</li>
<li>It does <b>not</b> allow arbitrary multiple sockets to bind to the <b>same full address (IP + port)</b> simultaneously. It will return <span class="tt">EADDRINUSE</span> unless:<ul>
<li>All sockets set <span class="tt">SO_REUSEADDR</span> <em>before</em> binding.</li>
<li>The sockets bind to different interfaces (e.g., <span class="tt">127.0.0.1</span> vs <span class="tt">0.0.0.0</span> vs a specific IP).</li>
<li>The kernel allows it (varies slightly between BSD/Linux implementations).</li>
</ul>
</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md98"></a>
üì¶ Common use cases</h4>
<ul>
<li>Restarting a server (e.g., NGINX, HAProxy, Redis) that previously closed a socket still in <span class="tt">TIME_WAIT</span>.</li>
<li>Rebinding to an ephemeral port after a client disconnects.</li>
<li>Binding a socket that needs to share a port with another <b>non-conflicting</b> binding (e.g., a broadcast/multicast listener).</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md99"></a>
‚ö†Ô∏è Misconceptions and caveats</h4>
<ul>
<li>It does <b>not</b> permit multiple listeners on the exact same <span class="tt">(ip, port)</span> to receive traffic at the same time ‚Äî that is the purpose of <span class="tt">SO_REUSEPORT</span>.</li>
<li>If multiple sockets successfully bind with <span class="tt">SO_REUSEADDR</span>, only <b>one</b> of them will receive incoming connections. This is typically the last one to bind, but behavior is not guaranteed.</li>
<li>When improperly used, it can lead to one process inadvertently "stealing" traffic from another.</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md100"></a>
üß† Practical implications</h4>
<ul>
<li>Without <span class="tt">SO_REUSEADDR</span>, restarting a server may fail with <span class="tt">EADDRINUSE</span> until the OS releases the port (typically after 60 seconds in <span class="tt">TIME_WAIT</span>).</li>
<li>With it, server restarts can be smooth and quick, avoiding port conflicts.</li>
<li>It does <b>not</b> override exclusive binds from other users (permissions apply).</li>
<li>Used by almost every server daemon and framework on Unix.</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md101"></a>
üß™ Socket state handling</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Previous socket state  </th><th class="markdownTableHeadNone">Can bind with <span class="tt">SO_REUSEADDR</span>?  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">TIME_WAIT</span>  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">CLOSE_WAIT</span>  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">ESTABLISHED</span>  </td><td class="markdownTableBodyNone">‚ùå No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">LISTEN</span>  </td><td class="markdownTableBodyNone">‚ùå No  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unbound  </td><td class="markdownTableBodyNone">‚úÖ N/A  </td></tr>
</table>
<p>In essence: <span class="tt">SO_REUSEADDR</span> <b>does not allow stealing a live port from another process.</b> It enables rebinding in <em>transitional</em> states (e.g., <span class="tt">TIME_WAIT</span>) and makes controlled reuse easier within cooperating processes.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md102"></a>
üöÄ Combining with <span class="tt">SO_REUSEPORT</span></h4>
<ul>
<li>When <b>used together</b>, <span class="tt">SO_REUSEADDR</span> and <span class="tt">SO_REUSEPORT</span> allow multiple sockets (in the same or different processes) to listen concurrently on the <b>same IP\:port</b> and receive connections in parallel.</li>
<li><p class="startli">This is common in load-balanced multi-process servers:</p>
<p class="startli"><span class="tt">cpp
      int sock = socket(...);
      setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, ...);
      setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, ...);
      bind(sock, ...);
      listen(sock, SOMAXCONN);
      </span></p>
</li>
<li>Without <span class="tt">SO_REUSEPORT</span>, <span class="tt">SO_REUSEADDR</span> is <em>not</em> sufficient for true concurrent binding or parallel connection handling.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md103"></a>
On Windows:</h3>
<ul>
<li><span class="tt">SO_REUSEADDR</span> allows binding to a port <b>even if it is still actively bound by another socket</b>.</li>
<li>This means two sockets in different processes could both bind to the same port and <b>both receive data</b>, leading to race conditions, data loss, or application errors.</li>
<li>Hence, this is <b>not safe for use in server applications</b> on Windows.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md104"></a>
On Windows:</h3>
<pre class="fragment">The behavior of `SO_REUSEADDR` on Windows diverges significantly from its Unix counterpart ‚Äî and **can be unsafe if misunderstood**.

##### üß® What it actually does

* On Windows, setting `SO_REUSEADDR` **before `bind()`** allows a socket to:

    * Bind to a port that is still in `TIME_WAIT`.
    * **Bind to a port already in use by another process or socket**, even if that socket is in `LISTEN` or `ESTABLISHED`.

##### ‚ùó Dangerous implications

* **Multiple sockets (even in different processes)** can bind to the **exact same IP and port**, provided they all use `SO_REUSEADDR`.
* Windows will not prevent this, nor guarantee which socket receives traffic.
* This leads to **non-deterministic behavior**, where:

    * Incoming data may be delivered to any of the bound sockets.
    * TCP connections may be accepted by either process.
    * UDP datagrams can be lost, duplicated, or processed out of order.

##### üö´ Not safe for servers

This behavior **breaks the assumption** that only one server process can bind to a specific port, and is considered unsafe for:

* Production services
* Daemons
* Applications requiring exclusive access

##### üîê Correct approach on Windows: `SO_EXCLUSIVEADDRUSE`

To ensure a server has **exclusive access to its listening port**, Windows introduced `SO_EXCLUSIVEADDRUSE`:

* Must be set before `bind()`.
* Prevents **any** other socket (in any process) from binding to the same IP\:port.
* Protects against port hijacking and unintended parallel bindings.

##### üõ†Ô∏è Example behavior

| Socket 1                   | Socket 2                   | Both use SO\_REUSEADDR | Result                              |
| -------------------------- | -------------------------- | ---------------------- | ----------------------------------- |
| Bound                      | Tries to bind to same port | ‚úÖ Yes                  | **Both succeed**, traffic split     |
| Bound                      | Tries to bind to same port | ‚ùå No                   | `bind()` fails with `WSAEADDRINUSE` |
| Uses `SO_EXCLUSIVEADDRUSE` | Any socket                 | N/A                    | Only one bind allowed               |

##### üß™ TCP state implications

* Windows does allow re-binding to sockets in `TIME_WAIT` when `SO_REUSEADDR` is used ‚Äî similar to Unix.
* **But it also permits re-binding to active or listening sockets** ‚Äî which Unix forbids ‚Äî making it **much more permissive and risky**.

##### üß† Summary

| Feature                             | Unix `SO_REUSEADDR` | Windows `SO_REUSEADDR`  |
| ----------------------------------- | ------------------- | ----------------------- |
| Bind to port in `TIME_WAIT`         | ‚úÖ Yes               | ‚úÖ Yes                   |
| Bind when another socket is bound   | ‚ùå No                | ‚úÖ Yes (unsafe!)         |
| Allow multiple sockets on same port | ‚ùå No                | ‚úÖ Yes (risky)           |
| Port hijacking risk                 | ‚ùå No                | ‚ö†Ô∏è Yes                  |
| Use for server binding              | ‚úÖ Yes               | ‚ùå No                    |
| Safer alternative                   | ‚Äî                   | ‚úÖ `SO_EXCLUSIVEADDRUSE` |

&gt; üí° Therefore, for **cross-platform server code**, it is essential to map `setReuseAddress(true)` to `SO_EXCLUSIVEADDRUSE` on Windows.
</pre><h2 class="doxsection"><a class="anchor" id="autotoc_md105"></a>
<span class="tt">SO_EXCLUSIVEADDRUSE</span> (Windows only)</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md106"></a>
üîê Definition</h3>
<p><span class="tt">SO_EXCLUSIVEADDRUSE</span> is a Windows-specific socket option that <b>guarantees exclusive access to a given IP and port</b>. When enabled, <b>no other socket</b> ‚Äî in the same process or in other processes ‚Äî can bind to the same address and port combination <b>until the socket is closed</b>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md107"></a>
üéØ Purpose</h3>
<p>Its goal is to prevent:</p>
<ul>
<li><b>Port hijacking</b> ‚Äî where another process binds to a port that should be owned by a server.</li>
<li><b>Accidental or malicious duplication</b> ‚Äî where multiple server instances interfere with each other.</li>
<li><b>Ambiguity</b> ‚Äî where incoming data could be routed to any of multiple listeners.</li>
</ul>
<p>This option is especially important on Windows because its default behavior is much more permissive than on Unix-based systems.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md108"></a>
‚öôÔ∏è Behavior</h3>
<ul>
<li>Must be set <b>before</b> calling <span class="tt">bind()</span>.</li>
<li>Ensures <b>only one socket</b> may bind to a given port at a time.</li>
<li>Even if another socket attempts to bind using <span class="tt">SO_REUSEADDR</span>, it will <b>fail</b> if <span class="tt">SO_EXCLUSIVEADDRUSE</span> is in effect on the bound socket.</li>
<li>Once the socket is closed, the port becomes available again.</li>
</ul>
<blockquote class="doxtable">
<p>üîÑ Unlike Unix <span class="tt">SO_REUSEADDR</span>, it does <b>not</b> allow rebinding while in <span class="tt">TIME_WAIT</span>. You must wait for the OS to release the port or restart the process. If you close a socket and immediately try to bind a new one to the same port ( e.g., on server restart), it will fail if the previous socket was not properly closed or if Windows still holds it in <span class="tt">TIME_WAIT</span>. To ensure a smooth restart: Properly close sockets before shutdown; Avoid forcibly terminating the server process; Consider using <span class="tt">netsh int <a class="el" href="group__tcp.html" title="Classes and functions for TCP networking.">TCP Sockets</a> set global MaxUserPort=...</span> and related commands to manage port exhaustion if relevant; You could provide a fallback mechanism: e.g., if <span class="tt">bind()</span> fails due to <span class="tt">WSAEADDRINUSE</span>, show a clear error or delay retry. </p>
</blockquote>
<h3 class="doxsection"><a class="anchor" id="autotoc_md109"></a>
‚ö†Ô∏è Incompatibility</h3>
<ul>
<li><b>Cannot be combined meaningfully with <span class="tt">SO_REUSEADDR</span></b>.<ul>
<li>If both are set, <span class="tt">SO_EXCLUSIVEADDRUSE</span> takes precedence.</li>
<li>In practice, this combination is discouraged because <span class="tt">SO_REUSEADDR</span> serves no useful purpose when exclusivity is enforced.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md110"></a>
‚úÖ Use Case</h3>
<p>This is the <b>recommended option</b> for <b>server applications on Windows</b>, especially those that:</p>
<ul>
<li>Need strong security guarantees (e.g., preventing malicious binding).</li>
<li>Expect to run only a single instance.</li>
<li>Must avoid data races or contention between multiple sockets.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md111"></a>
üõ†Ô∏è How it works internally</h3>
<ul>
<li>The Windows kernel enforces a strict binding policy for sockets with <span class="tt">SO_EXCLUSIVEADDRUSE</span>.</li>
<li>It denies subsequent bind attempts from <b>any</b> socket that doesn't own the port, regardless of <span class="tt">SO_REUSEADDR</span>.</li>
<li>Once the socket is closed, the address is fully released.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md112"></a>
üß† Summary</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Behavior  </th><th class="markdownTableHeadNone"><span class="tt">SO_EXCLUSIVEADDRUSE</span>  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Exclusive control over port  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Prevents other binds to same port  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Binds allowed while in <span class="tt">TIME_WAIT</span>  </td><td class="markdownTableBodyNone">‚ùå No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Safer alternative to <span class="tt">SO_REUSEADDR</span> on Win  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Useful for production servers  </td><td class="markdownTableBodyNone">‚úÖ Absolutely  </td></tr>
</table>
<blockquote class="doxtable">
<p>üí° <span class="tt"><a class="el" href="namespacejsocketpp.html" title="A C++ socket library providing Java-style networking interfaces.">jsocketpp</a></span> automatically enables <span class="tt">SO_EXCLUSIVEADDRUSE</span> on Windows when <span class="tt">setReuseAddress(true)</span> is called (which happens by default in <span class="tt">ServerSocket</span>). </p>
</blockquote>
<h2 class="doxsection"><a class="anchor" id="autotoc_md113"></a>
<span class="tt">SO_REUSEPORT</span> (Unix/Linux only)</h2>
<ul>
<li><b>Definition</b>: <span class="tt">SO_REUSEPORT</span> allows multiple sockets within the <b>same host</b> to bind to the <b>same port and IP address</b>, enabling <b>kernel-level load balancing</b> between them.</li>
<li><b>Primary Purpose</b>: Improve scalability and performance of <b>multi-threaded</b> or <b>multi-process</b> server applications. Each worker thread or process can bind its own socket to the same port, and the kernel distributes incoming packets.</li>
<li><b>How It Works</b>:<ul>
<li>All sockets <b>must set <span class="tt">SO_REUSEPORT</span> before <span class="tt">bind()</span></b>.</li>
<li>All sockets <b>must bind to the exact same port and address</b>.</li>
<li>The kernel performs <b>fair distribution</b> of incoming connections or datagrams among the bound sockets.</li>
<li>This avoids the need for synchronization between threads/processes in user-space.</li>
</ul>
</li>
<li><b>Typical Use Cases</b>:<ul>
<li>High-performance web servers like <b>NGINX</b>, <b>HAProxy</b>, and <b>systemd socket activation</b>.</li>
<li>Servers with <b>multiple threads or processes</b> listening on the same port to parallelize work.</li>
</ul>
</li>
<li><b>Compatibility</b>:<ul>
<li>Available on <b>Linux ‚â• 3.9</b> and <b>FreeBSD ‚â• 10</b>.</li>
<li>Not available on <b>macOS</b>, unless using the newer <span class="tt">SO_REUSEPORT_LB</span> extension (not portable).</li>
<li><b>Not available on Windows</b>.</li>
</ul>
</li>
<li><b>Key Advantages</b>:<ul>
<li><b>No need for accept-mutex or lock-based load balancing</b> in user space.</li>
<li><b>Improves cache locality</b>: each thread handles its own clients.</li>
<li><b>Scales better</b> on multicore systems under heavy load.</li>
</ul>
</li>
<li><b>Limitations &amp; Cautions</b>:<ul>
<li>Requires <b>careful design</b>: all sockets must be set up identically.</li>
<li>If one process crashes or behaves incorrectly, it can still affect shared traffic.</li>
<li><b>Security risk</b> if multiple untrusted processes bind to the same port.</li>
</ul>
</li>
<li><p class="startli"><b>Example</b>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> sock1 = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><span class="keywordtype">int</span> sock2 = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> optval = 1;</div>
<div class="line">setsockopt(sock1, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span>(optval));</div>
<div class="line">setsockopt(sock2, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span>(optval));</div>
<div class="line"> </div>
<div class="line">bind(sock1, ...);</div>
<div class="line">bind(sock2, ...);</div>
<div class="line"> </div>
<div class="line">listen(sock1, SOMAXCONN);</div>
<div class="line">listen(sock2, SOMAXCONN);</div>
</div><!-- fragment --></li>
<li><b>Comparison with <span class="tt">SO_REUSEADDR</span></b>:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature  </th><th class="markdownTableHeadNone"><span class="tt">SO_REUSEADDR</span>  </th><th class="markdownTableHeadNone"><span class="tt">SO_REUSEPORT</span>  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Multiple bind allowed  </td><td class="markdownTableBodyNone">Sometimes (see OS rules)  </td><td class="markdownTableBodyNone">‚úÖ Always if <span class="tt">SO_REUSEPORT</span> is set  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Load balancing  </td><td class="markdownTableBodyNone">‚ùå Only last wins  </td><td class="markdownTableBodyNone">‚úÖ Kernel distributes load  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Thread/process safety  </td><td class="markdownTableBodyNone">‚ùå Risk of collisions  </td><td class="markdownTableBodyNone">‚úÖ Independent sockets  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Available on Windows?  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td><td class="markdownTableBodyNone">‚ùå No  </td></tr>
</table>
<ul>
<li><b>Best Practice</b>: Use <span class="tt">SO_REUSEPORT</span> only if:<ul>
<li>You are targeting <b>Linux 3.9+ or FreeBSD 10+</b>.</li>
<li>Your architecture benefits from high parallelism.</li>
<li>You want <b>manual control over per-core listeners</b>.</li>
<li>You fully understand the implications.</li>
</ul>
</li>
</ul>
<blockquote class="doxtable">
<p>üõë <b>Not portable!</b> Avoid making it the default behavior in a cross-platform library. Instead, provide a way for advanced users to enable it via <span class="tt">setOption(...)</span>. </p>
</blockquote>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md115"></a>
üß™ What Happens When Multiple Sockets Bind to the Same Port?</h1>
<p>This behavior depends heavily on which socket options are used and which operating system the code is running on. Here‚Äôs a breakdown of the possibilities:</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md117"></a>
Unix/Linux</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md118"></a>
<b>With <span class="tt">SO_REUSEADDR</span> only</b>:</h3>
<ul>
<li>Multiple sockets in the same process or in different processes can bind to the same port, <b>but only if all of them set <span class="tt">SO_REUSEADDR</span> before binding</b>.</li>
<li>However, <b>only the last socket to bind will receive incoming connections</b>.</li>
<li>The others remain bound but receive <b>no data</b>.</li>
<li>This behavior is often <b>misunderstood</b> and may lead to subtle bugs if used incorrectly.</li>
<li>Example use case: Restarting a server that was listening on a port stuck in <span class="tt">TIME_WAIT</span>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md119"></a>
<b>With <span class="tt">SO_REUSEADDR</span> + <span class="tt">SO_REUSEPORT</span></b>:</h3>
<ul>
<li>All sockets that bind to the same port <b>and set both options</b> before binding can <b>receive connections concurrently **.</b></li>
<li><b>The kernel performs **load balancing</b> among the sockets.</li>
<li>Typically used by high-performance servers with <b>multi-threaded</b> or <b>multi-process</b> architectures.</li>
</ul>
<blockquote class="doxtable">
<p>‚ö†Ô∏è You must still ensure all sockets bind to the same address and port with matching options. Any inconsistency can lead to undefined behavior or silent failure. </p>
</blockquote>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md121"></a>
Windows</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md122"></a>
<b>With <span class="tt">SO_REUSEADDR</span></b>:</h3>
<ul>
<li><b>Highly permissive</b>, and potentially dangerous.</li>
<li>Allows <b>multiple processes</b> to bind to the <b>same port</b> even if another process is already using it.</li>
<li>If multiple sockets bind to the same port (even in different processes), <b>they may all receive the same data</b>, leading to:<ul>
<li>Data duplication</li>
<li>Message interleaving</li>
<li>Connection hijacking</li>
</ul>
</li>
<li>This is <b>unsafe for server sockets</b> and is <b>not recommended</b>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md123"></a>
<b>With <span class="tt">SO_EXCLUSIVEADDRUSE</span> (default in jsocketpp)</b>:</h3>
<ul>
<li>Prevents any other socket or process from binding to the same port <b>until the current socket is closed</b>.</li>
<li>The safest and most predictable behavior on Windows.</li>
<li>If another process tries to bind to the port, <span class="tt">bind()</span> fails with <span class="tt">WSAEADDRINUSE</span>.</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md125"></a>
Summary Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Platform  </th><th class="markdownTableHeadNone">Socket Option(s)  </th><th class="markdownTableHeadNone">Multiple Binds  </th><th class="markdownTableHeadNone">Who Receives Data?  </th><th class="markdownTableHeadNone">Safe?  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unix/Linux  </td><td class="markdownTableBodyNone"><span class="tt">SO_REUSEADDR</span>  </td><td class="markdownTableBodyNone">‚úÖ (if all set)  </td><td class="markdownTableBodyNone">‚ùå Only the last one to bind  </td><td class="markdownTableBodyNone">‚ö†Ô∏è Caution  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Unix/Linux  </td><td class="markdownTableBodyNone"><span class="tt">SO_REUSEADDR + REUSEPORT</span>  </td><td class="markdownTableBodyNone">‚úÖ  </td><td class="markdownTableBodyNone">‚úÖ All sockets (load balanced)  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Windows  </td><td class="markdownTableBodyNone"><span class="tt">SO_REUSEADDR</span>  </td><td class="markdownTableBodyNone">‚úÖ  </td><td class="markdownTableBodyNone">‚ùå All sockets (data race, unsafe)  </td><td class="markdownTableBodyNone">‚ùå No  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Windows  </td><td class="markdownTableBodyNone"><span class="tt">SO_EXCLUSIVEADDRUSE</span>  </td><td class="markdownTableBodyNone">‚ùå  </td><td class="markdownTableBodyNone">‚úÖ One socket exclusively  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
</table>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md127"></a>
‚ö†Ô∏è Java‚Äôs Approach and Its Limitations</h1>
<p>Java‚Äôs networking API attempts to simplify socket configuration across platforms, but this comes at a cost ‚Äî particularly on Windows.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md128"></a>
What Java Does</h2>
<ul>
<li>The <span class="tt">ServerSocket</span> class in Java <b>automatically enables <span class="tt">SO_REUSEADDR</span></b> by default.</li>
<li>This allows quick server restarts without waiting for the previous socket to fully leave the <span class="tt">TIME_WAIT</span> state.</li>
<li>This behavior matches Unix/Linux expectations but <b>does not distinguish between platforms</b>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md129"></a>
Why This is Problematic on Windows</h2>
<p>On Windows, enabling <span class="tt">SO_REUSEADDR</span> <b>does not behave the same way</b>:</p>
<ul>
<li>It allows <b>multiple sockets across different processes</b> to bind to the <b>same port</b> concurrently.</li>
<li>This can cause:<ul>
<li><b>Race conditions</b>: Two servers listening on the same port may both receive traffic unpredictably.</li>
<li><b>Security risks</b>: Malicious or accidental hijacking of network traffic.</li>
<li><b>Debugging nightmares</b>: Symptoms may not appear until runtime, and are often non-deterministic.</li>
</ul>
</li>
</ul>
<p>Java <b>does not use</b> <span class="tt">SO_EXCLUSIVEADDRUSE</span>, which would prevent this issue and is considered the safe default for Windows server sockets.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md131"></a>
Summary of Java‚Äôs Design Trade-Off</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Platform  </th><th class="markdownTableHeadNone">Behavior  </th><th class="markdownTableHeadNone">Consequence  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unix  </td><td class="markdownTableBodyNone">Enables <span class="tt">SO_REUSEADDR</span>  </td><td class="markdownTableBodyNone">Matches expectations. Allows restarts. Safe.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Windows  </td><td class="markdownTableBodyNone">Enables <span class="tt">SO_REUSEADDR</span> only  </td><td class="markdownTableBodyNone">Unsafe. Allows multiple bindings. May cause data races.  </td></tr>
</table>
<ul>
<li>Java‚Äôs choice prioritizes <b>restartability and simplicity</b> over <b>strict correctness and security</b>.</li>
<li>While convenient on Linux, it leads to <b>risky behavior on Windows</b>, especially for long-running or concurrent server applications.</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md133"></a>
A Better Alternative: What <span class="tt">jsocketpp</span> Does</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature  </th><th class="markdownTableHeadNone">Java  </th><th class="markdownTableHeadNone">jsocketpp  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">OS-aware address reuse  </td><td class="markdownTableBodyNone">‚ùå No  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Safe default on Windows  </td><td class="markdownTableBodyNone">‚ùå Uses <span class="tt">REUSE</span>  </td><td class="markdownTableBodyNone">‚úÖ Uses <span class="tt">EXCLUSIVEADDRUSE</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Allows override via API  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Explains trade-offs  </td><td class="markdownTableBodyNone">‚ùå No  </td><td class="markdownTableBodyNone">‚úÖ Comprehensive docs  </td></tr>
</table>
<p>By handling <span class="tt">SO_REUSEADDR</span> and <span class="tt">SO_EXCLUSIVEADDRUSE</span> appropriately for each platform, <span class="tt"><a class="el" href="namespacejsocketpp.html" title="A C++ socket library providing Java-style networking interfaces.">jsocketpp</a></span> ensures:</p>
<ul>
<li>Safe, predictable binding behavior.</li>
<li>Compatibility with modern OS expectations.</li>
<li>Restartable servers without risk of hijacking.</li>
</ul>
<blockquote class="doxtable">
<p>‚úÖ This strategy avoids the shortcomings of Java‚Äôs one-size-fits-all approach while preserving flexibility for advanced users. </p>
</blockquote>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md135"></a>
‚úÖ Smarter Strategy for jsocketpp</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md136"></a>
Recommended Behavior</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">OS  </th><th class="markdownTableHeadNone">Reuse Option  </th><th class="markdownTableHeadNone">Behavior  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Windows  </td><td class="markdownTableBodyNone"><span class="tt">SO_EXCLUSIVEADDRUSE</span>  </td><td class="markdownTableBodyNone">Safe: prevents any other process from binding the port.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Unix  </td><td class="markdownTableBodyNone"><span class="tt">SO_REUSEADDR</span>  </td><td class="markdownTableBodyNone">Allows port reuse in <span class="tt">TIME_WAIT</span>, safe within a single process.  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="autotoc_md137"></a>
Constructor Defaults</h2>
<ul>
<li><span class="tt">ServerSocket</span> automatically enables safe defaults:<ul>
<li><span class="tt">setReuseAddress(true)</span> maps to:<ul>
<li><span class="tt">SO_EXCLUSIVEADDRUSE</span> on Windows</li>
<li><span class="tt">SO_REUSEADDR</span> on Unix/Linux</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md138"></a>
Developer Control</h2>
<ul>
<li><span class="tt">setReuseAddress(bool)</span> remains available to developers.</li>
<li>Must be called <b>before <span class="tt">bind()</span></b>.</li>
<li>Does nothing once the socket is bound.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md139"></a>
Why Not Expose Windows <span class="tt">SO_REUSEADDR</span>?</h2>
<ul>
<li>It‚Äôs simply unsafe and not aligned with best practices.</li>
<li>Allowing it would cause undefined behavior that‚Äôs hard to debug.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md141"></a>
üí° Summary Table</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option  </th><th class="markdownTableHeadNone">Platform  </th><th class="markdownTableHeadNone">Safe Default  </th><th class="markdownTableHeadNone">Allows Multiple Binds  </th><th class="markdownTableHeadNone">Allows TIME_WAIT Reuse  </th><th class="markdownTableHeadNone">Notes  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">SO_REUSEADDR</span>  </td><td class="markdownTableBodyNone">Unix  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td><td class="markdownTableBodyNone">‚ö†Ô∏è Last bind wins  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td><td class="markdownTableBodyNone">OK for restarts  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">SO_REUSEADDR</span>  </td><td class="markdownTableBodyNone">Windows  </td><td class="markdownTableBodyNone">‚ùå No  </td><td class="markdownTableBodyNone">‚ùå Unsafe  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td><td class="markdownTableBodyNone">Do not use for servers  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">SO_REUSEPORT</span>  </td><td class="markdownTableBodyNone">Unix  </td><td class="markdownTableBodyNone">Optional  </td><td class="markdownTableBodyNone">‚úÖ Yes (load balanced)  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td><td class="markdownTableBodyNone">For multi-thread/process performance  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">SO_EXCLUSIVEADDRUSE</span>  </td><td class="markdownTableBodyNone">Windows  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td><td class="markdownTableBodyNone">‚ùå No  </td><td class="markdownTableBodyNone">‚ùå No  </td><td class="markdownTableBodyNone">Ensures exclusive use  </td></tr>
</table>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md143"></a>
üìå Notes for Library Authors</h1>
<ul>
<li>Always apply reuse settings <b>before</b> calling <span class="tt">bind()</span>.</li>
<li>Prefer safe defaults tailored to each OS.</li>
<li>Make <span class="tt">setReuseAddress()</span> explicit in the API.</li>
<li>Optionally add warnings if unsafe options are requested.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md145"></a>
üîó References</h1>
<ul>
<li><a href="https://man7.org/linux/man-pages/man7/socket.7.html">socket(7) - Linux Man Pages</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/winsock/using-so-exclusiveaddruse">Microsoft Docs on <span class="tt">SO_EXCLUSIVEADDRUSE</span></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html">Java Socket Options</a></li>
<li><a href="https://lwn.net/Articles/542629/">Linux <span class="tt">SO_REUSEPORT</span></a></li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md147"></a>
‚úÖ Conclusion</h1>
<p>Correct handling of socket address reuse options is essential for writing reliable and portable server applications, especially when targeting both Unix-like systems and Windows.</p>
<p>By default, many programming environments (like Java) apply <span class="tt">SO_REUSEADDR</span> without considering the platform-specific nuances. While convenient on Unix, this can introduce serious issues on Windows due to how <span class="tt">SO_REUSEADDR</span> behaves there ‚Äî enabling unintentional port sharing and data delivery ambiguity.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md148"></a>
‚úî What jsocketpp Gets Right</h2>
<p>The <span class="tt"><a class="el" href="namespacejsocketpp.html" title="A C++ socket library providing Java-style networking interfaces.">jsocketpp</a></span> library provides <b>safe, OS-aware defaults</b> that follow best practices:</p>
<ul>
<li>On <b>Windows</b>, <span class="tt">setReuseAddress(true)</span> internally applies <span class="tt">SO_EXCLUSIVEADDRUSE</span>, ensuring exclusive port ownership and eliminating race conditions.</li>
<li>On <b>Unix/Linux</b>, <span class="tt">setReuseAddress(true)</span> enables <span class="tt">SO_REUSEADDR</span>, allowing fast socket rebinding in typical server restart scenarios.</li>
<li>The library <b>does not expose unsafe behavior</b> such as <span class="tt">SO_REUSEADDR</span> on Windows, avoiding security and stability risks.</li>
<li>It provides clear, documented methods for advanced control (<span class="tt">setOption</span>, <span class="tt">getOption</span>), while giving safe defaults to newcomers.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md149"></a>
üß† Beyond the Basics</h2>
<ul>
<li>Developers working on high-performance, multi-threaded servers can use <span class="tt">SO_REUSEPORT</span> (on Unix/Linux) for concurrency and graceful reloads.</li>
<li>With helper methods like <span class="tt">setReuseAddress()</span>, <span class="tt">isBound()</span>, and platform-adaptive behavior, <span class="tt"><a class="el" href="namespacejsocketpp.html" title="A C++ socket library providing Java-style networking interfaces.">jsocketpp</a></span> strikes a thoughtful balance between <b>Java-style simplicity</b> and <b>system-level flexibility</b>.</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md151"></a>
‚úÖ Best Practices Recap</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Platform  </th><th class="markdownTableHeadNone">Safe Reuse Option  </th><th class="markdownTableHeadNone">Default Behavior in jsocketpp  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unix  </td><td class="markdownTableBodyNone"><span class="tt">SO_REUSEADDR</span>  </td><td class="markdownTableBodyNone">Enabled via <span class="tt">setReuseAddress(true)</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Windows  </td><td class="markdownTableBodyNone"><span class="tt">SO_EXCLUSIVEADDRUSE</span>  </td><td class="markdownTableBodyNone">Enabled via <span class="tt">setReuseAddress(true)</span>  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature  </th><th class="markdownTableHeadNone">Unix (<span class="tt">SO_REUSEADDR</span>)  </th><th class="markdownTableHeadNone">Windows (<span class="tt">SO_EXCLUSIVEADDRUSE</span>)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Fast restart after TIME_WAIT  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td><td class="markdownTableBodyNone">‚úÖ Yes (if port is truly free)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Prevent other binds  </td><td class="markdownTableBodyNone">‚ö†Ô∏è No  </td><td class="markdownTableBodyNone">‚úÖ Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Multiple sockets on one port  </td><td class="markdownTableBodyNone">‚ùå No (unless with <span class="tt">SO_REUSEPORT</span>)  </td><td class="markdownTableBodyNone">‚ùå No  </td></tr>
</table>
<hr  />
<p>By designing with platform-specific behaviors in mind and exposing a clear, Java-inspired API, <span class="tt"><a class="el" href="namespacejsocketpp.html" title="A C++ socket library providing Java-style networking interfaces.">jsocketpp</a></span> helps developers avoid subtle pitfalls while remaining flexible and powerful. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
