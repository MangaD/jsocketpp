<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jsocketpp: Comprehensive List of Socket Programming Functions</title>
<link rel="icon" href="logo55px.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo55px.png"/></td>
  <td id="projectalign">
   <div id="projectname">jsocketpp<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A cross-platform C++20 socket library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__list__bsd__socket__functions.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Comprehensive List of Socket Programming Functions <div class="ingroups"><a class="el" href="group__docs.html">User Guides</a></div></div></div>
</div><!--header-->
<div class="contents">
<p>Below is a comprehensive list of commonly used functions in socket programming, focusing on the Berkeley Sockets API (also known as BSD sockets), which is widely used in C/C++ for network programming on Unix-like systems and Windows (via Winsock). Each function is described with its purpose, typical usage, and key details. This list includes functions for creating, configuring, binding, connecting, sending, receiving, and managing sockets, as well as utility functions for address handling. The descriptions aim to be concise yet informative, suitable for inclusion in a technical library to educate users about socket programming.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
1. Core Socket Creation and Management</h2>
<ul>
<li><b><span class="tt">socket()</span></b><ul>
<li><b>Purpose</b>: Creates a new socket.</li>
<li><b>Description</b>: Initializes a socket with a specified address family (e.g., <span class="tt">AF_INET</span> for IPv4, <span class="tt">AF_INET6</span> for IPv6), socket type (e.g., <span class="tt">SOCK_STREAM</span> for TCP, <span class="tt">SOCK_DGRAM</span> for UDP), and protocol (e.g., <span class="tt">IPPROTO_TCP</span> or <span class="tt">0</span> for default).</li>
<li><b>Usage</b>: <span class="tt">int socket(int domain, int type, int protocol);</span></li>
<li><b>Example</b>: <span class="tt">int sockfd = socket(AF_INET, SOCK_STREAM, 0);</span> creates a TCP socket for IPv4.</li>
<li><b>Returns</b>: A socket file descriptor on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">close()</span></b> (Unix) / <b><span class="tt">closesocket()</span></b> (Windows)<ul>
<li><b>Purpose</b>: Closes a socket and releases its resources.</li>
<li><b>Description</b>: Terminates the socket, freeing the file descriptor and any associated resources. On Unix, <span class="tt">close()</span> is used; on Windows, <span class="tt">closesocket()</span> is required.</li>
<li><b>Usage</b>: <span class="tt">int close(int sockfd);</span> or <span class="tt">int closesocket(SOCKET sockfd);</span></li>
<li><b>Example</b>: <span class="tt">close(sockfd);</span> closes a socket after use.</li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">shutdown()</span></b><ul>
<li><b>Purpose</b>: Disables sending or receiving on a socket.</li>
<li><b>Description</b>: Allows partial closure of a socket, disabling further send (<span class="tt">SHUT_WR</span>), receive (<span class="tt">SHUT_RD</span>), or both (<span class="tt">SHUT_RDWR</span>) operations, while keeping the socket open for the other direction if needed.</li>
<li><b>Usage</b>: <span class="tt">int shutdown(int sockfd, int how);</span></li>
<li><b>Example</b>: <span class="tt">shutdown(sockfd, SHUT_RDWR);</span> stops both sending and receiving.</li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
2. Address Binding and Connection</h2>
<ul>
<li><b><span class="tt">bind()</span></b><ul>
<li><b>Purpose</b>: Associates a socket with a local address and port.</li>
<li><b>Description</b>: Explicitly binds a socket to a local IP address and port, typically used by servers or clients needing specific local endpoints. The address structure (e.g., <span class="tt">sockaddr_in</span>) specifies the IP and port.</li>
<li><b>Usage</b>: <span class="tt">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></li>
<li><b>Example</b>: Binds a server socket to <span class="tt">0.0.0.0:8080</span> for listening on all interfaces.</li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error (e.g., address in use).</li>
</ul>
</li>
<li><b><span class="tt">connect()</span></b><ul>
<li><b>Purpose</b>: Initiates a connection to a remote address or sets a default remote address for UDP.</li>
<li><b>Description</b>: For TCP, establishes a connection to a remote server. For UDP, sets a default remote address for subsequent send/receive operations. Triggers implicit binding if <span class="tt">bind()</span> wasn’t called.</li>
<li><b>Usage</b>: <span class="tt">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></li>
<li><b>Example</b>: <span class="tt">connect(sockfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));</span> connects to a server.</li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">listen()</span></b><ul>
<li><b>Purpose</b>: Marks a socket as a listening socket for incoming connections (TCP only).</li>
<li><b>Description</b>: Prepares a TCP socket to accept incoming connections, specifying the maximum number of pending connections in the queue.</li>
<li><b>Usage</b>: <span class="tt">int listen(int sockfd, int backlog);</span></li>
<li><b>Example</b>: <span class="tt">listen(sockfd, 5);</span> allows up to 5 pending connections.</li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">accept()</span></b><ul>
<li><b>Purpose</b>: Accepts an incoming connection on a listening TCP socket.</li>
<li><b>Description</b>: Creates a new socket for an incoming client connection, returning the new socket’s file descriptor and the client’s address.</li>
<li><b>Usage</b>: <span class="tt">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></li>
<li><b>Example</b>: <span class="tt">int client_fd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;addrlen);</span></li>
<li><b>Returns</b>: New socket descriptor on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
3. Data Transfer</h2>
<ul>
<li><b><span class="tt">send()</span></b><ul>
<li><b>Purpose</b>: Sends data over a connected socket (TCP or connected UDP).</li>
<li><b>Description</b>: Transmits data to the remote endpoint of a connected socket. Used after <span class="tt">connect()</span> for TCP or UDP.</li>
<li><b>Usage</b>: <span class="tt">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span></li>
<li><b>Example</b>: <span class="tt">send(sockfd, "Hello", 5, 0);</span> sends a message.</li>
<li><b>Returns</b>: Number of bytes sent on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">sendto()</span></b><ul>
<li><b>Purpose</b>: Sends data to a specific remote address (typically UDP).</li>
<li><b>Description</b>: Sends data to a specified remote address, used for unconnected UDP sockets or when overriding the default address set by <span class="tt">connect()</span>.</li>
<li><b>Usage</b>: <span class="tt">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</span></li>
<li><b>Example</b>: Sends a UDP datagram to a specific address.</li>
<li><b>Returns</b>: Number of bytes sent, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">recv()</span></b><ul>
<li><b>Purpose</b>: Receives data from a connected socket (TCP or connected UDP).</li>
<li><b>Description</b>: Reads incoming data from a connected socket into a buffer.</li>
<li><b>Usage</b>: <span class="tt">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span></li>
<li><b>Example</b>: <span class="tt">recv(sockfd, buffer, sizeof(buffer), 0);</span> receives data.</li>
<li><b>Returns</b>: Number of bytes received, <span class="tt">0</span> on connection close (TCP), <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">recvfrom()</span></b><ul>
<li><b>Purpose</b>: Receives data and the sender’s address (typically UDP).</li>
<li><b>Description</b>: Reads incoming data and captures the sender’s address, used for unconnected UDP sockets or to identify the source of datagrams.</li>
<li><b>Usage</b>: <span class="tt">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span></li>
<li><b>Example</b>: Receives a UDP datagram and the sender’s address.</li>
<li><b>Returns</b>: Number of bytes received, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">sendmsg()</span></b><ul>
<li><b>Purpose</b>: Sends data with advanced options (e.g., multiple buffers).</li>
<li><b>Description</b>: Sends data using a <span class="tt">msghdr</span> structure, allowing control over multiple buffers, ancillary data, and flags. Useful for complex scenarios like sending file descriptors or control messages.</li>
<li><b>Usage</b>: <span class="tt">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</span></li>
<li><b>Example</b>: Used in advanced applications like passing file descriptors over Unix domain sockets.</li>
<li><b>Returns</b>: Number of bytes sent, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">recvmsg()</span></b><ul>
<li><b>Purpose</b>: Receives data with advanced options.</li>
<li><b>Description</b>: Receives data into multiple buffers with a <span class="tt">msghdr</span> structure, supporting ancillary data and detailed control. Often used in advanced UDP or Unix domain socket applications.</li>
<li><b>Usage</b>: <span class="tt">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</span></li>
<li><b>Example</b>: Receives data with sender information or control messages.</li>
<li><b>Returns</b>: Number of bytes received, <span class="tt">-1</span> on error.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
4. Address and Name Resolution</h2>
<ul>
<li><b><span class="tt">getaddrinfo()</span></b><ul>
<li><b>Purpose</b>: Resolves hostnames and service names to socket addresses.</li>
<li><b>Description</b>: Converts a hostname (e.g., "example.com") and service (e.g., "http" or "80") into a list of <span class="tt">sockaddr</span> structures, supporting both IPv4 and IPv6. Preferred over older functions like <span class="tt">gethostbyname()</span>.</li>
<li><b>Usage</b>: <span class="tt">int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);</span></li>
<li><b>Example</b>: <span class="tt">getaddrinfo("example.com", "80", &amp;hints, &amp;res);</span> resolves a web server address.</li>
<li><b>Returns</b>: <span class="tt">0</span> on success, non-zero error code on failure.</li>
</ul>
</li>
<li><b><span class="tt">freeaddrinfo()</span></b><ul>
<li><b>Purpose</b>: Frees memory allocated by <span class="tt">getaddrinfo()</span>.</li>
<li><b>Description</b>: Releases the linked list of <span class="tt">addrinfo</span> structures returned by <span class="tt">getaddrinfo()</span> to prevent memory leaks.</li>
<li><b>Usage</b>: <span class="tt">void freeaddrinfo(struct addrinfo *res);</span></li>
<li><b>Example</b>: <span class="tt">freeaddrinfo(res);</span> after using <span class="tt">getaddrinfo()</span> results.</li>
<li><b>Returns</b>: None.</li>
</ul>
</li>
<li><b><span class="tt">getnameinfo()</span></b><ul>
<li><b>Purpose</b>: Converts a socket address to hostname and service name.</li>
<li><b>Description</b>: Reverse-resolves a <span class="tt">sockaddr</span> structure to a hostname and service name, useful for logging or displaying client information.</li>
<li><b>Usage</b>: <span class="tt">int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *serv, size_t servlen, int flags);</span></li>
<li><b>Example</b>: Retrieves the hostname and port of a connected client.</li>
<li><b>Returns</b>: <span class="tt">0</span> on success, non-zero error code on failure.</li>
</ul>
</li>
<li><b><span class="tt">inet_addr()</span></b><ul>
<li><b>Purpose</b>: Converts an IPv4 address string to binary format.</li>
<li><b>Description</b>: Converts a dotted-decimal IPv4 address (e.g., "192.168.1.1") to a binary <span class="tt">in_addr_t</span>. Deprecated in favor of <span class="tt">inet_pton()</span>.</li>
<li><b>Usage</b>: <span class="tt">in_addr_t inet_addr(const char *cp);</span></li>
<li><b>Example</b>: <span class="tt">in_addr_t addr = inet_addr("192.168.1.1");</span></li>
<li><b>Returns</b>: Binary address or <span class="tt">INADDR_NONE</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">inet_ntoa()</span></b><ul>
<li><b>Purpose</b>: Converts a binary IPv4 address to a string.</li>
<li><b>Description</b>: Converts a binary <span class="tt">in_addr</span> structure to a dotted-decimal string. Deprecated in favor of <span class="tt">inet_ntop()</span>.</li>
<li><b>Usage</b>: <span class="tt">char *inet_ntoa(struct in_addr in);</span></li>
<li><b>Example</b>: <span class="tt">char *ip = inet_ntoa(addr.sin_addr);</span></li>
<li><b>Returns</b>: Pointer to a static string (not thread-safe).</li>
</ul>
</li>
<li><b><span class="tt">inet_pton()</span></b><ul>
<li><b>Purpose</b>: Converts an address string to binary format (IPv4 or IPv6).</li>
<li><b>Description</b>: Converts a presentation-format address (e.g., "192.168.1.1" or "2001:db8::1") to binary for a specified address family. Modern replacement for <span class="tt">inet_addr()</span>.</li>
<li><b>Usage</b>: <span class="tt">int inet_pton(int af, const char *src, void *dst);</span></li>
<li><b>Example</b>: <span class="tt">inet_pton(AF_INET, "192.168.1.1", &amp;addr.sin_addr);</span></li>
<li><b>Returns</b>: <span class="tt">1</span> on success, <span class="tt">0</span> on invalid input, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">inet_ntop()</span></b><ul>
<li><b>Purpose</b>: Converts a binary address to a string (IPv4 or IPv6).</li>
<li><b>Description</b>: Converts a binary address to a presentation-format string, supporting both IPv4 and IPv6. Safer and more modern than <span class="tt">inet_ntoa()</span>.</li>
<li><b>Usage</b>: <span class="tt">const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span></li>
<li><b>Example</b>: <span class="tt">inet_ntop(AF_INET, &amp;addr.sin_addr, ip_str, INET_ADDRSTRLEN);</span></li>
<li><b>Returns</b>: Pointer to the destination string on success, <span class="tt">NULL</span> on error.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
5. Socket Information and Configuration</h2>
<ul>
<li><b><span class="tt">getsockname()</span></b><ul>
<li><b>Purpose</b>: Retrieves the local address bound to a socket.</li>
<li><b>Description</b>: Returns the local IP address and port associated with a socket, useful for determining the assigned address after implicit binding.</li>
<li><b>Usage</b>: <span class="tt">int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></li>
<li><b>Example</b>: <span class="tt">getsockname(sockfd, (struct sockaddr*)&amp;local_addr, &amp;addrlen);</span></li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">getpeername()</span></b><ul>
<li><b>Purpose</b>: Retrieves the remote address of a connected socket.</li>
<li><b>Description</b>: Returns the IP address and port of the remote endpoint for a connected socket (TCP or connected UDP).</li>
<li><b>Usage</b>: <span class="tt">int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></li>
<li><b>Example</b>: <span class="tt">getpeername(sockfd, (struct sockaddr*)&amp;peer_addr, &amp;addrlen);</span></li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">getsockopt()</span></b><ul>
<li><b>Purpose</b>: Retrieves socket options.</li>
<li><b>Description</b>: Queries the current value of a socket option, such as buffer sizes, timeout settings, or protocol-specific options.</li>
<li><b>Usage</b>: <span class="tt">int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);</span></li>
<li><b>Example</b>: <span class="tt">getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, &amp;optlen);</span></li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">setsockopt()</span></b><ul>
<li><b>Purpose</b>: Sets socket options.</li>
<li><b>Description</b>: Configures socket options, such as enabling reuse of addresses (<span class="tt">SO_REUSEADDR</span>), setting timeouts, or adjusting buffer sizes.</li>
<li><b>Usage</b>: <span class="tt">int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</span></li>
<li><b>Example</b>: <span class="tt">setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span></li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
6. Non-Blocking and Asynchronous I/O</h2>
<ul>
<li><b><span class="tt">select()</span></b><ul>
<li><b>Purpose</b>: Monitors multiple sockets for I/O readiness.</li>
<li><b>Description</b>: Checks a set of sockets for readability, writability, or errors, with an optional timeout. Used for multiplexing I/O operations.</li>
<li><b>Usage</b>: <span class="tt">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span></li>
<li><b>Example</b>: Monitors multiple sockets for incoming data.</li>
<li><b>Returns</b>: Number of ready descriptors, <span class="tt">0</span> on timeout, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">poll()</span></b><ul>
<li><b>Purpose</b>: Monitors sockets for events, similar to <span class="tt">select()</span>.</li>
<li><b>Description</b>: More scalable than <span class="tt">select()</span>, it monitors sockets for events (e.g., <span class="tt">POLLIN</span>, <span class="tt">POLLOUT</span>) with a specified timeout.</li>
<li><b>Usage</b>: <span class="tt">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span></li>
<li><b>Example</b>: Polls a set of sockets for incoming data or errors.</li>
<li><b>Returns</b>: Number of ready descriptors, <span class="tt">0</span> on timeout, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">epoll_create()</span></b> (Linux-specific)<ul>
<li><b>Purpose</b>: Creates an epoll instance for efficient I/O event monitoring.</li>
<li><b>Description</b>: Initializes an epoll instance for scalable I/O event handling, used with <span class="tt">epoll_ctl()</span> and <span class="tt">epoll_wait()</span>.</li>
<li><b>Usage</b>: <span class="tt">int epoll_create(int size);</span> (size is a hint, ignored in modern kernels).</li>
<li><b>Example</b>: <span class="tt">int epfd = epoll_create(1);</span></li>
<li><b>Returns</b>: Epoll file descriptor on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">epoll_ctl()</span></b> (Linux-specific)<ul>
<li><b>Purpose</b>: Manages epoll interest list.</li>
<li><b>Description</b>: Adds, modifies, or removes sockets from an epoll instance, specifying events to monitor (e.g., <span class="tt">EPOLLIN</span>, <span class="tt">EPOLLOUT</span>).</li>
<li><b>Usage</b>: <span class="tt">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span></li>
<li><b>Example</b>: Adds a socket to an epoll instance for monitoring.</li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">epoll_wait()</span></b> (Linux-specific)<ul>
<li><b>Purpose</b>: Waits for events on an epoll instance.</li>
<li><b>Description</b>: Blocks until events occur on monitored sockets or a timeout is reached, returning ready sockets.</li>
<li><b>Usage</b>: <span class="tt">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span></li>
<li><b>Example</b>: Waits for I/O events on multiple sockets.</li>
<li><b>Returns</b>: Number of ready events, <span class="tt">0</span> on timeout, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">fcntl()</span></b><ul>
<li><b>Purpose</b>: Sets socket to non-blocking mode (among other uses).</li>
<li><b>Description</b>: Modifies socket properties, such as enabling non-blocking I/O with <span class="tt">O_NONBLOCK</span>.</li>
<li><b>Usage</b>: <span class="tt">int fcntl(int sockfd, int cmd, ...);</span></li>
<li><b>Example</b>: <span class="tt">fcntl(sockfd, F_SETFL, O_NONBLOCK);</span> enables non-blocking mode.</li>
<li><b>Returns</b>: Depends on command, typically <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">ioctl()</span></b><ul>
<li><b>Purpose</b>: Controls socket properties (e.g., non-blocking mode, interface info).</li>
<li><b>Description</b>: Performs device-specific operations, such as setting non-blocking mode or retrieving interface information.</li>
<li><b>Usage</b>: <span class="tt">int ioctl(int sockfd, unsigned long request, ...);</span></li>
<li><b>Example</b>: <span class="tt">ioctl(sockfd, FIONBIO, &amp;nonblock);</span> enables non-blocking I/O.</li>
<li><b>Returns</b>: <span class="tt">0</span> on success, <span class="tt">-1</span> on error.</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md32"></a>
7. Miscellaneous</h2>
<ul>
<li><b><span class="tt">gethostbyname()</span></b> (Deprecated)<ul>
<li><b>Purpose</b>: Resolves a hostname to an IPv4 address.</li>
<li><b>Description</b>: Converts a hostname to a binary IPv4 address. Replaced by <span class="tt">getaddrinfo()</span> for IPv6 support and thread safety.</li>
<li><b>Usage</b>: <span class="tt">struct hostent *gethostbyname(const char *name);</span></li>
<li><b>Example</b>: Resolves "example.com" to an IP address.</li>
<li><b>Returns</b>: Pointer to <span class="tt">hostent</span> structure or <span class="tt">NULL</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">gethostbyaddr()</span></b> (Deprecated)<ul>
<li><b>Purpose</b>: Resolves an IP address to a hostname.</li>
<li><b>Description</b>: Performs reverse DNS lookup for an IPv4 address. Replaced by <span class="tt">getnameinfo()</span>.</li>
<li><b>Usage</b>: <span class="tt">struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);</span></li>
<li><b>Example</b>: Resolves an IP address to a hostname.</li>
<li><b>Returns</b>: Pointer to <span class="tt">hostent</span> structure or <span class="tt">NULL</span> on error.</li>
</ul>
</li>
<li><b><span class="tt">htons()</span></b> / <b><span class="tt">htonl()</span></b><ul>
<li><b>Purpose</b>: Converts short/long integers from host to network byte order.</li>
<li><b>Description</b>: Ensures proper byte order for port numbers (<span class="tt">htons</span>) or IP addresses (<span class="tt">htonl</span>) across different architectures.</li>
<li><b>Usage</b>: <span class="tt">uint16_t htons(uint16_t hostshort);</span> / <span class="tt">uint32_t htonl(uint32_t hostlong);</span></li>
<li><b>Example</b>: <span class="tt">serv_addr.sin_port = htons(8080);</span></li>
<li><b>Returns</b>: Converted value.</li>
</ul>
</li>
<li><b><span class="tt">ntohs()</span></b> / <b><span class="tt">ntohl()</span></b><ul>
<li><b>Purpose</b>: Converts short/long integers from network to host byte order.</li>
<li><b>Description</b>: Reverses <span class="tt">htons()</span>/<span class="tt">htonl()</span> for interpreting received data.</li>
<li><b>Usage</b>: <span class="tt">uint16_t ntohs(uint16_t netshort);</span> / <span class="tt">uint32_t ntohl(uint32_t netlong);</span></li>
<li><b>Example</b>: <span class="tt">port = ntohs(addr.sin_port);</span></li>
<li><b>Returns</b>: Converted value.</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
Notes</h1>
<ul>
<li><b>Platform Differences</b>: On Windows, the Winsock API requires <span class="tt">WSAStartup()</span> to initialize the socket library and <span class="tt">WSACleanup()</span> to clean up. Most functions listed above are available in Winsock, but <span class="tt">closesocket()</span> replaces <span class="tt">close()</span>, and some functions (e.g., <span class="tt">epoll_*</span>) are Linux-specific.</li>
<li><b>Deprecated Functions</b>: Functions like <span class="tt">gethostbyname()</span>, <span class="tt">gethostbyaddr()</span>, <span class="tt">inet_addr()</span>, and <span class="tt">inet_ntoa()</span> are deprecated due to lack of IPv6 support and thread-safety issues. Use <span class="tt">getaddrinfo()</span>, <span class="tt">getnameinfo()</span>, <span class="tt">inet_pton()</span>, and <span class="tt">inet_ntop()</span> instead.</li>
<li><b>Error Handling</b>: Most functions return <span class="tt">-1</span> on error, with the error code stored in <span class="tt">errno</span> (Unix) or retrievable via <span class="tt">WSAGetLastError()</span> (Windows).</li>
<li><b>Non-Blocking I/O</b>: Functions like <span class="tt">select()</span>, <span class="tt">poll()</span>, and <span class="tt">epoll_*</span> are critical for handling multiple sockets efficiently, especially in high-performance servers.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md34"></a>
Example Usage Context</h1>
<p>The following pseudocode illustrates a typical TCP server using several of these functions:</p><ol type="1">
<li>Resolve server address with <span class="tt">getaddrinfo()</span>.</li>
<li>Create a socket with <span class="tt">socket()</span>.</li>
<li>Set options like <span class="tt">SO_REUSEADDR</span> with <span class="tt">setsockopt()</span>.</li>
<li>Bind to a local address with <span class="tt">bind()</span>.</li>
<li>Listen for connections with <span class="tt">listen()</span>.</li>
<li>Accept client connections with <span class="tt">accept()</span>.</li>
<li>Send/receive data with <span class="tt">send()</span>/<span class="tt">recv()</span>.</li>
<li>Close the socket with <span class="tt">close()</span>.</li>
</ol>
<p>For a UDP client:</p><ol type="1">
<li>Resolve server address with <span class="tt">getaddrinfo()</span>.</li>
<li>Create a socket with <span class="tt">socket()</span>.</li>
<li>Optionally bind with <span class="tt">bind()</span> or let <span class="tt">connect()</span>/<span class="tt">sendto()</span> trigger implicit binding.</li>
<li>Send data with <span class="tt">sendto()</span> or receive with <span class="tt">recvfrom()</span>.</li>
<li>Close the socket with <span class="tt">close()</span>.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md35"></a>
Conclusion</h1>
<p>This list covers the essential functions for socket programming in the Berkeley Sockets API, providing a foundation for building network applications. Each function serves a specific role, from creating and configuring sockets to handling data transfer and address resolution. By understanding these functions, developers can create robust client-server applications for both TCP and UDP protocols. This guide is a valuable resource for your library, offering clear explanations and examples to educate users on socket programming. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
