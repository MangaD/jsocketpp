<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jsocketpp: Core Utilities and Types</title>
<link rel="icon" href="logo55px.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo55px.png"/></td>
  <td id="projectalign">
   <div id="projectname">jsocketpp<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A cross-platform C++20 socket library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__core.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Core Utilities and Types <div class="ingroups"><a class="el" href="group__jsocketpp.html">jsocketpp: C++20 cross-platform socket library</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Internal types, platform abstractions, and utility functions used across the jsocketpp library.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Core Utilities and Types:</div>
<div class="dyncontent">
<div class="center"><img src="group__core.png" border="0" usemap="#agroup____core" loading="lazy" alt=""/></div>
<map name="agroup____core" id="agroup____core">
<area shape="rect" title="Internal types, platform abstractions, and utility functions used across the jsocketpp library." alt="" coords="230,5,364,50"/>
<area shape="rect" href="group__jsocketpp.html" title="All core classes and functions of the jsocketpp networking library." alt="" coords="5,5,182,50"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:jsocketpp_3A_3Anet" id="r_jsocketpp_3A_3Anet"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejsocketpp_1_1net.html">jsocketpp::net</a></td></tr>
<tr class="memdesc:namespacejsocketpp_1_1net"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endianness utilities for network byte order conversion. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jsocketpp_3A_3ABufferView" id="r_jsocketpp_3A_3ABufferView"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsocketpp_1_1BufferView.html">jsocketpp::BufferView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a raw writable memory region for scatter/gather I/O.  <a href="structjsocketpp_1_1BufferView.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1a7be273748ae3d91bc5ebe6499788a7" id="r_ga1a7be273748ae3d91bc5ebe6499788a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1a7be273748ae3d91bc5ebe6499788a7">jsocketpp::Port</a> = std::uint16_t</td></tr>
<tr class="memdesc:ga1a7be273748ae3d91bc5ebe6499788a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing a TCP or UDP port number (1–65535).  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab0ac1b9850480abafeb047a4f96792a0" id="r_gab0ac1b9850480abafeb047a4f96792a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab0ac1b9850480abafeb047a4f96792a0">jsocketpp::isIPv4MappedIPv6</a> (const sockaddr_in6 *addr6)</td></tr>
<tr class="memdesc:gab0ac1b9850480abafeb047a4f96792a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given sockaddr_in6 represents an IPv4-mapped IPv6 address.  <br /></td></tr>
<tr class="memitem:ga4da3763b1f8385b27ebbe44cdcfdfc8d" id="r_ga4da3763b1f8385b27ebbe44cdcfdfc8d"><td class="memItemLeft" align="right" valign="top">sockaddr_in&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4da3763b1f8385b27ebbe44cdcfdfc8d">jsocketpp::convertIPv4MappedIPv6ToIPv4</a> (const sockaddr_in6 &amp;addr6)</td></tr>
<tr class="memdesc:ga4da3763b1f8385b27ebbe44cdcfdfc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an IPv4-mapped IPv6 address to a pure IPv4 sockaddr_in.  <br /></td></tr>
<tr class="memitem:gac7021e2ae20ca2e2effd13f3279a4739" id="r_gac7021e2ae20ca2e2effd13f3279a4739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac7021e2ae20ca2e2effd13f3279a4739">jsocketpp::internal::resolveNumericHostPort</a> (const sockaddr *sa, const socklen_t len, std::string &amp;host, <a class="el" href="#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> &amp;port)</td></tr>
<tr class="memdesc:gac7021e2ae20ca2e2effd13f3279a4739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve numeric host and port from a socket address.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gafa19c7cbeb622b106835021215b8d6b7" id="r_gafa19c7cbeb622b106835021215b8d6b7"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafa19c7cbeb622b106835021215b8d6b7">jsocketpp::DefaultBufferSize</a> = 4096</td></tr>
<tr class="memdesc:gafa19c7cbeb622b106835021215b8d6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default internal buffer size (in bytes) for socket read operations.  <br /></td></tr>
<tr class="memitem:ga2fb9d73742801c62e90aeb505c618c43" id="r_ga2fb9d73742801c62e90aeb505c618c43"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2fb9d73742801c62e90aeb505c618c43">jsocketpp::DefaultDatagramReceiveSize</a> = 8192</td></tr>
<tr class="memdesc:ga2fb9d73742801c62e90aeb505c618c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fallback receive size (in bytes) for UDP datagrams when the exact size is unknown.  <br /></td></tr>
<tr class="memitem:ga25eb16703a608853bca500682345bb89" id="r_ga25eb16703a608853bca500682345bb89"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga25eb16703a608853bca500682345bb89">jsocketpp::MaxDatagramPayloadSafe</a> = 65507</td></tr>
<tr class="memdesc:ga25eb16703a608853bca500682345bb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum UDP payload size (in bytes) that is safely valid across common stacks.  <br /></td></tr>
<tr class="memitem:ga63ed4637719268844616341e0f8908cb" id="r_ga63ed4637719268844616341e0f8908cb"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga63ed4637719268844616341e0f8908cb">jsocketpp::MaxUdpPayloadIPv4</a> = 65507</td></tr>
<tr class="memdesc:ga63ed4637719268844616341e0f8908cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum UDP payload size (in bytes) over IPv4.  <br /></td></tr>
<tr class="memitem:ga041bcd9d09d1d8e134c7b8af72523d66" id="r_ga041bcd9d09d1d8e134c7b8af72523d66"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga041bcd9d09d1d8e134c7b8af72523d66">jsocketpp::MaxUdpPayloadIPv6</a> = 65527</td></tr>
<tr class="memdesc:ga041bcd9d09d1d8e134c7b8af72523d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Theoretical maximum UDP payload size (in bytes) over IPv6.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Internal types, platform abstractions, and utility functions used across the jsocketpp library. </p>
<p>This group contains foundational components of the jsocketpp socket library, including common type aliases, byte-order conversion utilities, and cross-platform compatibility helpers.</p>
<p>Components in this group are typically not used directly by application-level code, but are essential for internal implementation and protocol correctness.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md595"></a>
Includes:</h3>
<ul>
<li><span class="tt"><a class="el" href="#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">jsocketpp::Port</a></span> – type alias for network ports</li>
<li><span class="tt"><a class="el" href="namespacejsocketpp_1_1net.html" title="Endianness utilities for network byte order conversion.">jsocketpp::net</a></span> – byte order conversion utilities (host ↔ network)</li>
<li>Platform-specific type abstractions (<span class="tt">SOCKET</span>, <span class="tt">INVALID_SOCKET</span>, etc.)</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejsocketpp_1_1net.html" title="Endianness utilities for network byte order conversion.">jsocketpp::net</a> </dd>
<dd>
Port </dd></dl>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga1a7be273748ae3d91bc5ebe6499788a7" name="ga1a7be273748ae3d91bc5ebe6499788a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a7be273748ae3d91bc5ebe6499788a7">&#9670;&#160;</a></span>Port</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga1a7be273748ae3d91bc5ebe6499788a7">jsocketpp::Port</a> = std::uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias representing a TCP or UDP port number (1–65535). </p>
<p>This alias provides strong typing for network port numbers across the <span class="tt"><a class="el" href="namespacejsocketpp.html" title="A C++ socket library providing Java-style networking interfaces.">jsocketpp</a></span> library. It improves readability and makes function signatures semantically clearer when dealing with socket operations.</p>
<p>Using <span class="tt"><a class="el" href="#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a></span> instead of a plain <span class="tt">uint16_t</span> or <span class="tt">unsigned short</span> helps:</p><ul>
<li>Differentiate port values from other numeric parameters</li>
<li>Assist with static analysis and overload resolution</li>
<li>Align with best practices in modern C++ design</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Although a <span class="tt"><a class="el" href="#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a></span> is technically an integer, it represents a well-defined semantic domain (TCP/UDP port number). </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga4da3763b1f8385b27ebbe44cdcfdfc8d" name="ga4da3763b1f8385b27ebbe44cdcfdfc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da3763b1f8385b27ebbe44cdcfdfc8d">&#9670;&#160;</a></span>convertIPv4MappedIPv6ToIPv4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sockaddr_in jsocketpp::convertIPv4MappedIPv6ToIPv4 </td>
          <td>(</td>
          <td class="paramtype">const sockaddr_in6 &amp;</td>          <td class="paramname"><span class="paramname"><em>addr6</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an IPv4-mapped IPv6 address to a pure IPv4 sockaddr_in. </p>
<p>This function extracts the embedded IPv4 address from an IPv4-mapped IPv6 address. It preserves the port number and fills a fully valid <span class="tt">sockaddr_in</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md610"></a>
Preconditions</h3>
<ul>
<li>The input must be an IPv4-mapped IPv6 address.</li>
<li>You should call <span class="tt"><a class="el" href="#gab0ac1b9850480abafeb047a4f96792a0" title="Checks if a given sockaddr_in6 represents an IPv4-mapped IPv6 address.">isIPv4MappedIPv6()</a></span> before using this function.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr6</td><td>A sockaddr_in6 known to be IPv4-mapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sockaddr_in representing the embedded IPv4 address and port. </dd></dl>

</div>
</div>
<a id="gab0ac1b9850480abafeb047a4f96792a0" name="gab0ac1b9850480abafeb047a4f96792a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0ac1b9850480abafeb047a4f96792a0">&#9670;&#160;</a></span>isIPv4MappedIPv6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::isIPv4MappedIPv6 </td>
          <td>(</td>
          <td class="paramtype">const sockaddr_in6 *</td>          <td class="paramname"><span class="paramname"><em>addr6</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given sockaddr_in6 represents an IPv4-mapped IPv6 address. </p>
<p>IPv4-mapped IPv6 addresses allow IPv6-only sockets to interoperate with IPv4 clients by embedding an IPv4 address inside a special IPv6 format:</p>
<div class="fragment"><div class="line">::ffff:a.b.c.d   <span class="comment">// 0000:0000:0000:0000:0000:ffff:abcd:efgh</span></div>
</div><!-- fragment --><p>This function identifies such addresses so they can be normalized to pure IPv4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr6</td><td>Pointer to a sockaddr_in6 structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the address is IPv4-mapped; false otherwise. </dd></dl>

</div>
</div>
<a id="gac7021e2ae20ca2e2effd13f3279a4739" name="gac7021e2ae20ca2e2effd13f3279a4739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7021e2ae20ca2e2effd13f3279a4739">&#9670;&#160;</a></span>resolveNumericHostPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::internal::resolveNumericHostPort </td>
          <td>(</td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>sa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const socklen_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>port</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve numeric host and port from a socket address. </p>
<p>Calls <span class="tt">getnameinfo()</span> with <span class="tt">NI_NUMERICHOST | NI_NUMERICSERV</span> (and <span class="tt">NI_NUMERICSCOPE</span> where available) to obtain the sender’s <b>numeric</b> IP and service strings without DNS lookups. Parses the service string to a <span class="tt"><a class="el" href="#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a></span> and validates it fits the type’s range. On failure, throws using the library’s cross-platform <span class="tt">getnameinfo</span> error pattern.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sa</td><td>Pointer to a valid <span class="tt">sockaddr</span> (e.g., <span class="tt">sockaddr_in</span>/<span class="tt">sockaddr_in6</span>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of the structure pointed to by <code class="param">sa</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">host</td><td>Receives the numeric host string (e.g., <span class="tt">"192.0.2.10"</span>, <span class="tt">"fe80::1eth0"</span>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port</td><td>Receives the numeric service string (e.g., <span class="tt">"8080"</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If <span class="tt">getnameinfo()</span> fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses purely numeric resolution to avoid blocking DNS queries. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="gafa19c7cbeb622b106835021215b8d6b7" name="gafa19c7cbeb622b106835021215b8d6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa19c7cbeb622b106835021215b8d6b7">&#9670;&#160;</a></span>DefaultBufferSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::DefaultBufferSize = 4096</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default internal buffer size (in bytes) for socket read operations. </p>
<p>This constant defines the default size (4096 bytes / 4 KB) of the internal read buffer used across various socket classes in the library unless explicitly overridden.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md599"></a>
Applies to</h3>
<ul>
<li><b>TCP client sockets</b> (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>) when constructed without a custom <span class="tt">internalBufferSize</span></li>
<li><b>Accepted TCP sockets</b> via <span class="tt"><a class="el" href="group__tcp.html#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">ServerSocket::accept()</a></span></li>
<li><b>UDP sockets</b> (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>) when no explicit <span class="tt">bufferSize</span> is passed</li>
<li>May also serve as a guideline for other buffer sizes (e.g., send/receive buffers)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md600"></a>
Rationale</h3>
<ul>
<li><b>Memory-efficient:</b> 4096 bytes aligns with the typical memory page size on most systems.</li>
<li><b>Performance-optimized:</b> Large enough for common protocol messages (e.g., HTTP, DNS, WebSocket)</li>
<li><b>Concurrency-friendly:</b> Balances throughput and memory usage across many simultaneous sockets.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md601"></a>
Customization</h3>
<p>Override this value by:</p><ul>
<li>Passing a custom buffer size to socket constructors (e.g., <span class="tt">DatagramSocket(port, 8192)</span>)</li>
<li>Calling <span class="tt">setInternalBufferSize()</span> after construction</li>
<li>Tuning system-level buffers via <span class="tt">setReceiveBufferSize()</span> or <span class="tt">setSendBufferSize()</span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md602"></a>
When to Adjust</h3>
<p>Increase if:</p><ul>
<li>Your application transfers large datagrams or stream data (e.g., file uploads, media streams)</li>
<li>You want to reduce syscall overhead by reading more per call</li>
</ul>
<p>Decrease if:</p><ul>
<li>Operating in memory-constrained environments (e.g., embedded systems)</li>
<li>Managing a large number of idle sockets where footprint matters more than speed</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a> </dd>
<dd>
<a class="el" href="group__tcp.html#ga3fb196157a1cde167c47a596c9235c91" title="Sets the size of the internal read buffer used for string operations.">Socket::setInternalBufferSize()</a> </dd>
<dd>
<a class="el" href="group__socketopts.html#ga69fdecc0aaaef4bbd2826c448a8bbe1d" title="Sets the socket&#39;s receive buffer size (SO_RCVBUF).">SocketOptions::setReceiveBufferSize()</a> </dd>
<dd>
<a class="el" href="group__socketopts.html#ga8279b0c70f6a0fddf73d84aac691422b" title="Sets the socket&#39;s send buffer size (SO_SNDBUF).">SocketOptions::setSendBufferSize()</a> </dd></dl>

</div>
</div>
<a id="ga2fb9d73742801c62e90aeb505c618c43" name="ga2fb9d73742801c62e90aeb505c618c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fb9d73742801c62e90aeb505c618c43">&#9670;&#160;</a></span>DefaultDatagramReceiveSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::DefaultDatagramReceiveSize = 8192</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fallback receive size (in bytes) for UDP datagrams when the exact size is unknown. </p>
<p>This constant defines the <b>default number of bytes</b> we ask the OS to deliver when receiving a UDP datagram <b>and</b> the platform cannot report the pending datagram's exact size (via <span class="tt">FIONREAD</span> or the POSIX <span class="tt">MSG_PEEK|MSG_TRUNC</span> probe) <b>and</b> the caller has not provisioned <span class="tt">_internalBuffer</span> (i.e., its size is 0).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md603"></a>
Applies to</h3>
<ul>
<li><b>UDP sockets</b> (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>) in <span class="tt">read()</span> overloads that construct a <span class="tt">std::string</span> or otherwise need a temporary buffer when the exact size is unavailable and <span class="tt">_internalBuffer</span> is unset.</li>
<li>May be used by other UDP-related helpers where a conservative per-call buffer is required.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md604"></a>
Semantics &amp; policy</h3>
<ul>
<li>We <b>do not</b> resize <span class="tt">_internalBuffer</span> based on this value; it is a <em>one-shot</em> receive size when the caller has not sized a reusable buffer.</li>
<li>If the incoming datagram is <b>larger</b> than this value and the OS cannot tell us the exact size up-front, the payload may be <b>truncated</b> to this size (standard UDP behavior).</li>
<li>A safety cap of <b>65,507 bytes</b> (maximum safe UDP payload) is always honored, even if this constant is set higher.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md605"></a>
Rationale (default: 8192 / 8 KiB)</h3>
<ul>
<li><b>Practicality:</b> Big enough for common application messages while avoiding large, frequent allocations when size probing is unavailable.</li>
<li><b>Performance:</b> Reduces syscall overhead compared to very small defaults without bloating per-receive memory.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md606"></a>
Customization</h3>
<ul>
<li>Increase if your application expects larger datagrams and you prefer to minimize truncation when size probing is unavailable.</li>
<li>Decrease in memory-constrained environments if your datagrams are typically small.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md607"></a>
Examples</h3>
<div class="fragment"><div class="line"><span class="comment">// Typical path inside read&lt;std::string&gt;():</span></div>
<div class="line"><span class="comment">// 1) Try exact size via nextDatagramSize(fd)</span></div>
<div class="line"><span class="comment">// 2) If 0 and _internalBuffer.size() == 0, use DefaultDatagramReceiveSize</span></div>
<div class="line"><span class="comment">// 3) Read up to std::min(DefaultDatagramReceiveSize, 65507)</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>When <span class="tt">_internalBuffer</span> is already sized by the user, its capacity takes precedence as the "caller-provided buffer" (Java-like semantics); this constant is not used then.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejsocketpp_1_1internal.html#a592175a5a77f541b400879a5a4ca8978" title="Query the exact size of the next UDP datagram, if the platform can provide it.">jsocketpp::internal::nextDatagramSize()</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a id="ga25eb16703a608853bca500682345bb89" name="ga25eb16703a608853bca500682345bb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25eb16703a608853bca500682345bb89">&#9670;&#160;</a></span>MaxDatagramPayloadSafe</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::MaxDatagramPayloadSafe = 65507</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum UDP payload size (in bytes) that is safely valid across common stacks. </p>
<p>This constant represents a conservative upper bound for a single UDP payload that is widely supported across platforms and socket APIs. It equals the IPv4 maximum payload:</p>
<p>65,535 (IPv4 total length) − 20 (minimum IPv4 header) − 8 (UDP header) = 65,507 bytes</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md608"></a>
Why a "safe" cap?</h3>
<ul>
<li>Many APIs and stacks historically enforce the IPv4 limit even for IPv6 sockets for compatibility. Using this value avoids surprises (e.g., EMSGSIZE) and simplifies buffer sizing when the address family is not known in advance.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md609"></a>
Usage</h3>
<ul>
<li>Clamp opportunistic receive sizes to <code>MaxDatagramPayloadSafe</code> to prevent oversizing.</li>
<li>When sending, avoid constructing payloads larger than this unless you <em>know</em> you are on IPv6 and have validated larger limits (see <a class="el" href="#ga041bcd9d09d1d8e134c7b8af72523d66">MaxUdpPayloadIPv6</a>).</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga63ed4637719268844616341e0f8908cb" title="Maximum UDP payload size (in bytes) over IPv4.">MaxUdpPayloadIPv4</a> </dd>
<dd>
<a class="el" href="#ga041bcd9d09d1d8e134c7b8af72523d66" title="Theoretical maximum UDP payload size (in bytes) over IPv6.">MaxUdpPayloadIPv6</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a id="ga63ed4637719268844616341e0f8908cb" name="ga63ed4637719268844616341e0f8908cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63ed4637719268844616341e0f8908cb">&#9670;&#160;</a></span>MaxUdpPayloadIPv4</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::MaxUdpPayloadIPv4 = 65507</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum UDP payload size (in bytes) over IPv4. </p>
<p>Computed as: 65,535 (IPv4 total length) − 20 (IPv4 header) − 8 (UDP header) = 65,507 bytes. Use this when you know the socket/address family is IPv4.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a id="ga041bcd9d09d1d8e134c7b8af72523d66" name="ga041bcd9d09d1d8e134c7b8af72523d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga041bcd9d09d1d8e134c7b8af72523d66">&#9670;&#160;</a></span>MaxUdpPayloadIPv6</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::MaxUdpPayloadIPv6 = 65527</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Theoretical maximum UDP payload size (in bytes) over IPv6. </p>
<p>Computed as: 65,535 (IPv6 <em>payload</em> length, excludes the 40-byte IPv6 header) − 8 (UDP header) = 65,527 bytes.</p>
<dl class="section note"><dt>Note</dt><dd>Real-world effective limits can be smaller due to extension headers, PMTU, and stack constraints. Many stacks still behave as if the IPv4 limit applies. Prefer <a class="el" href="#ga25eb16703a608853bca500682345bb89">MaxDatagramPayloadSafe</a> unless you have verified larger datagrams are supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
