<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jsocketpp: Comprehensive Guide to the Socket API</title>
<link rel="icon" href="logo55px.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo55px.png"/></td>
  <td id="projectalign">
   <div id="projectname">jsocketpp<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A cross-platform C++20 socket library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__underlying__socket__api.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Comprehensive Guide to the Socket API <div class="ingroups"><a class="el" href="group__docs.html">User Guides</a></div></div></div>
</div><!--header-->
<div class="contents">
<p><a href="https://creativecommons.org/publicdomain/zero/1.0/"><img src="https://licensebuttons.net/p/zero/1.0/88x31.png" alt="CC0" class="inline"/></a></p>
<p><em>Disclaimer: Grok generated document</em>.</p>
<p>The Socket API is a foundational technology for network and inter-process communication, enabling processes to exchange data across networks or within a single system. Initially developed as part of Berkeley Software Distribution (BSD) UNIX in the early 1980s, the Socket API, often called the Berkeley sockets API, has become a standard interface for networked applications across platforms like Linux, Windows, and macOS. This article provides a thorough exploration of the Socket API, covering its architecture, address families, socket types, protocols, implementation details, practical examples, and advanced concepts.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md441"></a>
1. Introduction to the Socket API</h1>
<p>The Socket API provides a standardized interface for creating communication endpoints, called sockets, which allow processes to send and receive data. Sockets abstract the complexities of underlying protocols and operating system mechanisms, making them versatile for both network communication (e.g., over the Internet) and local inter-process communication (IPC). Sockets are used in applications ranging from web servers and browsers to real-time systems and distributed computing.</p>
<p>The API defines functions, data structures, and conventions for creating, configuring, and using sockets. Its portability and flexibility have made it a cornerstone of modern networking.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md442"></a>
2. Core Components of the Socket API</h1>
<p>The Socket API revolves around a set of core functions and concepts that define how sockets are created and managed.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md443"></a>
2.1 Key Functions</h2>
<p>The primary functions in the Socket API include:</p>
<ul>
<li><b><span class="tt">socket()</span></b>: Creates a new socket, specifying the address family, socket type, and protocol.</li>
<li><b><span class="tt">bind()</span></b>: Associates a socket with a specific address (e.g., IP address and port for network sockets, or a filesystem path for local sockets).</li>
<li><b><span class="tt">listen()</span></b>: Prepares a socket to accept incoming connections (used by servers).</li>
<li><b><span class="tt">accept()</span></b>: Accepts an incoming connection, creating a new socket for communication with the client.</li>
<li><b><span class="tt">connect()</span></b>: Initiates a connection to a remote socket (used by clients).</li>
<li><b><span class="tt">send()</span>/<span class="tt">recv()</span></b>: Sends or receives data on a connected socket.</li>
<li><b><span class="tt">write()</span>/<span class="tt">read()</span></b>: Alternative functions for sending/receiving data, often used with local sockets.</li>
<li><b><span class="tt">close()</span></b>: Closes a socket, releasing resources.</li>
<li><b><span class="tt">setsockopt()</span>/<span class="tt">getsockopt()</span></b>: Configures or retrieves socket options (e.g., buffer sizes, timeouts).</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md444"></a>
2.2 Address Families</h2>
<p>Sockets are categorized by their <b>address family</b>, which defines the communication domain and address format. Common address families include:</p>
<ul>
<li><b>AF_INET</b>: For IPv4-based Internet communication, using IP addresses and ports.</li>
<li><b>AF_INET6</b>: For IPv6, supporting larger address spaces.</li>
<li><b>AF_UNIX</b>: For local IPC on UNIX-like systems, using filesystem paths as addresses.</li>
<li><b>AF_PACKET</b>: For low-level packet communication, often used for network monitoring.</li>
<li><b>AF_BLUETOOTH</b>: For Bluetooth communication.</li>
<li><b>AF_VSOCK</b>: For communication between virtual machines and their host.</li>
</ul>
<p>Each address family supports specific protocols and addressing schemes, making the Socket API highly extensible.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md445"></a>
2.3 Socket Types</h2>
<p>The Socket API supports different socket types, which determine the communication semantics:</p>
<ul>
<li><b>SOCK_STREAM</b>: Provides reliable, connection-oriented, byte-stream communication (e.g., TCP for AF_INET, or stream-based IPC for AF_UNIX).</li>
<li><b>SOCK_DGRAM</b>: Supports connectionless, message-oriented communication (e.g., UDP for AF_INET, or datagram-based IPC for AF_UNIX).</li>
<li><b>SOCK_RAW</b>: Allows direct access to lower-level protocols (e.g., IP or ICMP), used for custom protocols or diagnostics.</li>
<li><b>SOCK_SEQPACKET</b>: Offers reliable, connection-oriented, message-based communication with preserved message boundaries.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md446"></a>
3. Communication Models</h1>
<p>The Socket API supports various communication models, tailored to different use cases.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md447"></a>
3.1 Client-Server Model</h2>
<p>The most common model, where a server listens for incoming connections and clients initiate connections:</p>
<ul>
<li><b>Server</b>: Calls <span class="tt">socket()</span>, <span class="tt">bind()</span>, <span class="tt">listen()</span>, <span class="tt">accept()</span>, then uses <span class="tt">send()</span>/<span class="tt">recv()</span> to communicate.</li>
<li><b>Client</b>: Calls <span class="tt">socket()</span>, <span class="tt">connect()</span>, then uses <span class="tt">send()</span>/<span class="tt">recv()</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md448"></a>
3.2 Peer-to-Peer Model</h2>
<p>Processes communicate as equals, often used with AF_UNIX or connectionless protocols like UDP. Both sides use <span class="tt">socket()</span>, <span class="tt">bind()</span>, and <span class="tt">sendto()</span>/<span class="tt">recvfrom()</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md449"></a>
3.3 Raw Socket Communication</h2>
<p>Raw sockets (SOCK_RAW) bypass higher-level protocols, allowing direct packet manipulation. They are used in tools like <span class="tt">ping</span> or network analyzers like Wireshark.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md450"></a>
4. Protocols and the Socket API</h1>
<p>The Socket API supports various protocols, depending on the address family and socket type:</p>
<ul>
<li><b>TCP (Transmission Control Protocol)</b>: Used with SOCK_STREAM and AF_INET/AF_INET6. Ensures reliable, ordered, and error-checked data delivery. Ideal for HTTP, FTP, or email.</li>
<li><b>UDP (User Datagram Protocol)</b>: Used with SOCK_DGRAM and AF_INET/AF_INET6. Provides fast, connectionless communication, suitable for DNS, streaming, or gaming.</li>
<li><b>ICMP (Internet Control Message Protocol)</b>: Used with SOCK_RAW for network diagnostics.</li>
<li><b>UNIX Domain Protocols</b>: For AF_UNIX, the protocol is often unspecified (set to 0), as communication occurs within the kernel.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md451"></a>
5. Socket API in Action: Practical Examples</h1>
<p>Below are examples of using the Socket API in different contexts: a TCP server/client using AF_INET in Python and a UDP client/server in C.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md452"></a>
5.1 TCP Server and Client (Python, AF_INET)</h2>
<div class="fragment"><div class="line"><span class="keyword">import</span> socket</div>
<div class="line"> </div>
<div class="line">HOST = <span class="stringliteral">&#39;127.0.0.1&#39;</span></div>
<div class="line">PORT = 65432</div>
<div class="line"> </div>
<div class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> server_socket:</div>
<div class="line">    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div>
<div class="line">    server_socket.bind((HOST, PORT))</div>
<div class="line">    server_socket.listen()</div>
<div class="line">    print(f<span class="stringliteral">&quot;Server listening on {HOST}:{PORT}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    conn, addr = server_socket.accept()</div>
<div class="line">    <span class="keyword">with</span> conn:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Connected by {addr}&quot;</span>)</div>
<div class="line">        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">            data = conn.recv(1024)</div>
<div class="line">            <span class="keywordflow">if</span> <span class="keywordflow">not</span> data:</div>
<div class="line">                <span class="keywordflow">break</span></div>
<div class="line">            print(f<span class="stringliteral">&quot;Received: {data.decode()}&quot;</span>)</div>
<div class="line">            conn.sendall(data)</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">import</span> socket</div>
<div class="line"> </div>
<div class="line">HOST = <span class="stringliteral">&#39;127.0.0.1&#39;</span></div>
<div class="line">PORT = 65432</div>
<div class="line"> </div>
<div class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> client_socket:</div>
<div class="line">    client_socket.connect((HOST, PORT))</div>
<div class="line">    message = b<span class="stringliteral">&quot;Hello, Server!&quot;</span></div>
<div class="line">    client_socket.sendall(message)</div>
<div class="line">    data = client_socket.recv(1024)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Received: {data.decode()}&quot;</span>)</div>
</div><!-- fragment --><p><b>How to Run</b>:</p>
<ol type="1">
<li>Run the server: <span class="tt">python3 tcp_server.py</span></li>
<li>Run the client: <span class="tt">python3 tcp_client.py</span></li>
</ol>
<p>The server listens on localhost:65432, accepts a connection, receives a message, and echoes it back.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md453"></a>
5.2 UDP Server and Client (C, AF_INET)</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/socket.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;netinet/in.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define PORT 65432</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE 1024</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="client_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> sockfd;</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in server_addr, client_addr;</div>
<div class="line">    <span class="keywordtype">char</span> buffer[BUFFER_SIZE];</div>
<div class="line">    socklen_t addr_len = <span class="keyword">sizeof</span>(client_addr);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create socket</span></div>
<div class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (sockfd == -1) {</div>
<div class="line">        perror(<span class="stringliteral">&quot;Socket creation failed&quot;</span>);</div>
<div class="line">        exit(EXIT_FAILURE);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set up server address</span></div>
<div class="line">    memset(&amp;server_addr, 0, <span class="keyword">sizeof</span>(server_addr));</div>
<div class="line">    server_addr.sin_family = AF_INET;</div>
<div class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</div>
<div class="line">    server_addr.sin_port = htons(PORT);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bind socket</span></div>
<div class="line">    <span class="keywordflow">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == -1) {</div>
<div class="line">        perror(<span class="stringliteral">&quot;Bind failed&quot;</span>);</div>
<div class="line">        exit(EXIT_FAILURE);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;UDP Server listening on port %d\n&quot;</span>, PORT);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Receive and echo message</span></div>
<div class="line">    <span class="keywordtype">int</span> bytes_received = recvfrom(sockfd, buffer, BUFFER_SIZE, 0, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;addr_len);</div>
<div class="line">    buffer[bytes_received] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Received: %s\n&quot;</span>, buffer);</div>
<div class="line">    sendto(sockfd, buffer, bytes_received, 0, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, addr_len);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Cleanup</span></div>
<div class="line">    close(sockfd);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="client_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> client.cpp:89</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/socket.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;netinet/in.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define PORT 65432</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE 1024</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="client_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> sockfd;</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in server_addr;</div>
<div class="line">    <span class="keywordtype">char</span> buffer[BUFFER_SIZE] = <span class="stringliteral">&quot;Hello, UDP Server!&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> response[BUFFER_SIZE];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create socket</span></div>
<div class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (sockfd == -1) {</div>
<div class="line">        perror(<span class="stringliteral">&quot;Socket creation failed&quot;</span>);</div>
<div class="line">        exit(EXIT_FAILURE);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set up server address</span></div>
<div class="line">    memset(&amp;server_addr, 0, <span class="keyword">sizeof</span>(server_addr));</div>
<div class="line">    server_addr.sin_family = AF_INET;</div>
<div class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="stringliteral">&quot;127.0.0.1&quot;</span>);</div>
<div class="line">    server_addr.sin_port = htons(PORT);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Send message</span></div>
<div class="line">    sendto(sockfd, buffer, strlen(buffer) + 1, 0, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</div>
<div class="line">    printf(<span class="stringliteral">&quot;Sent: %s\n&quot;</span>, buffer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Receive response</span></div>
<div class="line">    socklen_t addr_len = <span class="keyword">sizeof</span>(server_addr);</div>
<div class="line">    <span class="keywordtype">int</span> bytes_received = recvfrom(sockfd, response, BUFFER_SIZE, 0, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, &amp;addr_len);</div>
<div class="line">    response[bytes_received] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Received: %s\n&quot;</span>, response);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Cleanup</span></div>
<div class="line">    close(sockfd);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>How to Run</b>:</p>
<ol type="1">
<li>Compile: <span class="tt">gcc -o udp_server udp_server.c &amp;&amp; gcc -o udp_client udp_client.c</span></li>
<li>Run the server: <span class="tt">./udp_server</span></li>
<li>Run the client: <span class="tt">./udp_client</span></li>
</ol>
<p>The UDP server receives a datagram and echoes it back to the client.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md454"></a>
6. Advanced Socket API Features</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md455"></a>
6.1 Non-Blocking Sockets</h2>
<p>By default, socket operations are blocking. Non-blocking sockets, enabled via <span class="tt">fcntl()</span> or <span class="tt">ioctlsocket()</span>, allow asynchronous communication. Event-driven frameworks like <span class="tt">select()</span>, <span class="tt">poll()</span>, or <span class="tt">epoll()</span> (on Linux) manage multiple sockets efficiently.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md456"></a>
6.2 Socket Options</h2>
<p>The <span class="tt">setsockopt()</span> function configures socket behavior:</p>
<ul>
<li><b>SO_REUSEADDR</b>: Allows reuse of local addresses, useful for server restarts.</li>
<li><b>SO_KEEPALIVE</b>: Enables TCP keepalive to detect connection failures.</li>
<li><b>SO_SNDBUF/SO_RCVBUF</b>: Adjusts send/receive buffer sizes.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md457"></a>
6.3 Multicast and Broadcast</h2>
<p>UDP sockets can be configured for:</p>
<ul>
<li><b>Multicast</b>: Sending data to a group of recipients using <span class="tt">IP_ADD_MEMBERSHIP</span>.</li>
<li><b>Broadcast</b>: Sending to all devices on a network by setting <span class="tt">SO_BROADCAST</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md458"></a>
6.4 Asynchronous I/O</h2>
<p>Modern applications often use asynchronous I/O with frameworks like Python’s <span class="tt">asyncio</span>, Node.js, or C++’s Boost.Asio to handle multiple connections concurrently.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md459"></a>
7. Security Considerations</h1>
<ul>
<li><b>Encryption</b>: Use TLS/SSL for secure network communication (e.g., with OpenSSL or Python’s <span class="tt">ssl</span> module).</li>
<li><b>Access Control</b>: For AF_UNIX, use filesystem permissions to restrict socket access. For AF_INET, use firewalls to limit connections.</li>
<li><b>Input Validation</b>: Protect against buffer overflows or malformed data.</li>
<li><b>Denial-of-Service</b>: Implement rate limiting and connection timeouts.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md460"></a>
8. Use Cases and Applications</h1>
<p>The Socket API is used in:</p>
<ul>
<li><b>Web Servers</b>: Nginx and Apache use AF_INET sockets for HTTP/HTTPS.</li>
<li><b>Databases</b>: MySQL and PostgreSQL use both AF_INET and AF_UNIX for client connections.</li>
<li><b>Real-Time Systems</b>: WebSockets (built on TCP) power chat apps and gaming.</li>
<li><b>IoT</b>: Sockets connect devices to cloud services or local hubs.</li>
<li><b>Distributed Systems</b>: Frameworks like gRPC or ZeroMQ rely on sockets.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md461"></a>
9. Platform-Specific Considerations</h1>
<p>While the Socket API is portable, there are platform-specific nuances:</p>
<ul>
<li><b>Windows</b>: Uses Winsock (e.g., <span class="tt">WSAStartup()</span> is required).</li>
<li><b>UNIX/Linux</b>: Supports AF_UNIX and advanced features like <span class="tt">epoll</span>.</li>
<li><b>macOS</b>: Similar to UNIX but may have differences in socket options or performance.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md462"></a>
10. Conclusion</h1>
<p>The Socket API is a powerful and flexible interface for building networked and local communication systems. Its support for multiple address families (AF_INET, AF_INET6, AF_UNIX, etc.), socket types, and protocols makes it suitable for a wide range of applications. The provided examples demonstrate practical usage, while advanced features like non-blocking I/O and socket options enable scalable, high-performance systems. Developers can further explore the API by experimenting with different languages, protocols, and frameworks to build robust, networked applications.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md464"></a>
Advanced Socket API Features</h1>
<p>The advanced features of the Socket API enable developers to build high-performance, scalable, and robust networked applications. These features extend the basic functionality of sockets, addressing challenges like concurrency, resource management, and specialized communication patterns. Below is an in-depth exploration of the advanced Socket API features mentioned in section 6 of the previous article, expanded with additional details, practical examples, and considerations for real-world use.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md465"></a>
6.1 Non-Blocking Sockets</h3>
<p><b>Overview</b>: By default, socket operations like <span class="tt">accept()</span>, <span class="tt">recv()</span>, or <span class="tt">connect()</span> are blocking, meaning the calling process waits until the operation completes. Non-blocking sockets allow these operations to return immediately, enabling asynchronous communication where a program can handle multiple tasks concurrently without waiting for I/O operations to complete. This is critical for high-performance servers handling thousands of connections.</p>
<p><b>How It Works</b>:</p>
<ul>
<li>Non-blocking mode is enabled using system calls like <span class="tt">fcntl()</span> (UNIX/Linux) or <span class="tt">ioctlsocket()</span> (Windows). For example, setting the <span class="tt">O_NONBLOCK</span> flag on a socket file descriptor in UNIX makes operations non-blocking.</li>
<li>Non-blocking sockets typically return an error code (e.g., <span class="tt">EAGAIN</span> or <span class="tt">EWOULDBLOCK</span>) if an operation cannot be completed immediately, allowing the program to perform other tasks.</li>
</ul>
<p><b>Implementation</b>:</p>
<ul>
<li><b>UNIX/Linux</b>: Use <span class="tt">fcntl()</span> to set non-blocking mode: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div>
<div class="line"><span class="keywordtype">int</span> sockfd = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><span class="keywordtype">int</span> flags = fcntl(sockfd, F_GETFL, 0);</div>
<div class="line">fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);</div>
</div><!-- fragment --></li>
<li><b>Windows</b>: Use <span class="tt">ioctlsocket()</span>: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;winsock2.h&gt;</span></div>
<div class="line">SOCKET sockfd = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line">u_long mode = 1; <span class="comment">// 1 for non-blocking</span></div>
<div class="line">ioctlsocket(sockfd, FIONBIO, &amp;mode);</div>
</div><!-- fragment --></li>
</ul>
<p><b>Use with Event Loops</b>: Non-blocking sockets are often used with event-driven mechanisms to manage multiple connections:</p>
<ul>
<li><b><span class="tt">select()</span></b>: Monitors multiple file descriptors for readability, writability, or errors. Limited to 1024 descriptors on some systems.</li>
<li><b><span class="tt">poll()</span></b>: Similar to <span class="tt">select()</span> but scales better for large numbers of descriptors.</li>
<li><b><span class="tt">epoll()</span> (Linux)</b>: A high-performance alternative for Linux, using an event-driven model to handle thousands of connections efficiently.</li>
<li><b><span class="tt">kqueue()</span> (BSD/macOS)</b>: A similar high-performance mechanism for BSD-based systems.</li>
<li><b>Windows IOCP (I/O Completion Ports)</b>: A scalable mechanism for handling asynchronous I/O on Windows.</li>
</ul>
<p><b>Example (C, Non-Blocking Server with <span class="tt">select()</span>)</b>: This example shows a non-blocking TCP server using <span class="tt">select()</span> to handle multiple clients:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/socket.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;netinet/in.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/select.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define PORT 65432</span></div>
<div class="line"><span class="preprocessor">#define MAX_CLIENTS 10</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE 1024</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="client_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> server_fd, client_fds[MAX_CLIENTS] = {0};</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in server_addr, client_addr;</div>
<div class="line">    fd_set read_fds;</div>
<div class="line">    <span class="keywordtype">char</span> buffer[BUFFER_SIZE];</div>
<div class="line">    socklen_t addr_len = <span class="keyword">sizeof</span>(client_addr);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create server socket</span></div>
<div class="line">    server_fd = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (server_fd == -1) { perror(<span class="stringliteral">&quot;Socket creation failed&quot;</span>); exit(1); }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set non-blocking</span></div>
<div class="line">    fcntl(server_fd, F_SETFL, O_NONBLOCK);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set up server address</span></div>
<div class="line">    memset(&amp;server_addr, 0, <span class="keyword">sizeof</span>(server_addr));</div>
<div class="line">    server_addr.sin_family = AF_INET;</div>
<div class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</div>
<div class="line">    server_addr.sin_port = htons(PORT);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bind and listen</span></div>
<div class="line">    <span class="keywordflow">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == -1) {</div>
<div class="line">        perror(<span class="stringliteral">&quot;Bind failed&quot;</span>); exit(1);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (listen(server_fd, 5) == -1) { perror(<span class="stringliteral">&quot;Listen failed&quot;</span>); exit(1); }</div>
<div class="line">    printf(<span class="stringliteral">&quot;Server listening on port %d\n&quot;</span>, PORT);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        FD_ZERO(&amp;read_fds);</div>
<div class="line">        FD_SET(server_fd, &amp;read_fds);</div>
<div class="line">        <span class="keywordtype">int</span> max_fd = server_fd;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Add client sockets to set</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; MAX_CLIENTS; i++) {</div>
<div class="line">            <span class="keywordflow">if</span> (client_fds[i] &gt; 0) {</div>
<div class="line">                FD_SET(client_fds[i], &amp;read_fds);</div>
<div class="line">                <span class="keywordflow">if</span> (client_fds[i] &gt; max_fd) max_fd = client_fds[i];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Wait for activity</span></div>
<div class="line">        <span class="keywordflow">if</span> (select(max_fd + 1, &amp;read_fds, NULL, NULL, NULL) &lt; 0) {</div>
<div class="line">            perror(<span class="stringliteral">&quot;Select failed&quot;</span>); exit(1);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check for new connections</span></div>
<div class="line">        <span class="keywordflow">if</span> (FD_ISSET(server_fd, &amp;read_fds)) {</div>
<div class="line">            <span class="keywordtype">int</span> new_fd = accept(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;addr_len);</div>
<div class="line">            <span class="keywordflow">if</span> (new_fd &gt;= 0) {</div>
<div class="line">                fcntl(new_fd, F_SETFL, O_NONBLOCK);</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; MAX_CLIENTS; i++) {</div>
<div class="line">                    <span class="keywordflow">if</span> (client_fds[i] == 0) {</div>
<div class="line">                        client_fds[i] = new_fd;</div>
<div class="line">                        printf(<span class="stringliteral">&quot;New client connected: %d\n&quot;</span>, new_fd);</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check for client data</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; MAX_CLIENTS; i++) {</div>
<div class="line">            <span class="keywordflow">if</span> (client_fds[i] &gt; 0 &amp;&amp; FD_ISSET(client_fds[i], &amp;read_fds)) {</div>
<div class="line">                <span class="keywordtype">int</span> bytes = recv(client_fds[i], buffer, BUFFER_SIZE, 0);</div>
<div class="line">                <span class="keywordflow">if</span> (bytes &lt;= 0) {</div>
<div class="line">                    close(client_fds[i]);</div>
<div class="line">                    client_fds[i] = 0;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    buffer[bytes] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">                    printf(<span class="stringliteral">&quot;Received from %d: %s\n&quot;</span>, client_fds[i], buffer);</div>
<div class="line">                    send(client_fds[i], buffer, bytes, 0);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    close(server_fd);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>How to Run</b>:</p>
<ol type="1">
<li>Compile: <span class="tt">gcc -o non_blocking_server non_blocking_server.c</span></li>
<li>Run: <span class="tt">./non_blocking_server</span></li>
<li>Connect clients using a tool like <span class="tt">telnet 127.0.0.1 65432</span>.</li>
</ol>
<p><b>Use Cases</b>:</p>
<ul>
<li>High-performance servers (e.g., Nginx, Redis).</li>
<li>Real-time applications like chat or gaming servers.</li>
<li>Event-driven frameworks like Node.js or Python’s <span class="tt">asyncio</span>.</li>
</ul>
<p><b>Challenges</b>:</p>
<ul>
<li>Managing state for multiple connections.</li>
<li>Handling partial reads/writes in non-blocking mode.</li>
<li>Scalability limitations of <span class="tt">select()</span> for very large numbers of connections (use <span class="tt">epoll</span> or <span class="tt">kqueue</span> instead).</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md466"></a>
6.2 Socket Options</h3>
<p><b>Overview</b>: The <span class="tt">setsockopt()</span> and <span class="tt">getsockopt()</span> functions allow fine-grained control over socket behavior, enabling optimization, reliability, and customization. These functions operate at different levels (e.g., <span class="tt">SOL_SOCKET</span> for generic socket options, <span class="tt">IPPROTO_TCP</span> for TCP-specific options).</p>
<p><b>Common Socket Options</b>:</p>
<ul>
<li><b>SO_REUSEADDR</b>: Allows a socket to bind to an address already in use, useful for restarting servers without waiting for the <span class="tt">TIME_WAIT</span> state to expire. <div class="fragment"><div class="line"><span class="keywordtype">int</span> opt = 1;</div>
<div class="line">setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</div>
</div><!-- fragment --></li>
<li><b>SO_KEEPALIVE</b>: Enables periodic TCP keepalive packets to detect dead connections. <div class="fragment"><div class="line"><span class="keywordtype">int</span> opt = 1;</div>
<div class="line">setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;opt, <span class="keyword">sizeof</span>(opt));</div>
</div><!-- fragment --></li>
<li><b>SO_SNDBUF/SO_RCVBUF</b>: Sets send/receive buffer sizes to optimize throughput or reduce latency. <div class="fragment"><div class="line"><span class="keywordtype">int</span> bufsize = 65536; <span class="comment">// 64KB</span></div>
<div class="line">setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize));</div>
</div><!-- fragment --></li>
<li><b>TCP_NODELAY</b>: Disables Nagle’s algorithm to reduce latency for small packets (useful for real-time applications). <div class="fragment"><div class="line"><span class="keywordtype">int</span> opt = 1;</div>
<div class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;opt, <span class="keyword">sizeof</span>(opt));</div>
</div><!-- fragment --></li>
<li><b>SO_LINGER</b>: Controls how a socket closes, ensuring all queued data is sent or discarded. <div class="fragment"><div class="line"><span class="keyword">struct </span>linger ling = {1, 5}; <span class="comment">// Linger for 5 seconds</span></div>
<div class="line">setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &amp;ling, <span class="keyword">sizeof</span>(ling));</div>
</div><!-- fragment --></li>
</ul>
<p><b>Practical Example (Python)</b>: Set <span class="tt">SO_REUSEADDR</span> and <span class="tt">TCP_NODELAY</span> for a TCP server:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> socket</div>
<div class="line"> </div>
<div class="line">HOST = <span class="stringliteral">&#39;127.0.0.1&#39;</span></div>
<div class="line">PORT = 65432</div>
<div class="line"> </div>
<div class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> server_socket:</div>
<div class="line">    <span class="comment"># Set socket options</span></div>
<div class="line">    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div>
<div class="line">    server_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)</div>
<div class="line"> </div>
<div class="line">    server_socket.bind((HOST, PORT))</div>
<div class="line">    server_socket.listen()</div>
<div class="line">    print(f<span class="stringliteral">&quot;Server listening on {HOST}:{PORT}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    conn, addr = server_socket.accept()</div>
<div class="line">    <span class="keyword">with</span> conn:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Connected by {addr}&quot;</span>)</div>
<div class="line">        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">            data = conn.recv(1024)</div>
<div class="line">            <span class="keywordflow">if</span> <span class="keywordflow">not</span> data:</div>
<div class="line">                <span class="keywordflow">break</span></div>
<div class="line">            print(f<span class="stringliteral">&quot;Received: {data.decode()}&quot;</span>)</div>
<div class="line">            conn.sendall(data)</div>
</div><!-- fragment --><p><b>Use Cases</b>:</p>
<ul>
<li>Optimizing server performance (e.g., buffer sizes for high-throughput applications).</li>
<li>Ensuring reliable connection closure (e.g., <span class="tt">SO_LINGER</span> for critical data).</li>
<li>Reducing latency in real-time systems (e.g., <span class="tt">TCP_NODELAY</span> for gaming).</li>
</ul>
<p><b>Challenges</b>:</p>
<ul>
<li>Platform-specific behavior (e.g., Windows may not support all options).</li>
<li>Incorrect buffer sizes can degrade performance or waste memory.</li>
<li>Misusing <span class="tt">SO_REUSEADDR</span> can lead to unintended connections.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md467"></a>
6.3 Multicast and Broadcast</h3>
<p><b>Overview</b>: The Socket API supports multicast and broadcast communication, primarily with UDP (SOCK_DGRAM). These mechanisms allow a single message to reach multiple recipients, useful for group communication or network discovery.</p>
<ul>
<li><b>Multicast</b>: Sends data to a specific group of recipients identified by a multicast IP address (e.g., 224.0.0.0–239.255.255.255 for IPv4). Requires joining a multicast group using <span class="tt">IP_ADD_MEMBERSHIP</span>.</li>
<li><b>Broadcast</b>: Sends data to all devices on a network (e.g., 255.255.255.255 for IPv4). Requires enabling <span class="tt">SO_BROADCAST</span>.</li>
</ul>
<p><b>Multicast Example (C)</b>: A simple UDP multicast sender and receiver:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/socket.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;netinet/in.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;arpa/inet.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define PORT 54321</span></div>
<div class="line"><span class="preprocessor">#define GROUP &quot;239.0.0.1&quot;</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE 1024</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="client_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (sockfd == -1) { perror(<span class="stringliteral">&quot;Socket creation failed&quot;</span>); exit(1); }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Allow reuse of local addresses</span></div>
<div class="line">    <span class="keywordtype">int</span> opt = 1;</div>
<div class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bind to the port</span></div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in addr;</div>
<div class="line">    memset(&amp;addr, 0, <span class="keyword">sizeof</span>(addr));</div>
<div class="line">    addr.sin_family = AF_INET;</div>
<div class="line">    addr.sin_addr.s_addr = INADDR_ANY;</div>
<div class="line">    addr.sin_port = htons(PORT);</div>
<div class="line">    <span class="keywordflow">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)) == -1) {</div>
<div class="line">        perror(<span class="stringliteral">&quot;Bind failed&quot;</span>); exit(1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Join multicast group</span></div>
<div class="line">    <span class="keyword">struct </span>ip_mreq mreq;</div>
<div class="line">    mreq.imr_multiaddr.s_addr = inet_addr(GROUP);</div>
<div class="line">    mreq.imr_interface.s_addr = INADDR_ANY;</div>
<div class="line">    setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Receive multicast messages</span></div>
<div class="line">    <span class="keywordtype">char</span> buffer[BUFFER_SIZE];</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in sender_addr;</div>
<div class="line">    socklen_t addr_len = <span class="keyword">sizeof</span>(sender_addr);</div>
<div class="line">    <span class="keywordtype">int</span> bytes = recvfrom(sockfd, buffer, BUFFER_SIZE, 0, (<span class="keyword">struct</span> sockaddr*)&amp;sender_addr, &amp;addr_len);</div>
<div class="line">    buffer[bytes] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Received: %s\n&quot;</span>, buffer);</div>
<div class="line"> </div>
<div class="line">    close(sockfd);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/socket.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;netinet/in.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;arpa/inet.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define PORT 54321</span></div>
<div class="line"><span class="preprocessor">#define GROUP &quot;239.0.0.1&quot;</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE 1024</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="client_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (sockfd == -1) { perror(<span class="stringliteral">&quot;Socket creation failed&quot;</span>); exit(1); }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set up destination address</span></div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in addr;</div>
<div class="line">    memset(&amp;addr, 0, <span class="keyword">sizeof</span>(addr));</div>
<div class="line">    addr.sin_family = AF_INET;</div>
<div class="line">    addr.sin_addr.s_addr = inet_addr(GROUP);</div>
<div class="line">    addr.sin_port = htons(PORT);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Send multicast message</span></div>
<div class="line">    <span class="keywordtype">char</span> *message = <span class="stringliteral">&quot;Hello, Multicast Group!&quot;</span>;</div>
<div class="line">    sendto(sockfd, message, strlen(message) + 1, 0, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</div>
<div class="line">    printf(<span class="stringliteral">&quot;Sent: %s\n&quot;</span>, message);</div>
<div class="line"> </div>
<div class="line">    close(sockfd);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>How to Run</b>:</p>
<ol type="1">
<li>Compile: <span class="tt">gcc -o multicast_receiver multicast_receiver.c &amp;&amp; gcc -o multicast_sender multicast_sender.c</span></li>
<li>Run receiver: <span class="tt">./multicast_receiver</span></li>
<li>Run sender: <span class="tt">./multicast_sender</span></li>
</ol>
<p><b>Broadcast Example (Python)</b>: Enable broadcast for a UDP socket:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> socket</div>
<div class="line"> </div>
<div class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> s:</div>
<div class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)</div>
<div class="line">    s.sendto(b<span class="stringliteral">&quot;Hello, Broadcast!&quot;</span>, (<span class="stringliteral">&#39;255.255.255.255&#39;</span>, 12345))</div>
</div><!-- fragment --><p><b>Use Cases</b>:</p>
<ul>
<li><b>Multicast</b>: Streaming media, service discovery (e.g., mDNS), or distributed systems.</li>
<li><b>Broadcast</b>: Network discovery (e.g., DHCP, UPnP).</li>
</ul>
<p><b>Challenges</b>:</p>
<ul>
<li>Multicast requires router support (IGMP for IPv4).</li>
<li>Broadcast is limited to local networks and can cause network congestion.</li>
<li>Security risks (e.g., unintended recipients).</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md468"></a>
6.4 Asynchronous I/O</h3>
<p><b>Overview</b>: Asynchronous I/O allows applications to handle multiple socket operations concurrently without blocking or using multiple threads. This is achieved using event loops or I/O completion mechanisms, often integrated with non-blocking sockets.</p>
<p><b>Frameworks and Tools</b>:</p>
<ul>
<li><b>Python <span class="tt">asyncio</span></b>: Provides an event loop for asynchronous socket programming. <div class="fragment"><div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span>handle_client(reader, writer):</div>
<div class="line">    data = await reader.read(100)</div>
<div class="line">    writer.write(data)</div>
<div class="line">    await writer.drain()</div>
<div class="line">    writer.close()</div>
<div class="line">    await writer.wait_closed()</div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span><a class="code hl_function" href="client_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>():</div>
<div class="line">    server = await asyncio.start_server(handle_client, <span class="stringliteral">&#39;127.0.0.1&#39;</span>, 65432)</div>
<div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> server:</div>
<div class="line">        await server.serve_forever()</div>
<div class="line"> </div>
<div class="line">asyncio.run(<a class="code hl_function" href="client_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>())</div>
</div><!-- fragment --></li>
<li><b>Node.js</b>: Uses an event-driven model with callbacks or promises for socket operations.</li>
<li><b>Boost.Asio (C++)</b>: Provides portable asynchronous I/O for sockets.</li>
<li><b>libuv</b>: A cross-platform library used by Node.js for asynchronous I/O.</li>
<li><b>Windows IOCP</b>: A high-performance mechanism for Windows applications.</li>
</ul>
<p><b>Use Cases</b>:</p>
<ul>
<li>Web servers handling thousands of concurrent connections.</li>
<li>Real-time applications like WebSockets or VoIP.</li>
<li>IoT systems with many devices.</li>
</ul>
<p><b>Challenges</b>:</p>
<ul>
<li>Complex programming model (callbacks, coroutines, or promises).</li>
<li>Debugging asynchronous code.</li>
<li>Resource management for large numbers of connections.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md469"></a>
7. Practical Considerations</h2>
<ul>
<li><b>Performance</b>: Non-blocking sockets and asynchronous I/O reduce CPU usage and improve scalability but require careful design to avoid bottlenecks.</li>
<li><b>Portability</b>: Some features (e.g., <span class="tt">epoll</span>, <span class="tt">kqueue</span>) are platform-specific, requiring conditional compilation or abstractions.</li>
<li><b>Error Handling</b>: Advanced features introduce complex error conditions (e.g., partial sends, temporary unavailability).</li>
<li><b>Security</b>: Multicast and broadcast require safeguards against unauthorized access or abuse.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md470"></a>
8. Conclusion</h2>
<p>The advanced features of the Socket API—non-blocking sockets, socket options, multicast/broadcast, and asynchronous I/O—enable developers to build efficient, scalable, and flexible networked applications. Non-blocking sockets and event loops handle high concurrency, socket options fine-tune performance and reliability, multicast/broadcast support group communication, and asynchronous I/O frameworks simplify complex workflows. By mastering these features, developers can create robust systems for diverse use cases, from web servers to real-time communication platforms. Experiment with the provided examples and explore frameworks like <span class="tt">asyncio</span> or <span class="tt">libuv</span> to deepen your understanding. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
