<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jsocketpp: UDP Sockets</title>
<link rel="icon" href="logo55px.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo55px.png"/></td>
  <td id="projectalign">
   <div id="projectname">jsocketpp<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A cross-platform C++20 socket library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__udp.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">UDP Sockets <div class="ingroups"><a class="el" href="group__jsocketpp.html">jsocketpp: C++20 cross-platform socket library</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Classes and functions for UDP datagram networking.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for UDP Sockets:</div>
<div class="dyncontent">
<div class="center"><img src="group__udp.png" border="0" usemap="#agroup____udp" loading="lazy" alt=""/></div>
<map name="agroup____udp" id="agroup____udp">
<area shape="rect" href="group__jsocketpp.html" title="All core classes and functions of the jsocketpp networking library." alt="" coords="5,5,182,50"/>
<area shape="rect" title="Classes and functions for UDP datagram networking." alt="" coords="230,14,333,42"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jsocketpp_3A_3ADatagramReadOptions" id="r_jsocketpp_3A_3ADatagramReadOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">jsocketpp::DatagramReadOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options controlling a single UDP receive operation.  <a href="structjsocketpp_1_1DatagramReadOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:jsocketpp_3A_3ADatagramReadResult" id="r_jsocketpp_3A_3ADatagramReadResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">jsocketpp::DatagramReadResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Telemetry data about a single UDP datagram receive operation.  <a href="structjsocketpp_1_1DatagramReadResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:jsocketpp_3A_3AReadExactOptions" id="r_jsocketpp_3A_3AReadExactOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsocketpp_1_1ReadExactOptions.html">jsocketpp::ReadExactOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for enforcing an exact-byte receive on a single UDP datagram.  <a href="structjsocketpp_1_1ReadExactOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:jsocketpp_3A_3ADatagramPacket" id="r_jsocketpp_3A_3ADatagramPacket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsocketpp_1_1DatagramPacket.html">jsocketpp::DatagramPacket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a UDP datagram packet, encapsulating both payload and addressing information.  <a href="classjsocketpp_1_1DatagramPacket.html#details">More...</a><br /></td></tr>
<tr class="memitem:jsocketpp_3A_3ADatagramSocket" id="r_jsocketpp_3A_3ADatagramSocket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsocketpp_1_1DatagramSocket.html">jsocketpp::DatagramSocket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform UDP socket class with Java-style interface.  <a href="classjsocketpp_1_1DatagramSocket.html#details">More...</a><br /></td></tr>
<tr class="memitem:jsocketpp_3A_3AMulticastSocket" id="r_jsocketpp_3A_3AMulticastSocket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsocketpp_1_1MulticastSocket.html">jsocketpp::MulticastSocket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform multicast UDP socket class (IPv4/IPv6).  <a href="classjsocketpp_1_1MulticastSocket.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2124eae8cec6709a67be265f14da3bdd" id="r_ga2124eae8cec6709a67be265f14da3bdd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2124eae8cec6709a67be265f14da3bdd">jsocketpp::DatagramReceiveMode</a> : std::uint8_t { <a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f">jsocketpp::DatagramReceiveMode::NoPreflight</a> = 0
, <a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd">jsocketpp::DatagramReceiveMode::PreflightSize</a> = 1
, <a class="el" href="#gga2124eae8cec6709a67be265f14da3bddac9a017cf1d4a5f3aff960a3f7e8bffd5">jsocketpp::DatagramReceiveMode::PreflightMax</a> = 2
 }</td></tr>
<tr class="memdesc:ga2124eae8cec6709a67be265f14da3bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive-time sizing policy for UDP datagrams.  <a href="#ga2124eae8cec6709a67be265f14da3bdd">More...</a><br /></td></tr>
<tr class="memitem:ga8272a360bdf6e0377f31ac8ce251a837" id="r_ga8272a360bdf6e0377f31ac8ce251a837"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8272a360bdf6e0377f31ac8ce251a837">jsocketpp::Direction</a> : std::uint8_t { <a class="el" href="#gga8272a360bdf6e0377f31ac8ce251a837a7a1a5f3e79fdc91edf2f5ead9d66abb4">jsocketpp::Direction::Read</a>
, <a class="el" href="#gga8272a360bdf6e0377f31ac8ce251a837a1129c0e4d43f2d121652a7302712cff6">jsocketpp::Direction::Write</a>
, <a class="el" href="#gga8272a360bdf6e0377f31ac8ce251a837a70a2a84088d405a2e3f1e3accaa16723">jsocketpp::Direction::ReadWrite</a>
 }</td></tr>
<tr class="memdesc:ga8272a360bdf6e0377f31ac8ce251a837"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O readiness selector used by waitReady().  <a href="#ga8272a360bdf6e0377f31ac8ce251a837">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga509c53d38c840b0cf95fbb16362a12ce" id="r_ga509c53d38c840b0cf95fbb16362a12ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga509c53d38c840b0cf95fbb16362a12ce">jsocketpp::DatagramPacket::hasDestination</a> () const noexcept</td></tr>
<tr class="memdesc:ga509c53d38c840b0cf95fbb16362a12ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether this packet specifies an explicit destination (address + port).  <br /></td></tr>
<tr class="memitem:ga4b4c631816f82eea0b6048a16682079e" id="r_ga4b4c631816f82eea0b6048a16682079e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b4c631816f82eea0b6048a16682079e">jsocketpp::DatagramSocket::DatagramSocket</a> (<a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> localPort=0, std::string_view localAddress=&quot;&quot;, std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, bool reuseAddress=true, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool nonBlocking=false, bool dualStack=true, bool autoBind=true, bool autoConnect=false, std::string_view remoteAddress=&quot;&quot;, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> remotePort=0, int connectTimeoutMillis=-1)</td></tr>
<tr class="memdesc:ga4b4c631816f82eea0b6048a16682079e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a UDP socket, optionally binds to a local address, and optionally connects to a remote peer.  <br /></td></tr>
<tr class="memitem:gaf2be0b146f197d55cc55a5ba8b619166" id="r_gaf2be0b146f197d55cc55a5ba8b619166"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf2be0b146f197d55cc55a5ba8b619166">jsocketpp::DatagramSocket::~DatagramSocket</a> () noexcept override</td></tr>
<tr class="memdesc:gaf2be0b146f197d55cc55a5ba8b619166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>. Ensures socket resources are released.  <br /></td></tr>
<tr class="memitem:ga3d08597b24d9c7a3fe43dd291ee85148" id="r_ga3d08597b24d9c7a3fe43dd291ee85148"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d08597b24d9c7a3fe43dd291ee85148">jsocketpp::DatagramSocket::DatagramSocket</a> (const DatagramSocket &amp;)=delete</td></tr>
<tr class="memdesc:ga3d08597b24d9c7a3fe43dd291ee85148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (deleted) for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>.  <br /></td></tr>
<tr class="memitem:gab67aad3e2d477982f19d17ab80607417" id="r_gab67aad3e2d477982f19d17ab80607417"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab67aad3e2d477982f19d17ab80607417">jsocketpp::DatagramSocket::operator=</a> (const <a class="el" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> &amp;)=delete</td></tr>
<tr class="memdesc:gab67aad3e2d477982f19d17ab80607417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator (deleted) for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>.  <br /></td></tr>
<tr class="memitem:gab613123c8bf1aca6aec451b1140e2f82" id="r_gab613123c8bf1aca6aec451b1140e2f82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab613123c8bf1aca6aec451b1140e2f82">jsocketpp::DatagramSocket::DatagramSocket</a> (DatagramSocket &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:gab613123c8bf1aca6aec451b1140e2f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>.  <br /></td></tr>
<tr class="memitem:ga38397874bcb62f889cb6fefa20b45ba6" id="r_ga38397874bcb62f889cb6fefa20b45ba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38397874bcb62f889cb6fefa20b45ba6">jsocketpp::DatagramSocket::operator=</a> (<a class="el" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga38397874bcb62f889cb6fefa20b45ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>.  <br /></td></tr>
<tr class="memitem:ga550b67d7ad08c5cb068bb2b66d2c2c49" id="r_ga550b67d7ad08c5cb068bb2b66d2c2c49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">jsocketpp::DatagramSocket::bind</a> ()</td></tr>
<tr class="memdesc:ga550b67d7ad08c5cb068bb2b66d2c2c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the datagram socket to all available interfaces on an ephemeral port.  <br /></td></tr>
<tr class="memitem:ga614ad4b99d492f9e6ad5c5b63a97c751" id="r_ga614ad4b99d492f9e6ad5c5b63a97c751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga614ad4b99d492f9e6ad5c5b63a97c751">jsocketpp::DatagramSocket::bind</a> (<a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> localPort)</td></tr>
<tr class="memdesc:ga614ad4b99d492f9e6ad5c5b63a97c751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the datagram socket to a specific local port on all network interfaces.  <br /></td></tr>
<tr class="memitem:ga386fcebc37da51731299a12b915d148f" id="r_ga386fcebc37da51731299a12b915d148f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga386fcebc37da51731299a12b915d148f">jsocketpp::DatagramSocket::bind</a> (std::string_view localAddress, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> localPort)</td></tr>
<tr class="memdesc:ga386fcebc37da51731299a12b915d148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the datagram socket to a specific local IP address and port.  <br /></td></tr>
<tr class="memitem:gadd6a72af69e4e8e1e8701c60a7e728f1" id="r_gadd6a72af69e4e8e1e8701c60a7e728f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadd6a72af69e4e8e1e8701c60a7e728f1">jsocketpp::DatagramSocket::isBound</a> () const noexcept</td></tr>
<tr class="memdesc:gadd6a72af69e4e8e1e8701c60a7e728f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the datagram socket has been explicitly bound to a local address or port.  <br /></td></tr>
<tr class="memitem:ga915c790c7cfde485e680ddec2edb2e74" id="r_ga915c790c7cfde485e680ddec2edb2e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74">jsocketpp::DatagramSocket::connect</a> (std::string_view host, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, int timeoutMillis)</td></tr>
<tr class="memdesc:ga915c790c7cfde485e680ddec2edb2e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect this UDP socket to a default peer (set the default destination).  <br /></td></tr>
<tr class="memitem:ga02b08c333a2f109a3b19ec7b3c0cecf9" id="r_ga02b08c333a2f109a3b19ec7b3c0cecf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga02b08c333a2f109a3b19ec7b3c0cecf9">jsocketpp::DatagramSocket::disconnect</a> ()</td></tr>
<tr class="memdesc:ga02b08c333a2f109a3b19ec7b3c0cecf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect this UDP socket from its current default peer.  <br /></td></tr>
<tr class="memitem:gac3b7c4a5fc5a21372c4a9cadb3e85efb" id="r_gac3b7c4a5fc5a21372c4a9cadb3e85efb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb">jsocketpp::DatagramSocket::isConnected</a> () const noexcept</td></tr>
<tr class="memdesc:gac3b7c4a5fc5a21372c4a9cadb3e85efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the datagram socket is connected to a specific remote peer.  <br /></td></tr>
<tr class="memitem:gab6486855380c97e18428a670f48f3efa" id="r_gab6486855380c97e18428a670f48f3efa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab6486855380c97e18428a670f48f3efa">jsocketpp::DatagramSocket::getLocalIp</a> (bool convertIPv4Mapped)</td></tr>
<tr class="memdesc:gab6486855380c97e18428a670f48f3efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the local interface IP address for this UDP socket.  <br /></td></tr>
<tr class="memitem:ga8b036d60faeaf712b6b477dc166061b8" id="r_ga8b036d60faeaf712b6b477dc166061b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b036d60faeaf712b6b477dc166061b8">jsocketpp::DatagramSocket::getLocalPort</a> ()</td></tr>
<tr class="memdesc:ga8b036d60faeaf712b6b477dc166061b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the local UDP port this socket is bound to.  <br /></td></tr>
<tr class="memitem:ga2b19edc594f75938a6028094744ec107" id="r_ga2b19edc594f75938a6028094744ec107"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2b19edc594f75938a6028094744ec107">jsocketpp::DatagramSocket::getLocalSocketAddress</a> (bool convertIPv4Mapped)</td></tr>
<tr class="memdesc:ga2b19edc594f75938a6028094744ec107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the local endpoint as a single "ip:port" string.  <br /></td></tr>
<tr class="memitem:ga3afd5b0d48ee9f92759c6f2d4ea9d8f0" id="r_ga3afd5b0d48ee9f92759c6f2d4ea9d8f0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3afd5b0d48ee9f92759c6f2d4ea9d8f0">jsocketpp::DatagramSocket::getRemoteIp</a> (bool convertIPv4Mapped) const</td></tr>
<tr class="memdesc:ga3afd5b0d48ee9f92759c6f2d4ea9d8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the remote peer IP address for this socket.  <br /></td></tr>
<tr class="memitem:ga6d1dbfd5b854e120b352a27b541e5841" id="r_ga6d1dbfd5b854e120b352a27b541e5841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6d1dbfd5b854e120b352a27b541e5841">jsocketpp::DatagramSocket::getRemotePort</a> () const</td></tr>
<tr class="memdesc:ga6d1dbfd5b854e120b352a27b541e5841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the remote peer UDP port for this socket.  <br /></td></tr>
<tr class="memitem:gaa31790315a4bb8d20cd924157107a166" id="r_gaa31790315a4bb8d20cd924157107a166"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa31790315a4bb8d20cd924157107a166">jsocketpp::DatagramSocket::getRemoteSocketAddress</a> (bool convertIPv4Mapped) const</td></tr>
<tr class="memdesc:gaa31790315a4bb8d20cd924157107a166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the remote endpoint as a single "ip:port" string.  <br /></td></tr>
<tr class="memitem:ga96bc239f42265d5c408c8f15046f24c8" id="r_ga96bc239f42265d5c408c8f15046f24c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8">jsocketpp::DatagramSocket::write</a> (std::string_view message) const</td></tr>
<tr class="memdesc:ga96bc239f42265d5c408c8f15046f24c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one UDP datagram to the currently connected peer (no pre-wait).  <br /></td></tr>
<tr class="memitem:ga3d9722c04df6d147773249d94df09135" id="r_ga3d9722c04df6d147773249d94df09135"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga3d9722c04df6d147773249d94df09135 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d9722c04df6d147773249d94df09135">jsocketpp::DatagramSocket::write</a> (const T &amp;value) const</td></tr>
<tr class="memdesc:ga3d9722c04df6d147773249d94df09135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one UDP datagram whose payload is the raw object representation of <code class="param">value</code>.  <br /></td></tr>
<tr class="memitem:ga22f349cb1f93f2fc18e4c6e19d7ba1ff" id="r_ga22f349cb1f93f2fc18e4c6e19d7ba1ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga22f349cb1f93f2fc18e4c6e19d7ba1ff">jsocketpp::DatagramSocket::write</a> (std::span&lt; const std::byte &gt; data) const</td></tr>
<tr class="memdesc:ga22f349cb1f93f2fc18e4c6e19d7ba1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one UDP datagram to the connected peer from a raw byte span (no pre-wait).  <br /></td></tr>
<tr class="memitem:gabb163d329ca77150019c3e430f415209" id="r_gabb163d329ca77150019c3e430f415209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabb163d329ca77150019c3e430f415209">jsocketpp::DatagramSocket::writeAll</a> (std::string_view message) const</td></tr>
<tr class="memdesc:gabb163d329ca77150019c3e430f415209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one UDP datagram to the connected peer, waiting indefinitely for writability.  <br /></td></tr>
<tr class="memitem:gaa848031032de9438dd560a8a9eba38d6" id="r_gaa848031032de9438dd560a8a9eba38d6"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaa848031032de9438dd560a8a9eba38d6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa848031032de9438dd560a8a9eba38d6">jsocketpp::DatagramSocket::writePrefixed</a> (const std::string_view payload) const</td></tr>
<tr class="memdesc:gaa848031032de9438dd560a8a9eba38d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a length-prefixed UDP datagram to the connected peer from text bytes (no pre-wait).  <br /></td></tr>
<tr class="memitem:gaffb1e99dbfcac72f8936e43d2d35467e" id="r_gaffb1e99dbfcac72f8936e43d2d35467e"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaffb1e99dbfcac72f8936e43d2d35467e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaffb1e99dbfcac72f8936e43d2d35467e">jsocketpp::DatagramSocket::writePrefixed</a> (const std::span&lt; const std::byte &gt; payload) const</td></tr>
<tr class="memdesc:gaffb1e99dbfcac72f8936e43d2d35467e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a length-prefixed UDP datagram to the connected peer from a byte span (no pre-wait).  <br /></td></tr>
<tr class="memitem:gaf2398346dc295a530a70cc0f11bc5928" id="r_gaf2398346dc295a530a70cc0f11bc5928"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaf2398346dc295a530a70cc0f11bc5928 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf2398346dc295a530a70cc0f11bc5928">jsocketpp::DatagramSocket::writePrefixedTo</a> (const std::string_view host, const <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, const std::string_view payload) const</td></tr>
<tr class="memdesc:gaf2398346dc295a530a70cc0f11bc5928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a length-prefixed UDP datagram to (host, port) from text bytes (unconnected path).  <br /></td></tr>
<tr class="memitem:ga568d0cb2e5888b3dca1f949e171c98ec" id="r_ga568d0cb2e5888b3dca1f949e171c98ec"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga568d0cb2e5888b3dca1f949e171c98ec template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga568d0cb2e5888b3dca1f949e171c98ec">jsocketpp::DatagramSocket::writePrefixedTo</a> (const std::string_view host, const <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, const std::span&lt; const std::byte &gt; payload) const</td></tr>
<tr class="memdesc:ga568d0cb2e5888b3dca1f949e171c98ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a length-prefixed UDP datagram to (host, port) from a byte span (unconnected path).  <br /></td></tr>
<tr class="memitem:ga6fff302b8483605f25254bf0a1f00baf" id="r_ga6fff302b8483605f25254bf0a1f00baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6fff302b8483605f25254bf0a1f00baf">jsocketpp::DatagramSocket::writev</a> (std::span&lt; const std::string_view &gt; buffers) const</td></tr>
<tr class="memdesc:ga6fff302b8483605f25254bf0a1f00baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one UDP datagram to the connected peer by concatenating multiple fragments (no pre-wait).  <br /></td></tr>
<tr class="memitem:gac69845676b984d0876f7ad9311571846" id="r_gac69845676b984d0876f7ad9311571846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac69845676b984d0876f7ad9311571846">jsocketpp::DatagramSocket::writevAll</a> (std::span&lt; const std::string_view &gt; buffers) const</td></tr>
<tr class="memdesc:gac69845676b984d0876f7ad9311571846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one UDP datagram to the connected peer by concatenating multiple fragments, waiting indefinitely.  <br /></td></tr>
<tr class="memitem:ga5fd49284f279d17c851a356caafdd216" id="r_ga5fd49284f279d17c851a356caafdd216"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5fd49284f279d17c851a356caafdd216">jsocketpp::DatagramSocket::writeFrom</a> (const void *data, std::size_t len) const</td></tr>
<tr class="memdesc:ga5fd49284f279d17c851a356caafdd216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one UDP datagram to the connected peer from a raw memory buffer (no pre-wait).  <br /></td></tr>
<tr class="memitem:ga4a22b644010f53c741a8ea733e4abf0f" id="r_ga4a22b644010f53c741a8ea733e4abf0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f">jsocketpp::DatagramSocket::writeWithTimeout</a> (std::string_view data, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga4a22b644010f53c741a8ea733e4abf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one UDP datagram to the connected peer, waiting up to <code class="param">timeoutMillis</code> for writability.  <br /></td></tr>
<tr class="memitem:gafb2439eddc4ce6db4915e02ed7946444" id="r_gafb2439eddc4ce6db4915e02ed7946444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafb2439eddc4ce6db4915e02ed7946444">jsocketpp::DatagramSocket::write</a> (const <a class="el" href="classjsocketpp_1_1DatagramPacket.html">DatagramPacket</a> &amp;packet)</td></tr>
<tr class="memdesc:gafb2439eddc4ce6db4915e02ed7946444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one UDP datagram using a packet’s buffer and optional explicit destination.  <br /></td></tr>
<tr class="memitem:gafed0d7b0bbe66da82d795d013ed2b29d" id="r_gafed0d7b0bbe66da82d795d013ed2b29d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d">jsocketpp::DatagramSocket::writeTo</a> (std::string_view host, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, std::string_view message)</td></tr>
<tr class="memdesc:gafed0d7b0bbe66da82d795d013ed2b29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).  <br /></td></tr>
<tr class="memitem:ga0239bea129ff0084aba9cd68e8a66f3c" id="r_ga0239bea129ff0084aba9cd68e8a66f3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0239bea129ff0084aba9cd68e8a66f3c">jsocketpp::DatagramSocket::writeTo</a> (std::string_view host, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, std::span&lt; const std::byte &gt; data)</td></tr>
<tr class="memdesc:ga0239bea129ff0084aba9cd68e8a66f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one unconnected UDP datagram to (host, port) from a raw byte span (no pre-wait).  <br /></td></tr>
<tr class="memitem:gac74d3b4a3f6c64919382f8d3a9805eb8" id="r_gac74d3b4a3f6c64919382f8d3a9805eb8"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gac74d3b4a3f6c64919382f8d3a9805eb8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac74d3b4a3f6c64919382f8d3a9805eb8">jsocketpp::DatagramSocket::writeTo</a> (const std::string_view host, const <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, const T &amp;value) const</td></tr>
<tr class="memdesc:gac74d3b4a3f6c64919382f8d3a9805eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one unconnected UDP datagram to (host, port) containing the raw bytes of <code class="param">value</code>.  <br /></td></tr>
<tr class="memitem:gaa7f9cce85a502e58b8d86db95a8e0721" id="r_gaa7f9cce85a502e58b8d86db95a8e0721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721">jsocketpp::DatagramSocket::read</a> (<a class="el" href="classjsocketpp_1_1DatagramPacket.html">DatagramPacket</a> &amp;packet, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts) const</td></tr>
<tr class="memdesc:gaa7f9cce85a502e58b8d86db95a8e0721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one UDP datagram into a <a class="el" href="classjsocketpp_1_1DatagramPacket.html" title="Represents a UDP datagram packet, encapsulating both payload and addressing information.">DatagramPacket</a> with optional growth/shrink and strict truncation policy.  <br /></td></tr>
<tr class="memitem:gada22ab72b367e5123600bb3276422940" id="r_gada22ab72b367e5123600bb3276422940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada22ab72b367e5123600bb3276422940">jsocketpp::DatagramSocket::readInto</a> (void *buffer, std::size_t len, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:gada22ab72b367e5123600bb3276422940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one UDP datagram into a caller-provided buffer with explicit truncation policy.  <br /></td></tr>
<tr class="memitem:ga585e06116cd0669c881c4bb8ee3ef99b" id="r_ga585e06116cd0669c881c4bb8ee3ef99b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga585e06116cd0669c881c4bb8ee3ef99b">jsocketpp::DatagramSocket::readInto</a> (std::span&lt; char &gt; out, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga585e06116cd0669c881c4bb8ee3ef99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one UDP datagram into a caller-provided span (zero allocation) with explicit truncation policy.  <br /></td></tr>
<tr class="memitem:ga9f9e08f58d50d29e0f3fa9ccf83c1c97" id="r_ga9f9e08f58d50d29e0f3fa9ccf83c1c97"><td class="memTemplParams" colspan="2">template&lt;typename T, std::enable_if_t&lt; <a class="el" href="namespacejsocketpp_1_1detail.html#aa46a9243f021ef54b04645f354feea30">detail::is_dynamic_buffer_v</a>&lt; T &gt;, int &gt; = 0&gt; </td></tr>
<tr class="memitem:ga9f9e08f58d50d29e0f3fa9ccf83c1c97 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9f9e08f58d50d29e0f3fa9ccf83c1c97">jsocketpp::DatagramSocket::read</a> (const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}, std::size_t minCapacity=<a class="el" href="group__core.html#ga2fb9d73742801c62e90aeb505c618c43">DefaultDatagramReceiveSize</a>) const</td></tr>
<tr class="memdesc:ga9f9e08f58d50d29e0f3fa9ccf83c1c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one UDP datagram into a dynamically resizable, contiguous byte container (zero-copy into caller storage).  <br /></td></tr>
<tr class="memitem:ga24a48ca4f6711d89e0a89531b3b31807" id="r_ga24a48ca4f6711d89e0a89531b3b31807"><td class="memTemplParams" colspan="2">template&lt;typename T, std::enable_if_t&lt; <a class="el" href="namespacejsocketpp_1_1detail.html#a18306b136e94e5aaf18c6dd6d5f06f33">detail::is_fixed_buffer_v</a>&lt; T &gt;, int &gt; = 0&gt; </td></tr>
<tr class="memitem:ga24a48ca4f6711d89e0a89531b3b31807 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga24a48ca4f6711d89e0a89531b3b31807">jsocketpp::DatagramSocket::read</a> (const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga24a48ca4f6711d89e0a89531b3b31807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one UDP datagram into a fixed-size, contiguous byte container (zero allocation).  <br /></td></tr>
<tr class="memitem:ga7fbd62107244e308dc0436f11fae7dad" id="r_ga7fbd62107244e308dc0436f11fae7dad"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga7fbd62107244e308dc0436f11fae7dad template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7fbd62107244e308dc0436f11fae7dad">jsocketpp::DatagramSocket::readFrom</a> (T &amp;buffer, std::string *senderAddr, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> *senderPort, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts) const</td></tr>
<tr class="memdesc:ga7fbd62107244e308dc0436f11fae7dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one UDP datagram into a caller-provided byte container and optionally return the sender address/port.  <br /></td></tr>
<tr class="memitem:gab34fd67ebc17563f286dde70ba456cf9" id="r_gab34fd67ebc17563f286dde70ba456cf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab34fd67ebc17563f286dde70ba456cf9">jsocketpp::DatagramSocket::readExact</a> (void *buffer, std::size_t exactLen, const <a class="el" href="structjsocketpp_1_1ReadExactOptions.html">ReadExactOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:gab34fd67ebc17563f286dde70ba456cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive exactly <code class="param">exactLen</code> bytes from a single UDP datagram into <code class="param">buffer</code>, with strict policy control.  <br /></td></tr>
<tr class="memitem:ga00b73bb3707d78fee4b4c11e2e139268" id="r_ga00b73bb3707d78fee4b4c11e2e139268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga00b73bb3707d78fee4b4c11e2e139268">jsocketpp::DatagramSocket::readExact</a> (std::span&lt; char &gt; out, const <a class="el" href="structjsocketpp_1_1ReadExactOptions.html">ReadExactOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga00b73bb3707d78fee4b4c11e2e139268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Span overload of readExact(...) (derives <code class="param">exactLen</code> from <code class="param">out.size()</code>).  <br /></td></tr>
<tr class="memitem:gaf2d8f0e01d69beb2ae22383abf706e2c" id="r_gaf2d8f0e01d69beb2ae22383abf706e2c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaf2d8f0e01d69beb2ae22383abf706e2c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf2d8f0e01d69beb2ae22383abf706e2c">jsocketpp::DatagramSocket::readExact</a> (T &amp;buffer, const std::size_t exactLen, const <a class="el" href="structjsocketpp_1_1ReadExactOptions.html">ReadExactOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:gaf2d8f0e01d69beb2ae22383abf706e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive exactly <code class="param">exactLen</code> bytes from a single UDP datagram into a contiguous byte container.  <br /></td></tr>
<tr class="memitem:gad5548c6a422e710410315dd6fb92788d" id="r_gad5548c6a422e710410315dd6fb92788d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad5548c6a422e710410315dd6fb92788d">jsocketpp::DatagramSocket::readAtMost</a> (std::span&lt; char &gt; out, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:gad5548c6a422e710410315dd6fb92788d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read up to <code class="param">out.size()</code> bytes from the next UDP datagram into a caller-provided buffer (no allocation).  <br /></td></tr>
<tr class="memitem:ga85c18071cceb1c0c679b7a444cfa9f65" id="r_ga85c18071cceb1c0c679b7a444cfa9f65"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga85c18071cceb1c0c679b7a444cfa9f65">jsocketpp::DatagramSocket::readAvailable</a> () const</td></tr>
<tr class="memdesc:ga85c18071cceb1c0c679b7a444cfa9f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive the next UDP datagram and return its payload as a string, attempting to avoid truncation.  <br /></td></tr>
<tr class="memitem:ga4773cc4b2879db4c5d377505bdb761fa" id="r_ga4773cc4b2879db4c5d377505bdb761fa"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4773cc4b2879db4c5d377505bdb761fa">jsocketpp::DatagramSocket::readAvailable</a> (std::span&lt; char &gt; out, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga4773cc4b2879db4c5d377505bdb761fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive the entire next UDP datagram into a caller-provided buffer, with explicit truncation policy.  <br /></td></tr>
<tr class="memitem:gae739db534b15bd856c9d83ac020a7796" id="r_gae739db534b15bd856c9d83ac020a7796"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae739db534b15bd856c9d83ac020a7796">jsocketpp::DatagramSocket::readIntoExact</a> (void *buffer, std::size_t len) const</td></tr>
<tr class="memdesc:gae739db534b15bd856c9d83ac020a7796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strict exact-length UDP receive into a caller-provided buffer (single datagram).  <br /></td></tr>
<tr class="memitem:ga4d5295306a17e8fdf4a6e00556e043b5" id="r_ga4d5295306a17e8fdf4a6e00556e043b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4d5295306a17e8fdf4a6e00556e043b5">jsocketpp::DatagramSocket::readAtMostWithTimeout</a> (std::size_t n, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga4d5295306a17e8fdf4a6e00556e043b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read up to <code class="param">n</code> bytes from the next UDP datagram, waiting up to <code class="param">timeoutMillis</code> for data.  <br /></td></tr>
<tr class="memitem:gabac0f0e22e72fa908fa49e44302c2a12" id="r_gabac0f0e22e72fa908fa49e44302c2a12"><td class="memTemplParams" colspan="2">template&lt;typename T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;std::is_unsigned_v&lt; T &gt; &amp;&amp;std::is_trivially_copyable_v&lt; T &gt;, int &gt; = 0&gt; </td></tr>
<tr class="memitem:gabac0f0e22e72fa908fa49e44302c2a12 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabac0f0e22e72fa908fa49e44302c2a12">jsocketpp::DatagramSocket::readPrefixed</a> (std::size_t maxPayloadLen=<a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89">MaxDatagramPayloadSafe</a>, const std::endian prefixEndian=std::endian::big) const</td></tr>
<tr class="memdesc:gabac0f0e22e72fa908fa49e44302c2a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a length-prefixed UDP datagram and return the payload (prefix type <code class="param">T</code>).  <br /></td></tr>
<tr class="memitem:ga243b470108bb0e02602780ee6c2ed8a7" id="r_ga243b470108bb0e02602780ee6c2ed8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga243b470108bb0e02602780ee6c2ed8a7">jsocketpp::DatagramSocket::discard</a> (const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga243b470108bb0e02602780ee6c2ed8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the next UDP datagram without copying it out.  <br /></td></tr>
<tr class="memitem:gaaa04156c3da5af5cf724d46764a04c84" id="r_gaaa04156c3da5af5cf724d46764a04c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaa04156c3da5af5cf724d46764a04c84">jsocketpp::DatagramSocket::discardExact</a> (std::size_t n, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:gaaa04156c3da5af5cf724d46764a04c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the next UDP datagram only if its payload size is exactly <code class="param">n</code> bytes.  <br /></td></tr>
<tr class="memitem:gae1222e5ce7f8c5e48f8fd997f4b57b42" id="r_gae1222e5ce7f8c5e48f8fd997f4b57b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae1222e5ce7f8c5e48f8fd997f4b57b42">jsocketpp::DatagramSocket::readv</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:gae1222e5ce7f8c5e48f8fd997f4b57b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter-gather receive: read one UDP datagram into multiple non-contiguous buffers.  <br /></td></tr>
<tr class="memitem:ga59d70a7a49451b0581757861d7fecf46" id="r_ga59d70a7a49451b0581757861d7fecf46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga59d70a7a49451b0581757861d7fecf46">jsocketpp::DatagramSocket::readvAll</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga59d70a7a49451b0581757861d7fecf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter-gather receive that guarantees the entire next datagram fits the provided buffers.  <br /></td></tr>
<tr class="memitem:ga06d5ac95a81132f8914473d59d333500" id="r_ga06d5ac95a81132f8914473d59d333500"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga06d5ac95a81132f8914473d59d333500">jsocketpp::DatagramSocket::readvAllBytes</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga06d5ac95a81132f8914473d59d333500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-compat convenience returning only the number of bytes copied.  <br /></td></tr>
<tr class="memitem:ga2e86bfec6de8b35caba5fc00a83489a4" id="r_ga2e86bfec6de8b35caba5fc00a83489a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e86bfec6de8b35caba5fc00a83489a4">jsocketpp::DatagramSocket::readvAtMostWithTimeout</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, int timeoutMillis, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga2e86bfec6de8b35caba5fc00a83489a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter-gather, best-effort read of the next datagram with a per-call timeout.  <br /></td></tr>
<tr class="memitem:gabddf96e6ee7f156a0fa09a054551744f" id="r_gabddf96e6ee7f156a0fa09a054551744f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabddf96e6ee7f156a0fa09a054551744f">jsocketpp::DatagramSocket::readvAtMostWithTimeout</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, int timeoutMillis) const</td></tr>
<tr class="memdesc:gabddf96e6ee7f156a0fa09a054551744f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper returning only the number of bytes read.  <br /></td></tr>
<tr class="memitem:ga94a10f136669c41e25fa2be205bd90af" id="r_ga94a10f136669c41e25fa2be205bd90af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga94a10f136669c41e25fa2be205bd90af">jsocketpp::DatagramSocket::readvAllWithTotalTimeout</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, int totalTimeoutMillis, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga94a10f136669c41e25fa2be205bd90af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter-gather, strict no-truncation receive with a per-call total timeout.  <br /></td></tr>
<tr class="memitem:ga037a8dcf56048b94e398842993021f0a" id="r_ga037a8dcf56048b94e398842993021f0a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga037a8dcf56048b94e398842993021f0a">jsocketpp::DatagramSocket::readvAllWithTotalTimeoutBytes</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, int totalTimeoutMillis, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:ga037a8dcf56048b94e398842993021f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper returning only the number of bytes copied.  <br /></td></tr>
<tr class="memitem:gadfec1ac007add5eddeabee9c19a621cf" id="r_gadfec1ac007add5eddeabee9c19a621cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadfec1ac007add5eddeabee9c19a621cf">jsocketpp::DatagramSocket::peek</a> (<a class="el" href="classjsocketpp_1_1DatagramPacket.html">DatagramPacket</a> &amp;packet, bool allowResize=true, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;opts={}) const</td></tr>
<tr class="memdesc:gadfec1ac007add5eddeabee9c19a621cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next UDP datagram without consuming it (single receive with MSG_PEEK).  <br /></td></tr>
<tr class="memitem:ga9befab6dbf6e8fc0dd9ee0e9645ea099" id="r_ga9befab6dbf6e8fc0dd9ee0e9645ea099"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9befab6dbf6e8fc0dd9ee0e9645ea099">jsocketpp::DatagramSocket::hasPendingData</a> (int timeoutMillis) const</td></tr>
<tr class="memdesc:ga9befab6dbf6e8fc0dd9ee0e9645ea099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the socket is readable within a timeout (no data is consumed).  <br /></td></tr>
<tr class="memitem:gabd73eb7df3c7871b1637ad03cc06b64c" id="r_gabd73eb7df3c7871b1637ad03cc06b64c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabd73eb7df3c7871b1637ad03cc06b64c">jsocketpp::DatagramSocket::getMTU</a> () const</td></tr>
<tr class="memdesc:gabd73eb7df3c7871b1637ad03cc06b64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the Maximum Transmission Unit (MTU) of the local interface associated with the socket.  <br /></td></tr>
<tr class="memitem:ga53fd92734f14407ce6c78d8df246c319" id="r_ga53fd92734f14407ce6c78d8df246c319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga53fd92734f14407ce6c78d8df246c319">jsocketpp::DatagramSocket::waitReady</a> (<a class="el" href="#ga8272a360bdf6e0377f31ac8ce251a837">Direction</a> dir, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga53fd92734f14407ce6c78d8df246c319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the socket is ready for I/O or a timeout occurs.  <br /></td></tr>
<tr class="memitem:ga1b017c1366655d32a2ec5d19deef9d37" id="r_ga1b017c1366655d32a2ec5d19deef9d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b017c1366655d32a2ec5d19deef9d37">jsocketpp::DatagramSocket::setInternalBufferSize</a> (std::size_t newLen)</td></tr>
<tr class="memdesc:ga1b017c1366655d32a2ec5d19deef9d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the internal buffer used for string-based UDP receive operations.  <br /></td></tr>
<tr class="memitem:ga9d0a9582b3a2a72bf62f182dbc33c352" id="r_ga9d0a9582b3a2a72bf62f182dbc33c352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352">jsocketpp::DatagramSocket::close</a> ()</td></tr>
<tr class="memdesc:ga9d0a9582b3a2a72bf62f182dbc33c352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the datagram socket and releases its underlying system resources.  <br /></td></tr>
<tr class="memitem:gab33da807656e2ab920707d60605844f5" id="r_gab33da807656e2ab920707d60605844f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab33da807656e2ab920707d60605844f5">jsocketpp::DatagramSocket::isValid</a> () const noexcept</td></tr>
<tr class="memdesc:gab33da807656e2ab920707d60605844f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the datagram socket is valid and ready for use.  <br /></td></tr>
<tr class="memitem:gae91f746fb4cffa0eb8460c816a476d65" id="r_gae91f746fb4cffa0eb8460c816a476d65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae91f746fb4cffa0eb8460c816a476d65">jsocketpp::DatagramSocket::isClosed</a> () const noexcept</td></tr>
<tr class="memdesc:gae91f746fb4cffa0eb8460c816a476d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the datagram socket has been closed or is otherwise invalid.  <br /></td></tr>
<tr class="memitem:gac19051ec24961addb059f01f1e7f28c7" id="r_gac19051ec24961addb059f01f1e7f28c7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; sockaddr_storage, socklen_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac19051ec24961addb059f01f1e7f28c7">jsocketpp::DatagramSocket::getLastPeerSockAddr</a> () const</td></tr>
<tr class="memdesc:gac19051ec24961addb059f01f1e7f28c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the raw socket address of the last known remote peer.  <br /></td></tr>
<tr class="memitem:ga30912969f0808f064aaeee9a79025f41" id="r_ga30912969f0808f064aaeee9a79025f41"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30912969f0808f064aaeee9a79025f41">jsocketpp::DatagramSocket::readIntoBuffer</a> (char *buf, std::size_t len, <a class="el" href="#ga2124eae8cec6709a67be265f14da3bdd">DatagramReceiveMode</a> mode, int recvFlags, sockaddr_storage *outSrc, socklen_t *outSrcLen, std::size_t *outDatagramSz, bool *outTruncated) const</td></tr>
<tr class="memdesc:ga30912969f0808f064aaeee9a79025f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level, single-recv primitive that copies one UDP datagram into a caller buffer.  <br /></td></tr>
<tr class="memitem:gaa0727094596347aa858629f6e5c7febf" id="r_gaa0727094596347aa858629f6e5c7febf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa0727094596347aa858629f6e5c7febf">jsocketpp::DatagramSocket::cleanup</a> ()</td></tr>
<tr class="memdesc:gaa0727094596347aa858629f6e5c7febf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper that releases socket resources and resets all internal state.  <br /></td></tr>
<tr class="memitem:ga1973415ece2f77f191b250b9e9690733" id="r_ga1973415ece2f77f191b250b9e9690733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1973415ece2f77f191b250b9e9690733">jsocketpp::DatagramSocket::cleanupAndThrow</a> (int errorCode)</td></tr>
<tr class="memdesc:ga1973415ece2f77f191b250b9e9690733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all socket resources and throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with the given error code.  <br /></td></tr>
<tr class="memitem:ga6608c56d08ccdb2807bd47cc862af24a" id="r_ga6608c56d08ccdb2807bd47cc862af24a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6608c56d08ccdb2807bd47cc862af24a">jsocketpp::DatagramSocket::cleanupAndRethrow</a> ()</td></tr>
<tr class="memdesc:ga6608c56d08ccdb2807bd47cc862af24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up the datagram socket and rethrows the currently active exception.  <br /></td></tr>
<tr class="memitem:ga1ff1dc3fb9ed36e31bc62941edf1d44c" id="r_ga1ff1dc3fb9ed36e31bc62941edf1d44c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ff1dc3fb9ed36e31bc62941edf1d44c">jsocketpp::DatagramSocket::chooseReceiveSize</a> () const</td></tr>
<tr class="memdesc:ga1ff1dc3fb9ed36e31bc62941edf1d44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide how many bytes to attempt to receive for the next UDP datagram.  <br /></td></tr>
<tr class="memitem:ga3f8607eac97767c09210d8836fdd860f" id="r_ga3f8607eac97767c09210d8836fdd860f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f8607eac97767c09210d8836fdd860f">jsocketpp::DatagramSocket::throwSizeMismatch</a> (const std::size_t expected, const std::size_t actual, const bool isProbedKnown)</td></tr>
<tr class="memdesc:ga3f8607eac97767c09210d8836fdd860f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a descriptive exception when a UDP datagram’s size differs from what was expected.  <br /></td></tr>
<tr class="memitem:ga71ea4f3e14d566fe91a188f4cc4a5f64" id="r_ga71ea4f3e14d566fe91a188f4cc4a5f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64">jsocketpp::DatagramSocket::enforceSendCapConnected</a> (const std::size_t payloadSize) const</td></tr>
<tr class="memdesc:ga71ea4f3e14d566fe91a188f4cc4a5f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce UDP payload size limits for <b>connected</b> datagram sends.  <br /></td></tr>
<tr class="memitem:gab12e38ad202aa788d89980864d3e83bc" id="r_gab12e38ad202aa788d89980864d3e83bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc">jsocketpp::DatagramSocket::sendUnconnectedTo</a> (std::string_view host, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, const void *data, std::size_t len)</td></tr>
<tr class="memdesc:gab12e38ad202aa788d89980864d3e83bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve and send one unconnected UDP datagram to the first compatible destination.  <br /></td></tr>
<tr class="memitem:ga20eb26c65ff8d9c880494e028509e0a8" id="r_ga20eb26c65ff8d9c880494e028509e0a8"><td class="memItemLeft" align="right" valign="top">static std::span&lt; const std::byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga20eb26c65ff8d9c880494e028509e0a8">jsocketpp::DatagramSocket::asBytes</a> (const std::string_view sv) noexcept</td></tr>
<tr class="memdesc:ga20eb26c65ff8d9c880494e028509e0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">View a textual buffer as raw bytes without copying.  <br /></td></tr>
<tr class="memitem:ga6de9a0542180215e2f2520148c71f1b4" id="r_ga6de9a0542180215e2f2520148c71f1b4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga6de9a0542180215e2f2520148c71f1b4 template"><td class="memItemLeft" align="right" valign="top">static std::array&lt; std::byte, sizeof(T)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4">jsocketpp::DatagramSocket::encodeLengthPrefixBE</a> (std::size_t n)</td></tr>
<tr class="memdesc:ga6de9a0542180215e2f2520148c71f1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a length value into a fixed-size, big-endian (network-order) byte array.  <br /></td></tr>
<tr class="memitem:ga463c1511ac0622b623fa2937314e1239" id="r_ga463c1511ac0622b623fa2937314e1239"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga463c1511ac0622b623fa2937314e1239 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga463c1511ac0622b623fa2937314e1239">jsocketpp::DatagramSocket::sendPrefixedConnected</a> (const std::span&lt; const std::byte &gt; payload) const</td></tr>
<tr class="memdesc:ga463c1511ac0622b623fa2937314e1239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and send a length-prefixed UDP datagram to the connected peer (no pre-wait).  <br /></td></tr>
<tr class="memitem:ga5c4761b07760b1eadf84b9fbed700c98" id="r_ga5c4761b07760b1eadf84b9fbed700c98"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga5c4761b07760b1eadf84b9fbed700c98 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c4761b07760b1eadf84b9fbed700c98">jsocketpp::DatagramSocket::sendPrefixedUnconnected</a> (const std::string_view host, const <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, const std::span&lt; const std::byte &gt; payload)</td></tr>
<tr class="memdesc:ga5c4761b07760b1eadf84b9fbed700c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and send a length-prefixed UDP datagram to (host, port) on the unconnected path.  <br /></td></tr>
<tr class="memitem:ga465ec84374a81fa09cf486e054863673" id="r_ga465ec84374a81fa09cf486e054863673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga465ec84374a81fa09cf486e054863673">jsocketpp::DatagramSocket::cacheLocalEndpoint</a> () noexcept</td></tr>
<tr class="memdesc:ga465ec84374a81fa09cf486e054863673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache the actual local endpoint assigned by the OS.  <br /></td></tr>
<tr class="memitem:ga219654befe4bb7c3024e9fab59f0ca64" id="r_ga219654befe4bb7c3024e9fab59f0ca64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga219654befe4bb7c3024e9fab59f0ca64">jsocketpp::DatagramSocket::tryGetRemoteSockaddr</a> (sockaddr_storage &amp;out, socklen_t &amp;outLen) const</td></tr>
<tr class="memdesc:ga219654befe4bb7c3024e9fab59f0ca64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the remote endpoint sockaddr for this socket, if available.  <br /></td></tr>
<tr class="memitem:ga996b99882efa863b01e0fff4a9782a82" id="r_ga996b99882efa863b01e0fff4a9782a82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga996b99882efa863b01e0fff4a9782a82">jsocketpp::MulticastSocket::MulticastSocket</a> (<a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> localPort, std::string_view localAddress, std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, bool reuseAddress=true, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool nonBlocking=false, bool dualStack=true, bool autoBind=true)</td></tr>
<tr class="memdesc:ga996b99882efa863b01e0fff4a9782a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a fully configurable multicast socket for receiving and sending datagrams.  <br /></td></tr>
<tr class="memitem:ga7937b05ccae7d059b4fcfa4b6383c75c" id="r_ga7937b05ccae7d059b4fcfa4b6383c75c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7937b05ccae7d059b4fcfa4b6383c75c">jsocketpp::MulticastSocket::joinGroup</a> (const std::string &amp;groupAddr, const std::string &amp;iface)</td></tr>
<tr class="memdesc:ga7937b05ccae7d059b4fcfa4b6383c75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a multicast group on an optional interface (string-friendly).  <br /></td></tr>
<tr class="memitem:gaf7317567ceae9b90967ec5a29d003af3" id="r_gaf7317567ceae9b90967ec5a29d003af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf7317567ceae9b90967ec5a29d003af3">jsocketpp::MulticastSocket::leaveGroup</a> (const std::string &amp;groupAddr, const std::string &amp;iface=&quot;&quot;)</td></tr>
<tr class="memdesc:gaf7317567ceae9b90967ec5a29d003af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a multicast group on an optional interface (string-friendly).  <br /></td></tr>
<tr class="memitem:gaf0d5d684dcbfcf62907482ae3ac98948" id="r_gaf0d5d684dcbfcf62907482ae3ac98948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948">jsocketpp::MulticastSocket::setMulticastInterface</a> (const std::string &amp;iface)</td></tr>
<tr class="memdesc:gaf0d5d684dcbfcf62907482ae3ac98948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the default outgoing interface for multicast transmissions.  <br /></td></tr>
<tr class="memitem:gaa47a2a344af40c080a860d5ee0883fd0" id="r_gaa47a2a344af40c080a860d5ee0883fd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa47a2a344af40c080a860d5ee0883fd0">jsocketpp::MulticastSocket::getMulticastInterface</a> () const</td></tr>
<tr class="memdesc:gaa47a2a344af40c080a860d5ee0883fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently selected egress interface for multicast transmissions.  <br /></td></tr>
<tr class="memitem:ga72172a10bc5ba13a908f31c791c90ec5" id="r_ga72172a10bc5ba13a908f31c791c90ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga72172a10bc5ba13a908f31c791c90ec5">jsocketpp::MulticastSocket::setTimeToLive</a> (int ttl)</td></tr>
<tr class="memdesc:ga72172a10bc5ba13a908f31c791c90ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time-to-live (TTL) / hop limit for outgoing multicast packets.  <br /></td></tr>
<tr class="memitem:gab6608be5d1aff24ad5077f6ea9a9168a" id="r_gab6608be5d1aff24ad5077f6ea9a9168a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab6608be5d1aff24ad5077f6ea9a9168a">jsocketpp::MulticastSocket::setLoopbackMode</a> (bool enable)</td></tr>
<tr class="memdesc:gab6608be5d1aff24ad5077f6ea9a9168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable multicast loopback for this socket.  <br /></td></tr>
<tr class="memitem:ga6235d9f1a2f2a9145b1c2c497d2ac26a" id="r_ga6235d9f1a2f2a9145b1c2c497d2ac26a"><td class="memItemLeft" align="right" valign="top">static in_addr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6235d9f1a2f2a9145b1c2c497d2ac26a">jsocketpp::MulticastSocket::resolveIPv4</a> (std::string_view host)</td></tr>
<tr class="memdesc:ga6235d9f1a2f2a9145b1c2c497d2ac26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve a host string to an IPv4 address (<span class="tt">in_addr</span>, network byte order).  <br /></td></tr>
<tr class="memitem:ga47a296c0592019a915a2046874d98184" id="r_ga47a296c0592019a915a2046874d98184"><td class="memItemLeft" align="right" valign="top">static in6_addr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga47a296c0592019a915a2046874d98184">jsocketpp::MulticastSocket::resolveIPv6</a> (std::string_view host)</td></tr>
<tr class="memdesc:ga47a296c0592019a915a2046874d98184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve a host string to an IPv6 address (<span class="tt">in6_addr</span>).  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Classes and functions for UDP datagram networking. </p>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2124eae8cec6709a67be265f14da3bdd" name="ga2124eae8cec6709a67be265f14da3bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2124eae8cec6709a67be265f14da3bdd">&#9670;&#160;</a></span>DatagramReceiveMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ga2124eae8cec6709a67be265f14da3bdd">jsocketpp::DatagramReceiveMode</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive-time sizing policy for UDP datagrams. </p>
<p>Controls how <span class="tt">DatagramSocket::read(...)</span> chooses the number of bytes to request from the OS for the <b>next</b> UDP datagram. This affects both the likelihood of truncation and the number of syscalls performed per receive.</p>
<p><b>General behavior</b></p><ul>
<li>In all modes, exactly <b>one</b> datagram is consumed per call.</li>
<li>The OS may truncate the payload if the destination buffer is smaller than the datagram.</li>
<li>For <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramPacket.html" title="Represents a UDP datagram packet, encapsulating both payload and addressing information.">DatagramPacket</a>&amp;</span> variants, the <span class="tt">resizeBuffer</span> parameter still applies and determines whether the packet’s buffer may be <b>grown/shrunk</b> by the call (see individual modes).</li>
<li>For raw-buffer variants (e.g., <span class="tt">readInto()</span>), the buffer size is fixed by the caller; no resizing is possible, but truncation may occur.</li>
</ul>
<p><b>Performance note</b></p><ul>
<li>Modes that preflight the exact datagram size typically issue an <b>extra syscall</b> (e.g., <span class="tt">FIONREAD</span> or <span class="tt">MSG_PEEK|MSG_TRUNC</span>) before the actual receive. This improves sizing accuracy at a small cost in throughput.</li>
</ul>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1DatagramPacket.html">DatagramPacket</a> pkt;</div>
<div class="line">pkt.<a class="code hl_function" href="classjsocketpp_1_1DatagramPacket.html#a2c99540d2136dae10a56f781c1b20c5f">resize</a>(8192); <span class="comment">// provision capacity</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Default (no preflight): fastest path; may truncate if a datagram &gt; 8192 arrives</span></div>
<div class="line">std::size_t n = sock.read(pkt, <span class="keyword">true</span>, <a class="code hl_enumvalue" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f">jsocketpp::DatagramReceiveMode::NoPreflight</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Preflight: probe exact size and (if allowed) grow pkt before receiving to avoid truncation</span></div>
<div class="line">n = sock.read(pkt, <span class="keyword">true</span>, <a class="code hl_enumvalue" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd">jsocketpp::DatagramReceiveMode::PreflightSize</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// PreflightMax: probe size but never request more than current capacity (or provided length)</span></div>
<div class="line">n = sock.read(pkt, <span class="keyword">false</span>, <a class="code hl_enumvalue" href="#gga2124eae8cec6709a67be265f14da3bddac9a017cf1d4a5f3aff960a3f7e8bffd5">jsocketpp::DatagramReceiveMode::PreflightMax</a>);</div>
<div class="ttc" id="aclassjsocketpp_1_1DatagramPacket_html"><div class="ttname"><a href="classjsocketpp_1_1DatagramPacket.html">jsocketpp::DatagramPacket</a></div><div class="ttdoc">Represents a UDP datagram packet, encapsulating both payload and addressing information.</div><div class="ttdef"><b>Definition</b> DatagramPacket.hpp:48</div></div>
<div class="ttc" id="aclassjsocketpp_1_1DatagramPacket_html_a2c99540d2136dae10a56f781c1b20c5f"><div class="ttname"><a href="classjsocketpp_1_1DatagramPacket.html#a2c99540d2136dae10a56f781c1b20c5f">jsocketpp::DatagramPacket::resize</a></div><div class="ttdeci">void resize(const size_t newSize)</div><div class="ttdoc">Resize the packet&#39;s internal buffer.</div><div class="ttdef"><b>Definition</b> DatagramPacket.hpp:112</div></div>
<div class="ttc" id="agroup__udp_html_gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd"><div class="ttname"><a href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd">jsocketpp::DatagramReceiveMode::PreflightSize</a></div><div class="ttdeci">@ PreflightSize</div><div class="ttdoc">Probe the exact size of the next datagram and size the receive accordingly.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:97</div></div>
<div class="ttc" id="agroup__udp_html_gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f"><div class="ttname"><a href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f">jsocketpp::DatagramReceiveMode::NoPreflight</a></div><div class="ttdeci">@ NoPreflight</div><div class="ttdoc">Do not probe the datagram size; call recvfrom() directly.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:78</div></div>
<div class="ttc" id="agroup__udp_html_gga2124eae8cec6709a67be265f14da3bddac9a017cf1d4a5f3aff960a3f7e8bffd5"><div class="ttname"><a href="#gga2124eae8cec6709a67be265f14da3bddac9a017cf1d4a5f3aff960a3f7e8bffd5">jsocketpp::DatagramReceiveMode::PreflightMax</a></div><div class="ttdeci">@ PreflightMax</div><div class="ttdoc">Probe the size of the next datagram but cap it at the current buffer length.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:113</div></div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f" name="gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f"></a>NoPreflight&#160;</td><td class="fielddoc"><p>Do not probe the datagram size; call <span class="tt">recvfrom()</span> directly. </p>
<ul>
<li><b>Syscalls:</b> 1 (fast path).</li>
<li><b>Resizing:</b> If <span class="tt">resizeBuffer == true</span>, the packet may be <b>shrunk</b> <em>after</em> the receive to match the actual byte count; it is <b>not</b> grown beforehand.</li>
<li><b>Truncation:</b> If the incoming datagram exceeds the current buffer size, the OS returns only the first <span class="tt">buffer.size()</span> bytes and discards the rest (standard UDP behavior).</li>
</ul>
<p>Use this for fixed-size protocols or hot paths where every syscall counts. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd" name="gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd"></a>PreflightSize&#160;</td><td class="fielddoc"><p>Probe the exact size of the next datagram and size the receive accordingly. </p>
<ul>
<li><b>Syscalls:</b> up to 2 (probe, then receive).</li>
<li><b>Resizing (<a class="el" href="classjsocketpp_1_1DatagramPacket.html" title="Represents a UDP datagram packet, encapsulating both payload and addressing information.">DatagramPacket</a>):</b> If <span class="tt">resizeBuffer == true</span> and the probed size is greater than <span class="tt">packet.size()</span>, the implementation may <b>grow</b> the packet (clamped to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>) to avoid truncation. If <span class="tt">resizeBuffer == false</span>, the packet is <b>not grown</b> and truncation may still occur.</li>
<li><b>Raw buffer:</b> Reads exactly the probed size if it fits in <span class="tt">len</span>, otherwise truncates to <span class="tt">len</span>.</li>
<li><b>Accuracy:</b> Uses platform facilities such as <span class="tt">FIONREAD</span> or a POSIX <span class="tt">MSG_PEEK|MSG_TRUNC</span> probe via <span class="tt">nextDatagramSize()</span>. On platforms where the probe is unavailable or unreliable, behavior gracefully degrades to <span class="tt">NoPreflight</span>.</li>
</ul>
<p>Choose this when datagram sizes vary widely and avoiding truncation is more important than minimizing syscalls. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2124eae8cec6709a67be265f14da3bddac9a017cf1d4a5f3aff960a3f7e8bffd5" name="gga2124eae8cec6709a67be265f14da3bddac9a017cf1d4a5f3aff960a3f7e8bffd5"></a>PreflightMax&#160;</td><td class="fielddoc"><p>Probe the size of the next datagram but cap it at the current buffer length. </p>
<ul>
<li><b>Syscalls:</b> up to 2 (probe, then receive).</li>
<li><b>Resizing (<a class="el" href="classjsocketpp_1_1DatagramPacket.html" title="Represents a UDP datagram packet, encapsulating both payload and addressing information.">DatagramPacket</a>):</b> If <span class="tt">resizeBuffer == true</span> and the probed size is less than or equal to <span class="tt">packet.size()</span>, the packet may be shrunk to the exact size after the receive. If the probed size is greater than <span class="tt">packet.size()</span>, truncation occurs; the packet is never grown.</li>
<li><b>Raw buffer:</b> Reads exactly <span class="tt">min(probedSize, len)</span>.</li>
<li><b>Accuracy:</b> Same probe mechanism as <span class="tt">PreflightSize</span>.</li>
</ul>
<p>Use this to avoid oversizing reads while still skipping unnecessary extra bytes for smaller datagrams. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8272a360bdf6e0377f31ac8ce251a837" name="ga8272a360bdf6e0377f31ac8ce251a837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8272a360bdf6e0377f31ac8ce251a837">&#9670;&#160;</a></span>Direction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ga8272a360bdf6e0377f31ac8ce251a837">jsocketpp::Direction</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I/O readiness selector used by waitReady(). </p>
<p>Specifies which readiness condition to wait for on a datagram socket when calling <span class="tt">waitReady()</span>. On POSIX systems this corresponds to polling for <span class="tt">POLLIN</span> (readable) and/or <span class="tt">POLLOUT</span> (writable). On Windows, it maps to <span class="tt">POLLRDNORM</span> and/or <span class="tt">POLLWRNORM</span> via <span class="tt">WSAPoll</span>. For UDP sockets:</p>
<ul>
<li><b>Read</b> means at least one complete datagram is queued and can be received without blocking.</li>
<li><b>Write</b> generally indicates the socket is writable (datagrams can be sent without blocking), though UDP sockets are often immediately writable unless the send buffer is full or an error is pending.</li>
<li><b>ReadWrite</b> requests readiness for either read or write (logical OR of the above conditions).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This selector controls <em>which</em> condition is awaited; timeout behavior and error reporting are defined by <span class="tt">waitReady()</span> itself. Exceptional poll conditions (e.g., error flags) are surfaced by <span class="tt">waitReady()</span> as exceptions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>waitReady() </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8272a360bdf6e0377f31ac8ce251a837a7a1a5f3e79fdc91edf2f5ead9d66abb4" name="gga8272a360bdf6e0377f31ac8ce251a837a7a1a5f3e79fdc91edf2f5ead9d66abb4"></a>Read&#160;</td><td class="fielddoc"><p>Wait until the socket is readable (one or more datagrams available). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8272a360bdf6e0377f31ac8ce251a837a1129c0e4d43f2d121652a7302712cff6" name="gga8272a360bdf6e0377f31ac8ce251a837a1129c0e4d43f2d121652a7302712cff6"></a>Write&#160;</td><td class="fielddoc"><p>Wait until the socket is writable (can send a datagram without blocking). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8272a360bdf6e0377f31ac8ce251a837a70a2a84088d405a2e3f1e3accaa16723" name="gga8272a360bdf6e0377f31ac8ce251a837a70a2a84088d405a2e3f1e3accaa16723"></a>ReadWrite&#160;</td><td class="fielddoc"><p>Wait until the socket is readable <b>or</b> writable (logical OR). </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga20eb26c65ff8d9c880494e028509e0a8" name="ga20eb26c65ff8d9c880494e028509e0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20eb26c65ff8d9c880494e028509e0a8">&#9670;&#160;</a></span>asBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const std::byte &gt; jsocketpp::DatagramSocket::asBytes </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel protected">protected</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View a textual buffer as raw bytes without copying. </p>
<p>Returns a <span class="tt">std::span&lt;const std::byte&gt;</span> that references the same memory as the input <span class="tt">std::string_view</span> <code class="param">sv</code>. This is an <b>O(1)</b>, zero-allocation conversion intended for APIs that operate on binary payloads (e.g., UDP datagram sends) while callers may naturally hold data as text.</p>
<ul>
<li>The resulting span <b>does not</b> include any null terminator; it covers exactly <span class="tt">sv.size()</span> bytes starting at <span class="tt">sv.data()</span>.</li>
<li>The span is <b>non-owning</b>; its lifetime and validity are tied to the lifetime of the storage viewed by <code class="param">sv</code>. Callers must ensure that storage remains alive until any I/O using the span completes.</li>
<li>Aliasing/strict-aliasing: viewing <span class="tt">char</span>/<span class="tt">unsigned char</span> storage as <span class="tt">std::byte</span> for read-only purposes is well-formed; this helper never writes through the span.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>The textual data to re-interpret as bytes. May be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A byte-span referencing the same memory as <code class="param">sv</code> (possibly empty).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function performs no validation or transcoding; it is a shallow view conversion only. For structured data, prefer explicit serialization.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>write(std::span&lt;const std::byte&gt;), write(std::string_view), writePrefixed&lt;T&gt;(std::string_view), writePrefixed&lt;T&gt;(std::span&lt;const std::byte&gt;), sendPrefixedConnected&lt;T&gt;(std::span&lt;const std::byte&gt;), <a class="el" href="#ga5c4761b07760b1eadf84b9fbed700c98" title="Build and send a length-prefixed UDP datagram to (host, port) on the unconnected path.">sendPrefixedUnconnected&lt;T&gt;(std::string_view, Port, std::span&lt;const std::byte&gt;)</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Treat a string payload as raw bytes for binary-oriented send paths:</span></div>
<div class="line">std::string payload = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line"><span class="keyword">auto</span> bytes = <a class="code hl_function" href="#ga20eb26c65ff8d9c880494e028509e0a8">DatagramSocket::asBytes</a>(std::string_view{payload});</div>
<div class="line">sock.write(bytes); <span class="comment">// sends as a single UDP datagram</span></div>
<div class="ttc" id="agroup__udp_html_ga20eb26c65ff8d9c880494e028509e0a8"><div class="ttname"><a href="#ga20eb26c65ff8d9c880494e028509e0a8">jsocketpp::DatagramSocket::asBytes</a></div><div class="ttdeci">static std::span&lt; const std::byte &gt; asBytes(const std::string_view sv) noexcept</div><div class="ttdoc">View a textual buffer as raw bytes without copying.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:4544</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga550b67d7ad08c5cb068bb2b66d2c2c49" name="ga550b67d7ad08c5cb068bb2b66d2c2c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">&#9670;&#160;</a></span>bind() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::bind </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the datagram socket to all available interfaces on an ephemeral port. </p>
<p>This method binds the <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> to an ephemeral (auto-assigned) local port on all local network interfaces (<span class="tt">0.0.0.0</span> for IPv4 or <span class="tt">::</span> for IPv6), depending on system configuration and address resolution.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md668"></a>
Common Use Cases</h3>
<ul>
<li>UDP client sockets that do not require a specific local port</li>
<li>Transient sockets used for fire-and-forget messages, RPC, or NAT traversal</li>
<li>Applications that allow the OS to choose a source port dynamically</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md669"></a>
Behavior</h3>
<ul>
<li>Uses <span class="tt">getaddrinfo()</span> with <span class="tt">AI_PASSIVE</span> and a wildcard local address (<span class="tt">0.0.0.0</span> or <span class="tt">::</span>)</li>
<li>Binds to the first successfully resolved and compatible local address</li>
<li>On success, updates internal <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a8c77f16fcae1c86b679a0567de055b7d" title="True if the socket is bound to an address.">_isBound</a></span> flag and enables receiving datagrams</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This method may only be called once per socket instance. Rebinding is not supported. </dd>
<dd>
If the socket was constructed with an already-resolved address, this will override it.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if address resolution or binding fails.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> sock;</div>
<div class="line">sock.<a class="code hl_function" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">bind</a>(); <span class="comment">// Binds to all interfaces on an ephemeral port (e.g., 0.0.0.0:49512 or [::]:49512)</span></div>
<div class="ttc" id="agroup__udp_html_ga4b4c631816f82eea0b6048a16682079e"><div class="ttname"><a href="#ga4b4c631816f82eea0b6048a16682079e">jsocketpp::DatagramSocket::DatagramSocket</a></div><div class="ttdeci">DatagramSocket(Port localPort=0, std::string_view localAddress=&quot;&quot;, std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, bool reuseAddress=true, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool nonBlocking=false, bool dualStack=true, bool autoBind=true, bool autoConnect=false, std::string_view remoteAddress=&quot;&quot;, Port remotePort=0, int connectTimeoutMillis=-1)</div><div class="ttdoc">Creates a UDP socket, optionally binds to a local address, and optionally connects to a remote peer.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:12</div></div>
<div class="ttc" id="agroup__udp_html_ga550b67d7ad08c5cb068bb2b66d2c2c49"><div class="ttname"><a href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">jsocketpp::DatagramSocket::bind</a></div><div class="ttdeci">void bind()</div><div class="ttdoc">Binds the datagram socket to all available interfaces on an ephemeral port.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:243</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga614ad4b99d492f9e6ad5c5b63a97c751" title="Binds the datagram socket to a specific local port on all network interfaces.">bind(Port localPort)</a>, <a class="el" href="#ga386fcebc37da51731299a12b915d148f" title="Binds the datagram socket to a specific local IP address and port.">bind(std::string_view localAddress, Port localPort)</a>, <a class="el" href="#ga2b19edc594f75938a6028094744ec107" title="Return the local endpoint as a single &quot;ip:port&quot; string.">getLocalSocketAddress()</a> </dd></dl>

</div>
</div>
<a id="ga614ad4b99d492f9e6ad5c5b63a97c751" name="ga614ad4b99d492f9e6ad5c5b63a97c751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga614ad4b99d492f9e6ad5c5b63a97c751">&#9670;&#160;</a></span>bind() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>localPort</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the datagram socket to a specific local port on all network interfaces. </p>
<p>This overload binds the socket to the given UDP <span class="tt">localPort</span> across all available network interfaces, using a wildcard address (<span class="tt">0.0.0.0</span> for IPv4 or <span class="tt">::</span> for IPv6).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md670"></a>
Common Use Cases</h3>
<ul>
<li>Server-side sockets that need to receive packets on a known port</li>
<li>P2P or NAT traversal clients using fixed source ports</li>
<li>Test setups or replay systems where the port number must be predictable</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md671"></a>
Behavior</h3>
<ul>
<li>Uses <span class="tt">getaddrinfo()</span> with <span class="tt">AI_PASSIVE</span> and a null host to resolve wildcard binding addresses</li>
<li>Attempts all resolved addresses until <span class="tt"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a></span> succeeds</li>
<li>If successful, sets <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a8c77f16fcae1c86b679a0567de055b7d" title="True if the socket is bound to an address.">_isBound</a> = true</span> and enables subsequent <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read()</a></span> or <span class="tt">recvFrom()</span> operations</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localPort</td><td>UDP port number to bind to. Must be in the range [1, 65535], or 0 to request an ephemeral port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method may only be called once per socket instance. Rebinding is not supported. </dd>
<dd>
If the specified port is already in use, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> will be thrown.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if address resolution or binding fails, or if the socket is already bound.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> server;</div>
<div class="line">server.<a class="code hl_function" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">bind</a>(12345); <span class="comment">// Bind to port 12345 on all interfaces</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a>, <a class="el" href="#ga386fcebc37da51731299a12b915d148f" title="Binds the datagram socket to a specific local IP address and port.">bind(std::string_view, Port)</a>, <a class="el" href="#ga2b19edc594f75938a6028094744ec107" title="Return the local endpoint as a single &quot;ip:port&quot; string.">getLocalSocketAddress()</a>, <a class="el" href="group__socketopts.html#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a> </dd></dl>

</div>
</div>
<a id="ga386fcebc37da51731299a12b915d148f" name="ga386fcebc37da51731299a12b915d148f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga386fcebc37da51731299a12b915d148f">&#9670;&#160;</a></span>bind() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::bind </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>localPort</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the datagram socket to a specific local IP address and port. </p>
<p>This method allows full control over the local binding interface by specifying both the local IP address (<span class="tt">host</span>) and port. It supports IPv4 and IPv6 addresses, including loopback, multicast-capable interfaces, and link-local addresses.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md672"></a>
Common Use Cases</h3>
<ul>
<li>Multihomed systems binding to a specific NIC/interface</li>
<li>Clients or servers requiring fixed local IP-port pairing</li>
<li>Binding to loopback or link-local addresses</li>
<li>Low-level networking tools (e.g., packet sniffers, trace clients)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md673"></a>
Behavior</h3>
<ul>
<li>Uses <span class="tt">getaddrinfo()</span> to resolve the provided IP/hostname and port</li>
<li>Tries all resolved addresses until one binds successfully</li>
<li>Updates internal state to reflect the binding result</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localAddress</td><td>Local IP address or hostname to bind to (e.g., "127.0.0.1", "::1", "eth0.local"). Use "0.0.0.0" or "::" to bind to all interfaces (same as <span class="tt">bind(port)</span>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localPort</td><td>Local UDP port number to bind to. Use 0 for ephemeral port assignment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method may only be called once. Rebinding is not supported. </dd>
<dd>
If resolution fails, or no address can be bound, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if address resolution or binding fails.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> sock;</div>
<div class="line">sock.<a class="code hl_function" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">bind</a>(<span class="stringliteral">&quot;192.168.1.42&quot;</span>, 9000); <span class="comment">// Bind to specific interface and port</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a>, <a class="el" href="#ga614ad4b99d492f9e6ad5c5b63a97c751" title="Binds the datagram socket to a specific local port on all network interfaces.">bind(Port)</a>, <a class="el" href="#ga2b19edc594f75938a6028094744ec107" title="Return the local endpoint as a single &quot;ip:port&quot; string.">getLocalSocketAddress()</a>, <a class="el" href="group__socketopts.html#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a> </dd></dl>

</div>
</div>
<a id="ga465ec84374a81fa09cf486e054863673" name="ga465ec84374a81fa09cf486e054863673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga465ec84374a81fa09cf486e054863673">&#9670;&#160;</a></span>cacheLocalEndpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::cacheLocalEndpoint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache the actual local endpoint assigned by the OS. </p>
<p>Invokes <span class="tt">getsockname()</span> on the socket and stores the result in <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a87523b567e1963c683584ed19c1d6f84" title="Cached local socket address (set by bind()/UDP connect() via getsockname()).">_localAddr</a></span>/<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a471ce3677773b7fb9fb7766e247bc76f" title="Size in bytes of the cached local address stored in _localAddr.">_localAddrLen</a></span>, setting <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a97c828576d9ee0290be3feb35a1bc81c" title="True if _localAddr/_localAddrLen contain a valid endpoint; reset on close().">_haveLocalAddr</a></span> to <span class="tt">true</span> on success. Call this immediately after a successful <span class="tt"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a></span> or after a UDP <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span> that implicitly binds an ephemeral port. If <span class="tt">getsockname()</span> fails, the existing cached values are left unchanged.</p>
<dl class="section post"><dt>Postcondition</dt><dd>On success: <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a97c828576d9ee0290be3feb35a1bc81c" title="True if _localAddr/_localAddrLen contain a valid endpoint; reset on close().">_haveLocalAddr</a> == true</span> and <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a87523b567e1963c683584ed19c1d6f84" title="Cached local socket address (set by bind()/UDP connect() via getsockname()).">_localAddr</a></span>/<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a471ce3677773b7fb9fb7766e247bc76f" title="Size in bytes of the cached local address stored in _localAddr.">_localAddrLen</a></span> contain a valid <span class="tt">AF_INET</span> or <span class="tt">AF_INET6</span> endpoint. On failure: cache remains as it was.</dd></dl>
<p>@thread_safety Intended for the owning thread of the socket. Not synchronized against concurrent <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span>; coordinate externally if those may race.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>This function is <span class="tt">noexcept</span> and never throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ff1dc3fb9ed36e31bc62941edf1d44c" name="ga1ff1dc3fb9ed36e31bc62941edf1d44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ff1dc3fb9ed36e31bc62941edf1d44c">&#9670;&#160;</a></span>chooseReceiveSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::DatagramSocket::chooseReceiveSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decide how many bytes to attempt to receive for the next UDP datagram. </p>
<p>This method centralizes the library’s <b>Java-like sizing policy</b> so all UDP <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read()</a></span> variants behave consistently while keeping <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a03328f6602738b63c4a6c8a720ec1204" title="Internal buffer for read operations.">_internalBuffer</a></span> as reusable storage only (never resized here).</p>
<p><b>Policy order:</b></p><ol type="1">
<li><b>Prefer exact size</b> from <span class="tt">jsocketpp::internal::nextDatagramSize(getSocketFd())</span>. If the platform reports the pending datagram length, use that value.</li>
<li><b>Otherwise, use caller capacity</b>: if <span class="tt">_internalBuffer.size() &gt; 0</span>, treat it as the caller-provided maximum (Java semantics).</li>
<li>If the internal buffer is <b>unset/empty</b>, fall back to <span class="tt"><a class="el" href="group__core.html#ga2fb9d73742801c62e90aeb505c618c43" title="Fallback receive size (in bytes) for UDP datagrams when the exact size is unknown.">DefaultDatagramReceiveSize</a></span>.</li>
<li><b>Clamp</b> the chosen value to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span> (65,507 bytes) to avoid oversizing.</li>
</ol>
<p><b>Semantics:</b></p><ul>
<li>This method performs <b>no I/O</b> and <b>never resizes</b> <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a03328f6602738b63c4a6c8a720ec1204" title="Internal buffer for read operations.">_internalBuffer</a></span>.</li>
<li>The returned value is a <b>target</b> receive size; the actual bytes read may be less (e.g., zero-length datagrams, short reads, or errors).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Proposed byte count to pass to <span class="tt">recv()</span> / <span class="tt">recvfrom()</span> for the next datagram.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a></span> is valid if the result will be used immediately for I/O. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the OS cannot report exact size and the sender’s datagram exceeds both the chosen value and available destination storage, the payload may be truncated (standard UDP behavior). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejsocketpp_1_1internal.html#a592175a5a77f541b400879a5a4ca8978" title="Query the exact size of the next UDP datagram, if the platform can provide it.">jsocketpp::internal::nextDatagramSize()</a> </dd>
<dd>
<a class="el" href="group__core.html#ga2fb9d73742801c62e90aeb505c618c43" title="Fallback receive size (in bytes) for UDP datagrams when the exact size is unknown.">DefaultDatagramReceiveSize</a> </dd>
<dd>
<a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a id="gaa0727094596347aa858629f6e5c7febf" name="gaa0727094596347aa858629f6e5c7febf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0727094596347aa858629f6e5c7febf">&#9670;&#160;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::cleanup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal helper that releases socket resources and resets all internal state. </p>
<p>This method safely resets the <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> to an uninitialized state. It is used during error recovery to release partially constructed socket state, and ensures the object no longer appears bound or connected after failure.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md707"></a>
⚙️ Behavior</h3>
<ul>
<li>Closes the socket if it is valid (<span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>)</li>
<li>Sets the socket descriptor to <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></li>
<li>Resets internal flags:<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a8c77f16fcae1c86b679a0567de055b7d" title="True if the socket is bound to an address.">_isBound</a> = false</span></li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#acc0850711b172f6c6c8bf0649c530ea0" title="True if the socket is connected to a remote host.">_isConnected</a> = false</span></li>
</ul>
</li>
<li>Clears cached local and remote address structures:<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a87523b567e1963c683584ed19c1d6f84" title="Cached local socket address (set by bind()/UDP connect() via getsockname()).">_localAddr</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a471ce3677773b7fb9fb7766e247bc76f" title="Size in bytes of the cached local address stored in _localAddr.">_localAddrLen</a></span></li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#ac53f064c3e7249b78d895121d3ead632" title="Storage for the address of the most recent sender (used in unconnected mode).">_remoteAddr</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#acc234405e43a22139930c6b2611927c8" title="Length of the valid address data in _remoteAddr (0 if none received yet).">_remoteAddrLen</a></span></li>
</ul>
</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md709"></a>
🔒 Safety</h3>
<ul>
<li>Safe to call multiple times</li>
<li>Never throws</li>
<li>Used internally by <span class="tt"><a class="el" href="#ga1973415ece2f77f191b250b9e9690733" title="Releases all socket resources and throws a SocketException with the given error code.">cleanupAndThrow()</a></span> and <span class="tt"><a class="el" href="#ga6608c56d08ccdb2807bd47cc862af24a" title="Cleans up the datagram socket and rethrows the currently active exception.">cleanupAndRethrow()</a></span> for consistent recovery</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This method is private and should not be exposed to users directly. It is designed for internal lifecycle management and exception-safe cleanup.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1973415ece2f77f191b250b9e9690733" title="Releases all socket resources and throws a SocketException with the given error code.">cleanupAndThrow()</a>, <a class="el" href="#ga6608c56d08ccdb2807bd47cc862af24a" title="Cleans up the datagram socket and rethrows the currently active exception.">cleanupAndRethrow()</a>, <a class="el" href="namespacejsocketpp.html#a12fd46ba498b19d6102220bc100ef931">CloseSocket()</a> </dd></dl>

</div>
</div>
<a id="ga6608c56d08ccdb2807bd47cc862af24a" name="ga6608c56d08ccdb2807bd47cc862af24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6608c56d08ccdb2807bd47cc862af24a">&#9670;&#160;</a></span>cleanupAndRethrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::cleanupAndRethrow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up the datagram socket and rethrows the currently active exception. </p>
<p>This method is intended to be used inside a <span class="tt">catch</span> block when an exception occurs during socket construction or setup. It ensures all internal resources are safely released before rethrowing the original exception, leaving the socket in an uninitialized and safe state.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md715"></a>
⚙️ Behavior</h3>
<p>Internally calls <span class="tt"><a class="el" href="#gaa0727094596347aa858629f6e5c7febf" title="Internal helper that releases socket resources and resets all internal state.">cleanup()</a></span>, which:</p><ul>
<li>Closes the socket if it is open</li>
<li>Sets the socket descriptor to <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></li>
<li>Resets connection state flags:<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a8c77f16fcae1c86b679a0567de055b7d" title="True if the socket is bound to an address.">_isBound</a> = false</span></li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#acc0850711b172f6c6c8bf0649c530ea0" title="True if the socket is connected to a remote host.">_isConnected</a> = false</span></li>
</ul>
</li>
<li>Clears cached local/remote address structures</li>
</ul>
<p>Then rethrows the active exception using <span class="tt">throw;</span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md717"></a>
⚠️ Usage Notes</h3>
<ul>
<li>Must be invoked only from within a valid <span class="tt">catch</span> block</li>
<li>If no exception is currently being handled, calling this method causes undefined behavior</li>
<li>Never accepts an exception object — <span class="tt">throw;</span> preserves full type and context</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md719"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <a class="code hl_function" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b">setNonBlocking</a>(<span class="keyword">true</span>);</div>
<div class="line">    <a class="code hl_function" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721">setSoRecvTimeout</a>(2000);</div>
<div class="line">} <span class="keywordflow">catch</span> (...) {</div>
<div class="line">    <a class="code hl_function" href="#ga6608c56d08ccdb2807bd47cc862af24a">cleanupAndRethrow</a>(); <span class="comment">// Fully resets state and rethrows original exception</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__socketopts_html_ga5ad18e598507d04059bdaff086b01721"><div class="ttname"><a href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721">jsocketpp::SocketOptions::setSoRecvTimeout</a></div><div class="ttdeci">void setSoRecvTimeout(int millis)</div><div class="ttdoc">Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:160</div></div>
<div class="ttc" id="agroup__socketopts_html_ga5f2dffc2949b06b1d945e590bce7f05b"><div class="ttname"><a href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b">jsocketpp::SocketOptions::setNonBlocking</a></div><div class="ttdeci">void setNonBlocking(bool nonBlocking)</div><div class="ttdoc">Enables or disables non-blocking mode on the socket.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:223</div></div>
<div class="ttc" id="agroup__udp_html_ga6608c56d08ccdb2807bd47cc862af24a"><div class="ttname"><a href="#ga6608c56d08ccdb2807bd47cc862af24a">jsocketpp::DatagramSocket::cleanupAndRethrow</a></div><div class="ttdeci">void cleanupAndRethrow()</div><div class="ttdoc">Cleans up the datagram socket and rethrows the currently active exception.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:176</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>or the original active exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa0727094596347aa858629f6e5c7febf" title="Internal helper that releases socket resources and resets all internal state.">cleanup()</a>, <a class="el" href="#ga1973415ece2f77f191b250b9e9690733" title="Releases all socket resources and throws a SocketException with the given error code.">cleanupAndThrow()</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a> </dd></dl>

</div>
</div>
<a id="ga1973415ece2f77f191b250b9e9690733" name="ga1973415ece2f77f191b250b9e9690733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1973415ece2f77f191b250b9e9690733">&#9670;&#160;</a></span>cleanupAndThrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::cleanupAndThrow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>errorCode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases all socket resources and throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with the given error code. </p>
<p>This method performs complete internal cleanup of the datagram socket and then throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>. It is typically invoked when construction, binding, or configuration of the socket fails, ensuring the object is left in a safe, uninitialized state.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md711"></a>
⚙️ Behavior</h3>
<p>Internally delegates to <span class="tt"><a class="el" href="#gaa0727094596347aa858629f6e5c7febf" title="Internal helper that releases socket resources and resets all internal state.">cleanup()</a></span>, which:</p><ul>
<li>Closes the socket if open</li>
<li>Resets the socket descriptor to <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></li>
<li>Resets internal state flags:<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a8c77f16fcae1c86b679a0567de055b7d" title="True if the socket is bound to an address.">_isBound</a> = false</span></li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#acc0850711b172f6c6c8bf0649c530ea0" title="True if the socket is connected to a remote host.">_isConnected</a> = false</span></li>
</ul>
</li>
<li>Clears cached local/remote address structures</li>
</ul>
<p>After cleanup, throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with:</p><ul>
<li>The provided <span class="tt">errorCode</span></li>
<li>A descriptive message from <span class="tt">SocketErrorMessage(errorCode)</span></li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md713"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">::bind</a>(<a class="code hl_function" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794">getSocketFd</a>(), ...) == <a class="code hl_variable" href="namespacejsocketpp.html#adc2dd9860dec2a3c3189e756288d5ba2">SOCKET_ERROR</a>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="#ga1973415ece2f77f191b250b9e9690733">cleanupAndThrow</a>(<a class="code hl_function" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError</a>());</div>
<div class="line">}</div>
<div class="ttc" id="agroup__socketopts_html_gaced4c6dc799564ece9ce4e6766b1d794"><div class="ttname"><a href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794">jsocketpp::SocketOptions::getSocketFd</a></div><div class="ttdeci">SOCKET getSocketFd() const noexcept</div><div class="ttdoc">Retrieves the native socket handle (file descriptor or OS-level handle).</div><div class="ttdef"><b>Definition</b> SocketOptions.hpp:275</div></div>
<div class="ttc" id="agroup__udp_html_ga1973415ece2f77f191b250b9e9690733"><div class="ttname"><a href="#ga1973415ece2f77f191b250b9e9690733">jsocketpp::DatagramSocket::cleanupAndThrow</a></div><div class="ttdeci">void cleanupAndThrow(int errorCode)</div><div class="ttdoc">Releases all socket resources and throws a SocketException with the given error code.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:170</div></div>
<div class="ttc" id="anamespacejsocketpp_html_aac009a479ad7c6c77530e5e270cb25ad"><div class="ttname"><a href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">jsocketpp::GetSocketError</a></div><div class="ttdeci">int GetSocketError()</div><div class="ttdef"><b>Definition</b> common.hpp:246</div></div>
<div class="ttc" id="anamespacejsocketpp_html_adc2dd9860dec2a3c3189e756288d5ba2"><div class="ttname"><a href="namespacejsocketpp.html#adc2dd9860dec2a3c3189e756288d5ba2">jsocketpp::SOCKET_ERROR</a></div><div class="ttdeci">constexpr SOCKET SOCKET_ERROR</div><div class="ttdef"><b>Definition</b> common.hpp:265</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errorCode</td><td>The system or application-level error code to report.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>Always throws after cleanup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa0727094596347aa858629f6e5c7febf" title="Internal helper that releases socket resources and resets all internal state.">cleanup()</a> </dd>
<dd>
<a class="el" href="#ga6608c56d08ccdb2807bd47cc862af24a" title="Cleans up the datagram socket and rethrows the currently active exception.">cleanupAndRethrow()</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a>, <a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage()</a> </dd></dl>

</div>
</div>
<a id="ga9d0a9582b3a2a72bf62f182dbc33c352" name="ga9d0a9582b3a2a72bf62f182dbc33c352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d0a9582b3a2a72bf62f182dbc33c352">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::close </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the datagram socket and releases its underlying system resources. </p>
<p>This method performs a full teardown of the datagram socket, closing the underlying file descriptor/handle and releasing all associated resources. After closure, the socket becomes invalid and cannot be reused.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md691"></a>
⚙️ Core Behavior</h3>
<ul>
<li>Invalidates the socket descriptor (<span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a> = <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>)</li>
<li>Releases system-level socket resources via <span class="tt">::close()</span> or <span class="tt">::closesocket()</span></li>
<li>Resets all internal state flags (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a8c77f16fcae1c86b679a0567de055b7d" title="True if the socket is bound to an address.">_isBound</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#acc0850711b172f6c6c8bf0649c530ea0" title="True if the socket is connected to a remote host.">_isConnected</a></span>)</li>
<li>Clears address resolution data and remote peer information</li>
<li>Makes the socket unsuitable for further I/O operations</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md693"></a>
🔒 Safety</h3>
<ul>
<li>Safe to call multiple times (idempotent)</li>
<li>Thread-safe with respect to other instances</li>
<li>Ensures no resource leaks even after errors</li>
<li>Preserves exception safety guarantees</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md695"></a>
🧪 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> sock;</div>
<div class="line">sock.<a class="code hl_function" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">bind</a>(12345);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... use socket ...</span></div>
<div class="line"> </div>
<div class="line">sock.<a class="code hl_function" href="#ga9d0a9582b3a2a72bf62f182dbc33c352">close</a>(); <span class="comment">// Release all resources</span></div>
<div class="line">assert(sock.<a class="code hl_function" href="#gae91f746fb4cffa0eb8460c816a476d65">isClosed</a>());</div>
<div class="ttc" id="agroup__udp_html_ga9d0a9582b3a2a72bf62f182dbc33c352"><div class="ttname"><a href="#ga9d0a9582b3a2a72bf62f182dbc33c352">jsocketpp::DatagramSocket::close</a></div><div class="ttdeci">void close()</div><div class="ttdoc">Closes the datagram socket and releases its underlying system resources.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:196</div></div>
<div class="ttc" id="agroup__udp_html_gae91f746fb4cffa0eb8460c816a476d65"><div class="ttname"><a href="#gae91f746fb4cffa0eb8460c816a476d65">jsocketpp::DatagramSocket::isClosed</a></div><div class="ttdeci">bool isClosed() const noexcept</div><div class="ttdoc">Checks whether the datagram socket has been closed or is otherwise invalid.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:3988</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the underlying close operation fails unexpectedly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Any pending operations on the socket will be aborted</li>
<li>Subsequent operations will throw <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span></li>
<li>Use <span class="tt"><a class="el" href="#gae91f746fb4cffa0eb8460c816a476d65" title="Checks whether the datagram socket has been closed or is otherwise invalid.">isClosed()</a></span> to check socket state</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae91f746fb4cffa0eb8460c816a476d65" title="Checks whether the datagram socket has been closed or is otherwise invalid.">isClosed()</a> To verify socket state </dd>
<dd>
<a class="el" href="#gab33da807656e2ab920707d60605844f5" title="Checks whether the datagram socket is valid and ready for use.">isValid()</a> Alternative check for usability </dd>
<dd>
<a class="el" href="#gaa0727094596347aa858629f6e5c7febf" title="Internal helper that releases socket resources and resets all internal state.">cleanup()</a> Internal <a class="el" href="#gaa0727094596347aa858629f6e5c7febf" title="Internal helper that releases socket resources and resets all internal state.">cleanup</a> helper </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a id="ga915c790c7cfde485e680ddec2edb2e74" name="ga915c790c7cfde485e680ddec2edb2e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga915c790c7cfde485e680ddec2edb2e74">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::connect </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect this UDP socket to a default peer (set the default destination). </p>
<p>Establishes a default remote endpoint for the datagram socket. After a successful call, send/receive operations that use the connected variants (e.g., <span class="tt">send</span>, <span class="tt">recv</span>) no longer require an explicit destination address. Unlike TCP, UDP "connect" performs <b>no</b> handshake; it simply sets the default peer and may implicitly bind the local endpoint (address/port).</p>
<p>This implementation:</p><ul>
<li>Resolves <code class="param">host</code> + <code class="param">port</code> to a linked list of address candidates (IPv6 and/or IPv4).</li>
<li>Iterates <b>all</b> candidates in order until one succeeds.</li>
<li>If <code class="param">timeoutMillis</code> ≥ 0, temporarily switches the socket to non-blocking mode and uses <span class="tt">select()</span> to wait for writability, respecting a <b>single overall</b> timeout budget across all candidates (not per-candidate).</li>
<li>On success, caches the local endpoint (via <span class="tt">getsockname()</span>), sets <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a8c77f16fcae1c86b679a0567de055b7d" title="True if the socket is bound to an address.">_isBound</a> = true</span> (if it wasn’t already), and marks the socket as connected.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Remote hostname or IP literal (IPv4/IPv6). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Remote UDP port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Connection timeout in milliseconds. If <span class="tt">&lt; 0</span>, the call is blocking. If <span class="tt">0</span>, the function attempts a non-blocking connect and will time out immediately unless completion is instantaneous.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket must be open and not already connected.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success:<ul>
<li>The socket has a default peer set (connected UDP).</li>
<li>The local endpoint cache is populated to reflect any implicit bind.</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#acc0850711b172f6c6c8bf0649c530ea0" title="True if the socket is connected to a remote host.">_isConnected</a> == true</span> and <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a8c77f16fcae1c86b679a0567de055b7d" title="True if the socket is bound to an address.">_isBound</a> == true</span> (if an implicit bind occurred).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If called when already connected.</li>
<li>If name resolution yields no candidates.</li>
<li>If a candidate fails synchronously (and other candidates also fail), or if <span class="tt">select()</span>/<span class="tt">getsockopt(SO_ERROR)</span> reports an error. The exception carries <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt">SocketErrorMessage(GetSocketError())</span>. </li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td><ul>
<li>If the connection does not complete within <code class="param">timeoutMillis</code> across all candidates (including the case <span class="tt">timeoutMillis == 0</span> and the operation cannot complete immediately).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Notes</dt><dd><ul>
<li>The total elapsed time across candidate attempts will not exceed <code class="param">timeoutMillis</code>.</li>
<li>On Windows and POSIX, writability after <span class="tt">select()</span> is not a guarantee of success; this method checks <span class="tt">SO_ERROR</span> to confirm or retrieve the per-candidate failure code.</li>
<li>If you routinely connect with timeouts, consider replacing <span class="tt">select()</span> with a <span class="tt">poll()</span>-based wait to avoid <span class="tt">FD_SETSIZE</span> constraints.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When <code class="param">timeoutMillis</code> ≥ 0 and <span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> &gt;= FD_SETSIZE</span>, <span class="tt">select()</span> cannot be used and this function throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> before attempting the connection.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safety: intended for the socket’s owning thread. Do not call concurrently with <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> or other operations that mutate connection state.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s;</div>
<div class="line">s.open(AF_UNSPEC);                  <span class="comment">// create socket</span></div>
<div class="line">s.<a class="code hl_function" href="#ga915c790c7cfde485e680ddec2edb2e74">connect</a>(<span class="stringliteral">&quot;example.net&quot;</span>, 5353, 2000); <span class="comment">// iterate v6/v4 candidates, 2s overall timeout</span></div>
<div class="line">s.send(data, len);                  <span class="comment">// now uses the default peer</span></div>
<div class="ttc" id="agroup__udp_html_ga915c790c7cfde485e680ddec2edb2e74"><div class="ttname"><a href="#ga915c790c7cfde485e680ddec2edb2e74">jsocketpp::DatagramSocket::connect</a></div><div class="ttdeci">void connect(std::string_view host, Port port, int timeoutMillis)</div><div class="ttdoc">Connect this UDP socket to a default peer (set the default destination).</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:249</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3d08597b24d9c7a3fe43dd291ee85148" name="ga3d08597b24d9c7a3fe43dd291ee85148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d08597b24d9c7a3fe43dd291ee85148">&#9670;&#160;</a></span>DatagramSocket() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::DatagramSocket::DatagramSocket </td>
          <td>(</td>
          <td class="paramtype">const DatagramSocket &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (deleted) for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>. </p>
<p>The copy constructor is explicitly deleted to prevent copying of <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> instances. This class wraps a native socket file descriptor (<span class="tt"><a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a></span>) and manages system-level resources that cannot be safely or meaningfully duplicated.</p>
<p>Copying would result in multiple objects referring to the same underlying socket, which would violate ownership semantics and could lead to:</p><ul>
<li>Double closure of the same socket</li>
<li>Undefined behavior in concurrent scenarios</li>
<li>Silent data corruption if two sockets share internal buffers</li>
</ul>
<p>Instead, use move semantics to transfer ownership safely between instances.</p>
<dl class="section note"><dt>Note</dt><dd>All socket classes in the library are non-copyable by design to preserve RAII guarantees and strict resource control.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> a(12345);</div>
<div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> b = a; <span class="comment">// ❌ Compilation error (copy constructor is deleted)</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab613123c8bf1aca6aec451b1140e2f82" title="Move constructor for DatagramSocket.">DatagramSocket(DatagramSocket&amp;&amp;)</a> noexcept </dd></dl>

</div>
</div>
<a id="gab613123c8bf1aca6aec451b1140e2f82" name="gab613123c8bf1aca6aec451b1140e2f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab613123c8bf1aca6aec451b1140e2f82">&#9670;&#160;</a></span>DatagramSocket() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::DatagramSocket::DatagramSocket </td>
          <td>(</td>
          <td class="paramtype">DatagramSocket &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>. </p>
<p>Transfers ownership of the underlying socket file descriptor and internal state from another <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> instance. After the move, the source object is left in a valid but unspecified state and should not be used.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md663"></a>
What Is Transferred</h3>
<ul>
<li>Native socket handle (<span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a></span>)</li>
<li>Address resolution pointers (<span class="tt">_addrInfoPtr</span>, <span class="tt">_selectedAddrInfo</span>)</li>
<li>Local address metadata</li>
<li>Internal receive buffer</li>
<li><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a> number</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md664"></a>
Rationale</h3>
<ul>
<li>Enables safe transfer of socket ownership</li>
<li>Preserves resource integrity without duplicating system handles</li>
<li>Supports RAII and container use (e.g., <span class="tt">std::vector&lt;<a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>&gt;</span>)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The moved-from object is invalidated and cannot be reused.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> a(12345);</div>
<div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> b = std::move(a); <span class="comment">// ✅ b now owns the socket</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga38397874bcb62f889cb6fefa20b45ba6" title="Move assignment operator for DatagramSocket.">operator=(DatagramSocket&amp;&amp;)</a> noexcept </dd></dl>

</div>
</div>
<a id="ga4b4c631816f82eea0b6048a16682079e" name="ga4b4c631816f82eea0b6048a16682079e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b4c631816f82eea0b6048a16682079e">&#9670;&#160;</a></span>DatagramSocket() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DatagramSocket::DatagramSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>localPort</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reuseAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dualStack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>autoBind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>autoConnect</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>remoteAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>remotePort</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>connectTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a UDP socket, optionally binds to a local address, and optionally connects to a remote peer. </p>
<p>This constructor supports both server-style and client-style UDP sockets:</p>
<ul>
<li><b>Server mode</b>: Binds to a local address and receives datagrams from any source</li>
<li><b>Client mode</b>: Optionally connects to a remote peer, enabling <span class="tt">send()</span>/<span class="tt">recv()</span> and automatic ICMP error handling</li>
</ul>
<p>The socket supports:</p><ul>
<li>IPv4 and IPv6 (with optional dual-stack fallback)</li>
<li>Local binding (<span class="tt"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a></span>), optionally done during construction</li>
<li>Connection to a remote host/port using <span class="tt">::connect()</span> semantics</li>
<li>OS-level socket configuration (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>, timeouts, etc.)</li>
<li>Optional non-blocking mode</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md657"></a>
Usage Modes</h3>
<ul>
<li><p class="startli"><b>Bound UDP Server</b> Useful for listening on a specific port/interface for datagrams from any peer.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s(53, <span class="stringliteral">&quot;0.0.0.0&quot;</span>, ..., <span class="keyword">true</span>, <span class="keyword">false</span>); <span class="comment">// bind only</span></div>
</div><!-- fragment --></li>
<li><p class="startli"><b>Connected UDP Client</b> Binds (optional) and then connects to a fixed remote peer. Enables <span class="tt"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write()</a></span> / <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read()</a></span>, ICMP error propagation, and performance improvements.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s(0, <span class="stringliteral">&quot;&quot;</span>, ..., <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="stringliteral">&quot;1.2.3.4&quot;</span>, 9000, 3000); <span class="comment">// bind and connect with timeout</span></div>
</div><!-- fragment --></li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md659"></a>
Configuration Parameters</h3>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localPort</td><td>The local port to bind from. Use <span class="tt">0</span> for ephemeral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localAddress</td><td>The local IP to bind from (e.g., <span class="tt">"192.168.1.100"</span> or <span class="tt">"::"</span>). Empty for wildcard. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional socket receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional socket send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Optional internal buffer size used by high-level read methods </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reuseAddress</td><td>If <span class="tt">true</span>, enables <span class="tt">SO_REUSEADDR</span> to allow rebinding the port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Timeout for receive operations in milliseconds (<span class="tt">-1</span> disables) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Timeout for send operations in milliseconds (<span class="tt">-1</span> disables) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>If <span class="tt">true</span>, sets the socket to non-blocking mode immediately </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dualStack</td><td>If <span class="tt">true</span>, enables IPv6 sockets to accept IPv4-mapped addresses </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoBind</td><td>If <span class="tt">true</span>, performs a <span class="tt"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a></span> using <span class="tt">localAddress</span> and <span class="tt">localPort</span> after construction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoConnect</td><td>If <span class="tt">true</span>, immediately connects to the remote peer using <span class="tt">remoteAddress</span> and <span class="tt">remotePort</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remoteAddress</td><td>The remote host/IP to connect to (used only if <span class="tt">autoConnect == true</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remotePort</td><td>The remote UDP port to connect to (used only if <span class="tt">autoConnect == true</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectTimeoutMillis</td><td>Timeout (in ms) for the connection attempt when <span class="tt">autoConnect == true</span>:<ul>
<li><span class="tt">&lt; 0</span> performs a traditional blocking <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span></li>
<li><span class="tt">&gt;= 0</span> uses a timeout-aware non-blocking connect</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md661"></a>
Throws</h3>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If any step of socket resolution, creation, binding, configuration, or connection fails </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If the <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span> call exceeds the specified <span class="tt">connectTimeoutMillis</span> timeout</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a>, <a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a>, <a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a>, <a class="el" href="group__socketopts.html#ga7107a9da459b00bf39ec2fe4d3e83396" title="Sets the socket send timeout (SO_SNDTIMEO) in milliseconds.">setSoSendTimeout()</a>, <a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a>, <a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write()</a>, <a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo()</a> </dd></dl>

</div>
</div>
<a id="ga243b470108bb0e02602780ee6c2ed8a7" name="ga243b470108bb0e02602780ee6c2ed8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga243b470108bb0e02602780ee6c2ed8a7">&#9670;&#160;</a></span>discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the next UDP datagram without copying it out. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Consumes exactly one datagram from the socket and discards its bytes. This method ignores the datagram size and never throws due to truncation. Timeouts and OS-level receive errors still apply. On unconnected sockets, when <code class="param">opts.updateLastRemote</code> is true, the internally tracked “last remote” endpoint is updated to the sender of the discarded datagram.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options controlling sender bookkeeping and receive flags. The <code>mode</code> field is ignored (a single receive is always performed). Truncation reporting is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open or an OS-level receive error occurs (message via <code>SocketErrorMessage</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a configured receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Exactly one datagram has been removed from the socket’s receive queue. For unconnected sockets, when <code class="param">opts.updateLastRemote</code> is true, the internal “last remote” reflects that sender.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="comment">// Drop the next datagram, whatever its size</span></div>
<div class="line">sock.discard();</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaaa04156c3da5af5cf724d46764a04c84" name="gaaa04156c3da5af5cf724d46764a04c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa04156c3da5af5cf724d46764a04c84">&#9670;&#160;</a></span>discardExact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::discardExact </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the next UDP datagram only if its payload size is exactly <code class="param">n</code> bytes. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Enforces <b>exact-length</b> semantics while draining the datagram:</p><ul>
<li>If a reliable size probe is available, the method verifies the next datagram size equals <code class="param">n</code> and throws <b>before</b> reading when it does not, so the datagram remains queued.</li>
<li>If size cannot be probed, it performs exactly one receive of up to <code class="param">n</code> bytes. If the datagram is larger than <code class="param">n</code>, the kernel truncates it; this method then throws. If the datagram is smaller than <code class="param">n</code>, it also throws. In other words, the datagram must be exactly <code class="param">n</code> bytes or the call fails.</li>
</ul>
<p>The discard operation minimizes copying: when the size is known to be <code class="param">n</code>, the method reads with a tiny scratch buffer to consume the datagram (the kernel drops the remainder).</p>
<p>On unconnected sockets, when <code class="param">opts.updateLastRemote</code> is true, the internally tracked “last remote” endpoint is updated to the sender of the discarded datagram.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Required datagram payload size (&gt; 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options controlling sender bookkeeping and receive flags. Truncation policy in <code class="param">opts</code> is ignored; this method enforces its own exact-length checks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; <code class="param">n</code> == 0; OS-level receive errors occur (message via <code>SocketErrorMessage</code>); or the next datagram’s size is not exactly <code class="param">n</code> bytes. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a configured receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. <code class="param">n</code> &gt; 0. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Exactly one datagram has been removed from the socket’s receive queue if and only if its size was <code class="param">n</code>. For unconnected sockets, when <code class="param">opts.updateLastRemote</code> is true, the internal “last remote” reflects that sender.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="comment">// Drop the next datagram only if it is exactly 512 bytes</span></div>
<div class="line">sock.discardExact(512);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga02b08c333a2f109a3b19ec7b3c0cecf9" name="ga02b08c333a2f109a3b19ec7b3c0cecf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02b08c333a2f109a3b19ec7b3c0cecf9">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::disconnect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect this UDP socket from its current default peer. </p>
<p>Dissolves the association set by a prior <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span> without closing the socket. Internally, this issues <span class="tt">::connect(fd, { .sa_family = AF_UNSPEC }, sizeof(sockaddr))</span>, which is the standard UDP “disconnect” idiom on POSIX and Winsock. The socket remains open and (if previously bound) stays bound to its local address/port; only the default remote peer is cleared.</p>
<p>This implementation:</p><ul>
<li>Treats a not-currently-connected socket as a no-op.</li>
<li>Throws if the socket handle is invalid or if the kernel <span class="tt">connect(AF_UNSPEC)</span> call fails.</li>
<li><b>Preserves</b> the cached local endpoint and <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a8c77f16fcae1c86b679a0567de055b7d" title="True if the socket is bound to an address.">_isBound</a></span> state.</li>
<li><b>Clears</b> any cached remote endpoint (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#ac9e89ef197694e0464a7c8e076bd6e04">_haveRemoteAddr</a> = false</span>, zeroes <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#ac53f064c3e7249b78d895121d3ead632" title="Storage for the address of the most recent sender (used in unconnected mode).">_remoteAddr</a></span>, and <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#acc234405e43a22139930c6b2611927c8" title="Length of the valid address data in _remoteAddr (0 if none received yet).">_remoteAddrLen</a> = 0</span>).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The socket must be open. If <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#acc0850711b172f6c6c8bf0649c530ea0" title="True if the socket is connected to a remote host.">_isConnected</a> == false</span>, the call is a no-op.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#acc0850711b172f6c6c8bf0649c530ea0" title="True if the socket is connected to a remote host.">_isConnected</a> == false</span>. Local bind (if any) and its cache remain intact. Remote-endpoint cache is cleared.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open, or if the underlying <span class="tt">connect(AF_UNSPEC)</span> fails. The exception carries <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt">SocketErrorMessage(GetSocketError())</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safety: intended for the socket’s owning thread. Do not call concurrently with <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> or other operations that mutate connection state. </dd>
<dd>
POSIX: the call may be retried internally if interrupted by a signal (<span class="tt">EINTR</span>).</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s;</div>
<div class="line">s.<a class="code hl_function" href="#ga915c790c7cfde485e680ddec2edb2e74">connect</a>(<span class="stringliteral">&quot;203.0.113.5&quot;</span>, 9999, 1000);</div>
<div class="line"><span class="comment">// ... use connected send/recv ...</span></div>
<div class="line">s.<a class="code hl_function" href="#ga02b08c333a2f109a3b19ec7b3c0cecf9">disconnect</a>();  <span class="comment">// clears default peer; socket remains open and bound</span></div>
<div class="ttc" id="agroup__udp_html_ga02b08c333a2f109a3b19ec7b3c0cecf9"><div class="ttname"><a href="#ga02b08c333a2f109a3b19ec7b3c0cecf9">jsocketpp::DatagramSocket::disconnect</a></div><div class="ttdeci">void disconnect()</div><div class="ttdoc">Disconnect this UDP socket from its current default peer.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:419</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga6de9a0542180215e2f2520148c71f1b4" name="ga6de9a0542180215e2f2520148c71f1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6de9a0542180215e2f2520148c71f1b4">&#9670;&#160;</a></span>encodeLengthPrefixBE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::byte, sizeof(T)&gt; jsocketpp::DatagramSocket::encodeLengthPrefixBE </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode a length value into a fixed-size, big-endian (network-order) byte array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Unsigned integral type used for the length prefix. Typical choices are <span class="tt">std::uint8_t</span>, <span class="tt">std::uint16_t</span>, <span class="tt">std::uint32_t</span>, or <span class="tt">std::uint64_t</span>. A compile-time check enforces that <span class="tt">T</span> is an unsigned integral.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts <code class="param">n</code> into its big-endian (network byte order) representation using exactly <span class="tt">sizeof(T)</span> bytes and returns the result as <span class="tt">std::array&lt;std::byte, sizeof(T)&gt;</span>. The function is O(<span class="tt">sizeof(T)</span>) and allocation-free.</p>
<ul>
<li>When <span class="tt">sizeof(T) == 1</span>, the result is a single byte: <span class="tt">n &amp; 0xFF</span>.</li>
<li>For larger <span class="tt">T</span>, the most significant byte appears first in the array.</li>
<li>Only the low <span class="tt">sizeof(T) * 8</span> bits of <code class="param">n</code> are representable; values that do not fit are rejected with a logical exception (see Throws).</li>
</ul>
<p>This helper is intended for building length-prefixed UDP frames with a prefix followed by payload bytes, where the prefix must be in network byte order for interoperability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The length value to encode. Must satisfy <span class="tt">n &lt;= std::numeric_limits&lt;T&gt;::max()</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt">std::array&lt;std::byte, sizeof(T)&gt;</span> containing <code class="param">n</code> encoded in big-endian order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b> if <code class="param">n</code> exceeds <span class="tt">std::numeric_limits&lt;T&gt;::max()</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>writePrefixed&lt;T&gt;(std::string_view), writePrefixed&lt;T&gt;(std::span&lt;const std::byte&gt;), writePrefixedTo&lt;T&gt;(std::string_view, Port, std::string_view), writePrefixedTo&lt;T&gt;(std::string_view, Port, std::span&lt;const std::byte&gt;)</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: encode a 16-bit length (42) as network-order bytes { 0x00, 0x2A }.</span></div>
<div class="line"><span class="keyword">auto</span> be = <a class="code hl_function" href="#ga6de9a0542180215e2f2520148c71f1b4">DatagramSocket::encodeLengthPrefixBE&lt;std::uint16_t&gt;</a>(42);</div>
<div class="line">assert(<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(be[0]) == 0x00);</div>
<div class="line">assert(<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(be[1]) == 0x2A);</div>
<div class="ttc" id="agroup__udp_html_ga6de9a0542180215e2f2520148c71f1b4"><div class="ttname"><a href="#ga6de9a0542180215e2f2520148c71f1b4">jsocketpp::DatagramSocket::encodeLengthPrefixBE</a></div><div class="ttdeci">static std::array&lt; std::byte, sizeof(T)&gt; encodeLengthPrefixBE(std::size_t n)</div><div class="ttdoc">Encode a length value into a fixed-size, big-endian (network-order) byte array.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:4592</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga71ea4f3e14d566fe91a188f4cc4a5f64" name="ga71ea4f3e14d566fe91a188f4cc4a5f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71ea4f3e14d566fe91a188f4cc4a5f64">&#9670;&#160;</a></span>enforceSendCapConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::enforceSendCapConnected </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>payloadSize</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enforce UDP payload size limits for <b>connected</b> datagram sends. </p>
<p>Validates that a single datagram of <code class="param">payloadSize</code> bytes can be sent to the <b>currently connected</b> peer without exceeding protocol-level maxima.</p>
<p>The check is conservative by default:</p><ul>
<li>Always allows up to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span> (65,507 bytes), which is safe on both IPv4 and IPv6.</li>
<li>If the connected peer is IPv6 (<span class="tt">AF_INET6</span>), allows the IPv6 theoretical maximum (<span class="tt"><a class="el" href="group__core.html#ga041bcd9d09d1d8e134c7b8af72523d66" title="Theoretical maximum UDP payload size (in bytes) over IPv6.">MaxUdpPayloadIPv6</a></span> = 65,527) while continuing to reject anything larger.</li>
</ul>
<p>If the socket is connected to IPv4 (<span class="tt">AF_INET</span>) and <code class="param">payloadSize</code> exceeds the IPv4 limit (<span class="tt"><a class="el" href="group__core.html#ga63ed4637719268844616341e0f8908cb" title="Maximum UDP payload size (in bytes) over IPv4.">MaxUdpPayloadIPv4</a></span> = 65,507), an exception is thrown <b>before</b> calling <span class="tt">send()</span>, providing a precise, user-friendly error message.</p>
<p>The remote address family is determined via: 1) cached last-peer address when available, otherwise 2) a <span class="tt">getpeername()</span> query on the connected socket.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md721"></a>
Rationale</h3>
<p>Proactive validation yields deterministic, actionable errors (instead of a vague <span class="tt">EMSGSIZE</span> from the kernel) and avoids futile syscalls.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md723"></a>
Example (internal use)</h3>
<div class="fragment"><div class="line"><span class="comment">// Inside write(std::string_view):</span></div>
<div class="line"><a class="code hl_function" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64">enforceSendCapConnected</a>(value.size());</div>
<div class="line"><a class="code hl_function" href="group__internal.html#ga8826c90e1bb9e0023b75940ff4cd72f8">internal::sendExact</a>(<a class="code hl_function" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794">getSocketFd</a>(), value.data(), value.size());</div>
<div class="ttc" id="agroup__internal_html_ga8826c90e1bb9e0023b75940ff4cd72f8"><div class="ttname"><a href="group__internal.html#ga8826c90e1bb9e0023b75940ff4cd72f8">jsocketpp::internal::sendExact</a></div><div class="ttdeci">void sendExact(SOCKET fd, const void *data, std::size_t size)</div><div class="ttdoc">Sends an entire datagram to a connected peer using send().</div><div class="ttdef"><b>Definition</b> common.cpp:477</div></div>
<div class="ttc" id="agroup__udp_html_ga71ea4f3e14d566fe91a188f4cc4a5f64"><div class="ttname"><a href="#ga71ea4f3e14d566fe91a188f4cc4a5f64">jsocketpp::DatagramSocket::enforceSendCapConnected</a></div><div class="ttdeci">void enforceSendCapConnected(const std::size_t payloadSize) const</div><div class="ttdoc">Enforce UDP payload size limits for connected datagram sends.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:4407</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">payloadSize</td><td>Number of bytes intended for a single datagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If the socket is not open or not connected (logical error).</li>
<li>If <span class="tt">getpeername()</span> fails while determining the connected peer family (OS error; uses <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span>/<span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage()</a></span>).</li>
<li>If <code class="param">payloadSize</code> exceeds the permitted maximum for the connected peer’s family.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method does <b>not</b> enforce path-MTU/non-fragmenting policies; it only enforces absolute protocol maxima to prevent guaranteed failures.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a>, <a class="el" href="group__core.html#ga63ed4637719268844616341e0f8908cb" title="Maximum UDP payload size (in bytes) over IPv4.">MaxUdpPayloadIPv4</a>, <a class="el" href="group__core.html#ga041bcd9d09d1d8e134c7b8af72523d66" title="Theoretical maximum UDP payload size (in bytes) over IPv6.">MaxUdpPayloadIPv6</a>, <a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write()</a>, <a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo()</a> </dd></dl>

</div>
</div>
<a id="gac19051ec24961addb059f01f1e7f28c7" name="gac19051ec24961addb059f01f1e7f28c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac19051ec24961addb059f01f1e7f28c7">&#9670;&#160;</a></span>getLastPeerSockAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::pair&lt; sockaddr_storage, socklen_t &gt; &gt; jsocketpp::DatagramSocket::getLastPeerSockAddr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the raw socket address of the last known remote peer. </p>
<p>This method exposes the internal low-level <span class="tt">sockaddr_storage</span> structure representing the last known remote peer that this socket communicated with. It is useful in advanced use cases where direct access to address structures is required — for example:</p>
<ul>
<li>Custom routing or connection tracking</li>
<li>Creating new sockets targeting the same peer</li>
<li>Implementing security checks or access controls</li>
<li>Avoiding repeated DNS resolution</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md702"></a>
🔁 Behavior Based on Mode</h3>
<ul>
<li><b>Connected <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>:</b><ul>
<li>Reflects the peer specified via <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span>.</li>
<li>Remains constant until the socket is closed or reset.</li>
</ul>
</li>
<li><b>Unconnected <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>:</b><ul>
<li>Reflects the peer involved in the most recent:<ul>
<li><span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read()</a></span></li>
<li><span class="tt">recvFrom()</span></li>
<li><span class="tt"><a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo()</a></span></li>
<li><span class="tt">write(DatagramPacket)</span></li>
</ul>
</li>
<li>If no such operation has occurred, the result is empty.</li>
</ul>
</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md704"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> remote = sock.getLastPeerSockAddr();</div>
<div class="line"><span class="keywordflow">if</span> (remote) {</div>
<div class="line">    <span class="keyword">const</span> sockaddr* sa = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>sockaddr*<span class="keyword">&gt;</span>(&amp;remote-&gt;first);</div>
<div class="line">    <span class="comment">// Now you can use sendto(), bind(), connect(), etc.</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><span class="tt">std::optional&lt;std::pair&lt;sockaddr_storage, socklen_t&gt;&gt;</span>:<ul>
<li><span class="tt">.first</span> contains the raw peer address</li>
<li><span class="tt">.second</span> is the valid length of the address</li>
</ul>
</li>
<li>Returns <span class="tt">std::nullopt</span> if the socket has not communicated with any peer.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level method. Use <span class="tt"><a class="el" href="#ga3afd5b0d48ee9f92759c6f2d4ea9d8f0" title="Return the remote peer IP address for this socket.">getRemoteIp()</a></span> or <span class="tt"><a class="el" href="#gaa31790315a4bb8d20cd924157107a166" title="Return the remote endpoint as a single &quot;ip:port&quot; string.">getRemoteSocketAddress()</a></span> for string-formatted access. </dd>
<dd>
The returned structure is a <b>copy</b>; modifying it has no effect on socket state.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3afd5b0d48ee9f92759c6f2d4ea9d8f0" title="Return the remote peer IP address for this socket.">getRemoteIp()</a>, <a class="el" href="#ga6d1dbfd5b854e120b352a27b541e5841" title="Return the remote peer UDP port for this socket.">getRemotePort()</a>, <a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo()</a>, <a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read()</a>, <a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a>, <a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a> </dd></dl>

</div>
</div>
<a id="gab6486855380c97e18428a670f48f3efa" name="gab6486855380c97e18428a670f48f3efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6486855380c97e18428a670f48f3efa">&#9670;&#160;</a></span>getLocalIp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DatagramSocket::getLocalIp </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>convertIPv4Mapped</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the local interface IP address for this UDP socket. </p>
<p>Returns the textual IP address (IPv4 or IPv6) currently bound to this socket. If a cached local endpoint is available, it is used without a syscall. Otherwise, this method performs a single <span class="tt">getsockname()</span> and, on success, updates the internal cache (only if the kernel reports a non-zero port, i.e., the socket is actually bound). This method is non-const because it may refresh and persist the cached local endpoint.</p>
<p>When <code class="param">convertIPv4Mapped</code> is <span class="tt">true</span> and the underlying address is an IPv6 IPv4-mapped address (<span class="tt">::ffff:a.b.c.d</span>), the returned string is converted to an IPv4 literal (<span class="tt">a.b.c.d</span>). For IPv6 link-local addresses, the scope ID may be included if available (e.g., <span class="tt">fe80::1eth0</span>), depending on platform conventions and the socket's bound interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convertIPv4Mapped</td><td>If <span class="tt">true</span>, convert IPv4-mapped IPv6 addresses to IPv4 text form; if <span class="tt">false</span>, return the canonical address text as reported by the OS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The local IP address in presentation form.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">isOpen() == true</span>.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If the socket is bound to a non-zero port, the internal local-endpoint cache is updated and marked valid.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If the socket is not open.</li>
<li>If <span class="tt">getsockname()</span> fails; the exception carries <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt">SocketErrorMessage(GetSocketError())</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1) on a warm cache; otherwise one <span class="tt">getsockname()</span> call. </dd>
<dd>
Thread-safety: intended for the socket's owning thread. Do not call concurrently with <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> or other operations that tear down the descriptor.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s;</div>
<div class="line">s.<a class="code hl_function" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">bind</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 0);                 <span class="comment">// OS assigns an address/port</span></div>
<div class="line"><span class="keyword">auto</span> ip = s.<a class="code hl_function" href="#gab6486855380c97e18428a670f48f3efa">getLocalIp</a>(<span class="keyword">true</span>);         <span class="comment">// e.g., &quot;192.0.2.10&quot;</span></div>
<div class="ttc" id="agroup__udp_html_gab6486855380c97e18428a670f48f3efa"><div class="ttname"><a href="#gab6486855380c97e18428a670f48f3efa">jsocketpp::DatagramSocket::getLocalIp</a></div><div class="ttdeci">std::string getLocalIp(bool convertIPv4Mapped)</div><div class="ttdoc">Return the local interface IP address for this UDP socket.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:1651</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga8b036d60faeaf712b6b477dc166061b8" name="ga8b036d60faeaf712b6b477dc166061b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b036d60faeaf712b6b477dc166061b8">&#9670;&#160;</a></span>getLocalPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> DatagramSocket::getLocalPort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the local UDP port this socket is bound to. </p>
<p>Returns the numeric port currently bound to this socket. If a cached local endpoint is available, it is used without a syscall. Otherwise, this method performs a single <span class="tt">getsockname()</span> and, on success, updates the internal cache <b>only if</b> the kernel reports a non-zero port (i.e., the socket is actually bound). This method is non-const because it may refresh and persist the cached local endpoint.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a> The local UDP port number.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">isOpen() == true</span>.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If the socket is bound to a non-zero port, the internal local-endpoint cache is updated and marked valid.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If the socket is not open.</li>
<li>If <span class="tt">getsockname()</span> fails; the exception carries <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt">SocketErrorMessage(GetSocketError())</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1) with a warm cache; otherwise one <span class="tt">getsockname()</span> call. </dd>
<dd>
Thread-safety: intended for the socket’s owning thread. Do not call concurrently with <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> or other teardown operations.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s;</div>
<div class="line">s.<a class="code hl_function" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">bind</a>(<span class="stringliteral">&quot;::&quot;</span>, 0);                   <span class="comment">// OS selects an ephemeral port</span></div>
<div class="line"><a class="code hl_typedef" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> p = s.<a class="code hl_function" href="#ga8b036d60faeaf712b6b477dc166061b8">getLocalPort</a>();         <span class="comment">// e.g., 54321</span></div>
<div class="ttc" id="agroup__core_html_ga1a7be273748ae3d91bc5ebe6499788a7"><div class="ttname"><a href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">jsocketpp::Port</a></div><div class="ttdeci">std::uint16_t Port</div><div class="ttdoc">Type alias representing a TCP or UDP port number (1–65535).</div><div class="ttdef"><b>Definition</b> common.hpp:392</div></div>
<div class="ttc" id="agroup__udp_html_ga8b036d60faeaf712b6b477dc166061b8"><div class="ttname"><a href="#ga8b036d60faeaf712b6b477dc166061b8">jsocketpp::DatagramSocket::getLocalPort</a></div><div class="ttdeci">Port getLocalPort()</div><div class="ttdoc">Return the local UDP port this socket is bound to.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:1681</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga2b19edc594f75938a6028094744ec107" name="ga2b19edc594f75938a6028094744ec107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b19edc594f75938a6028094744ec107">&#9670;&#160;</a></span>getLocalSocketAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DatagramSocket::getLocalSocketAddress </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>convertIPv4Mapped</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the local endpoint as a single "ip:port" string. </p>
<p>Builds a presentation string for the socket’s current local endpoint by combining the local IP and port. If a cached local endpoint is available, it is used without a syscall. Otherwise, this method performs a single <span class="tt">getsockname()</span> and, on success, updates the internal cache <b>only if</b> the kernel reports a non-zero port (i.e., the socket is actually bound). This method is non-const because it may refresh and persist the cached local endpoint. For IPv6 addresses, the IP may be bracketed (e.g., <span class="tt">[2001:db8::1]:54321</span>) depending on the formatting used by the underlying helpers.</p>
<p>When <code class="param">convertIPv4Mapped</code> is <span class="tt">true</span> and the underlying address is an IPv6 IPv4-mapped address (<span class="tt">::ffff:a.b.c.d</span>), the IP portion is converted to an IPv4 literal (<span class="tt">a.b.c.d</span>) before concatenation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convertIPv4Mapped</td><td>If <span class="tt">true</span>, convert IPv4-mapped IPv6 addresses to IPv4 text form in the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The local endpoint string, e.g., <span class="tt">"192.0.2.10:54321"</span> or <span class="tt">"[2001:db8::1]:54321"</span>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">isOpen() == true</span>.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If the socket is bound to a non-zero port, the internal local-endpoint cache is updated and marked valid.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If the socket is not open.</li>
<li>If <span class="tt">getsockname()</span> fails; the exception carries <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt">SocketErrorMessage(GetSocketError())</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1) on a warm cache; otherwise one <span class="tt">getsockname()</span> call. </dd>
<dd>
Thread-safety: intended for the socket’s owning thread. Do not call concurrently with <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> or other teardown operations.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s;</div>
<div class="line">s.<a class="code hl_function" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">bind</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 0);                         <span class="comment">// OS assigns an address/port</span></div>
<div class="line"><span class="keyword">auto</span> ep = s.<a class="code hl_function" href="#ga2b19edc594f75938a6028094744ec107">getLocalSocketAddress</a>(<span class="keyword">true</span>);      <span class="comment">// e.g., &quot;192.0.2.10:54321&quot;</span></div>
<div class="ttc" id="agroup__udp_html_ga2b19edc594f75938a6028094744ec107"><div class="ttname"><a href="#ga2b19edc594f75938a6028094744ec107">jsocketpp::DatagramSocket::getLocalSocketAddress</a></div><div class="ttdeci">std::string getLocalSocketAddress(bool convertIPv4Mapped)</div><div class="ttdoc">Return the local endpoint as a single &quot;ip:port&quot; string.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:1708</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gabd73eb7df3c7871b1637ad03cc06b64c" name="gabd73eb7df3c7871b1637ad03cc06b64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd73eb7df3c7871b1637ad03cc06b64c">&#9670;&#160;</a></span>getMTU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int &gt; DatagramSocket::getMTU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the Maximum Transmission Unit (MTU) of the local interface associated with the socket. </p>
<p>This method attempts to query the MTU of the network interface to which the socket is currently bound. It supports both Windows and POSIX platforms using appropriate system APIs and returns the result as an optional integer.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md677"></a>
🔍 What is the MTU?</h3>
<p>The MTU is the largest size (in bytes) of a datagram that can be sent over a network interface without fragmentation. For example, Ethernet IPv4 commonly uses an MTU of 1500 bytes, while the payload limit for UDP is typically 1472 bytes after IP/UDP headers.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md679"></a>
⚙️ Platform Behavior</h3>
<ul>
<li><b>Windows:</b><ul>
<li>Uses <span class="tt">GetAdaptersAddresses()</span> to enumerate system interfaces.</li>
<li>Uses <span class="tt">getsockname()</span> to determine the bound local IP.</li>
<li>Compares adapter unicast IPs to the bound address using normalized logic that handles IPv4 and IPv4-mapped IPv6.</li>
<li>Returns the MTU for the matched adapter.</li>
</ul>
</li>
<li><b>POSIX (Linux, macOS, etc.):</b><ul>
<li>Uses <span class="tt">getsockname()</span> to retrieve the bound IP.</li>
<li>Uses <span class="tt">getifaddrs()</span> to map the IP to a named interface.</li>
<li>Uses <span class="tt">ioctl(SIOCGIFMTU)</span> to retrieve the MTU for the interface.</li>
</ul>
</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md681"></a>
✅ Use Cases</h3>
<ul>
<li>Enforce maximum UDP payload size to avoid fragmentation</li>
<li>Tune protocol chunk sizes dynamically based on interface limits</li>
<li>Avoid silent datagram drops on MTU-exceeding payloads</li>
</ul>
<hr  />
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><span class="tt">std::optional&lt;int&gt;</span> containing the MTU value if successfully determined.</li>
<li><span class="tt">std::nullopt</span> if:<ul>
<li>The socket is not bound</li>
<li>The local interface cannot be resolved</li>
<li>The OS query fails</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If a low-level socket operation (e.g., <span class="tt">getsockname()</span>) fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method returns the MTU of the <b>local sending interface</b>, not of any remote peer. </dd>
<dd>
On some platforms, this requires the socket to be explicitly bound or connected.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write()</a>, <a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a>, <a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a>, <a class="el" href="#ga2b19edc594f75938a6028094744ec107" title="Return the local endpoint as a single &quot;ip:port&quot; string.">getLocalSocketAddress()</a>, getBoundLocalIp(), ipAddressesEqual() </dd></dl>

</div>
</div>
<a id="gaa47a2a344af40c080a860d5ee0883fd0" name="gaa47a2a344af40c080a860d5ee0883fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa47a2a344af40c080a860d5ee0883fd0">&#9670;&#160;</a></span>getMulticastInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string jsocketpp::MulticastSocket::getMulticastInterface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently selected egress interface for multicast transmissions. </p>
<p>Returns the <b>human-friendly identifier</b> that this object currently holds as the default <b>outgoing multicast interface</b>, as last set via <a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface(const std::string&amp;)</a>. This is a cached value intended for diagnostics and UI; it does not perform a fresh system query.</p>
<p>Possible return forms (depending on how the interface was selected):</p><ul>
<li><b>IPv4 egress:</b> the interface’s IPv4 <b>literal address</b> (e.g., <span class="tt">"192.168.1.5"</span>).</li>
<li><b>IPv6 egress:</b> a <b>numeric interface index</b> as a decimal string (e.g., <span class="tt">"12"</span>), or on POSIX the <b>interface name</b> originally provided (e.g., <span class="tt">"eth0"</span>).</li>
<li><b>Empty string (<span class="tt">""</span>):</b> no explicit egress configured — the system defaults are in effect (IPv4: <span class="tt">INADDR_ANY</span>; IPv6: index <span class="tt">0</span>).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The current multicast egress selector (IPv4 address, IPv6 name/index as a string), or an empty string if the system default is in use.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None. This is a read-only accessor.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state is unchanged.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This method returns the value <b>cached by this object</b> when <a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface(const std::string&amp;)</a> last succeeded. It does <b>not</b> re-read kernel state. If code outside this class (e.g., direct calls to <a class="el" href="group__socketopts.html#ga0303c931f324a501e2502df58b8a9232">setMulticastInterfaceIPv4(in_addr)</a> or <a class="el" href="group__socketopts.html#gad8e171cfa4daf58cde0f27d26794e35c">setMulticastInterfaceIPv6(unsigned int)</a>) changes the egress after that, this cached string may no longer reflect the OS setting.</li>
<li>The return format mirrors the input you supplied: IPv4 address for IPv4 egress, decimal index (or POSIX name) for IPv6 egress, or <span class="tt">""</span> for default routing.</li>
<li>This accessor is about <b>multicast egress selection only</b>; it does not imply any group membership. Use join/leave APIs to manage membership.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface(const std::string&amp;)</a> — set the egress interface via a user-friendly identifier.</li>
<li><a class="el" href="group__socketopts.html#ga0303c931f324a501e2502df58b8a9232">setMulticastInterfaceIPv4(in_addr)</a> / <a class="el" href="group__socketopts.html#gad8e171cfa4daf58cde0f27d26794e35c">setMulticastInterfaceIPv6(unsigned int)</a> — low-level per-family setters.</li>
<li><a class="el" href="group__socketopts.html#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> / <a class="el" href="group__socketopts.html#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL()</a> — control/query multicast scope.</li>
<li><a class="el" href="group__socketopts.html#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> / <a class="el" href="group__socketopts.html#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> — control/query local delivery of this socket’s own multicast.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga996b99882efa863b01e0fff4a9782a82">MulticastSocket</a> sock;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Default (no explicit egress)</span></div>
<div class="line">assert(sock.<a class="code hl_function" href="#gaa47a2a344af40c080a860d5ee0883fd0">getMulticastInterface</a>().empty());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Choose IPv4 egress by address</span></div>
<div class="line">sock.<a class="code hl_function" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;192.0.2.10&quot;</span>);</div>
<div class="line">assert(sock.<a class="code hl_function" href="#gaa47a2a344af40c080a860d5ee0883fd0">getMulticastInterface</a>() == <span class="stringliteral">&quot;192.0.2.10&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// POSIX: choose IPv6 egress by name (or use a numeric index string on any platform)</span></div>
<div class="line">sock.<a class="code hl_function" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;eth0&quot;</span>);          <span class="comment">// POSIX name</span></div>
<div class="line"><span class="comment">// or: sock.setMulticastInterface(&quot;12&quot;);     // numeric index string</span></div>
<div class="line"><span class="keyword">auto</span> current = sock.<a class="code hl_function" href="#gaa47a2a344af40c080a860d5ee0883fd0">getMulticastInterface</a>(); <span class="comment">// &quot;eth0&quot; or &quot;12&quot;</span></div>
<div class="ttc" id="agroup__udp_html_ga996b99882efa863b01e0fff4a9782a82"><div class="ttname"><a href="#ga996b99882efa863b01e0fff4a9782a82">jsocketpp::MulticastSocket::MulticastSocket</a></div><div class="ttdeci">MulticastSocket(Port localPort, std::string_view localAddress, std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, bool reuseAddress=true, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool nonBlocking=false, bool dualStack=true, bool autoBind=true)</div><div class="ttdoc">Constructs a fully configurable multicast socket for receiving and sending datagrams.</div><div class="ttdef"><b>Definition</b> MulticastSocket.cpp:7</div></div>
<div class="ttc" id="agroup__udp_html_gaa47a2a344af40c080a860d5ee0883fd0"><div class="ttname"><a href="#gaa47a2a344af40c080a860d5ee0883fd0">jsocketpp::MulticastSocket::getMulticastInterface</a></div><div class="ttdeci">std::string getMulticastInterface() const</div><div class="ttdoc">Get the currently selected egress interface for multicast transmissions.</div><div class="ttdef"><b>Definition</b> MulticastSocket.hpp:478</div></div>
<div class="ttc" id="agroup__udp_html_gaf0d5d684dcbfcf62907482ae3ac98948"><div class="ttname"><a href="#gaf0d5d684dcbfcf62907482ae3ac98948">jsocketpp::MulticastSocket::setMulticastInterface</a></div><div class="ttdeci">void setMulticastInterface(const std::string &amp;iface)</div><div class="ttdoc">Select the default outgoing interface for multicast transmissions.</div><div class="ttdef"><b>Definition</b> MulticastSocket.cpp:20</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3afd5b0d48ee9f92759c6f2d4ea9d8f0" name="ga3afd5b0d48ee9f92759c6f2d4ea9d8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3afd5b0d48ee9f92759c6f2d4ea9d8f0">&#9670;&#160;</a></span>getRemoteIp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DatagramSocket::getRemoteIp </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>convertIPv4Mapped</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the remote peer IP address for this socket. </p>
<p>Produces the textual IP address (IPv4 or IPv6) of the current remote endpoint. The source of truth is:</p><ul>
<li><b>Connected sockets:</b> use the cached peer if available; otherwise perform one <span class="tt">getpeername()</span> to query the OS.</li>
<li><b>Unconnected sockets:</b> return the last-seen sender if your receive path has cached one; otherwise this method fails because no remote is known yet.</li>
</ul>
<p>When <code class="param">convertIPv4Mapped</code> is <span class="tt">true</span> and the address is IPv6 IPv4-mapped (<span class="tt">::ffff:a.b.c.d</span>), the result is converted to an IPv4 literal (<span class="tt">a.b.c.d</span>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convertIPv4Mapped</td><td>Convert IPv4-mapped IPv6 addresses to IPv4 text if <span class="tt">true</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string Remote IP address in presentation form.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket must be open (<span class="tt">isOpen() == true</span>).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If the socket is not open.</li>
<li>If the socket is unconnected and no last-seen sender is cached.</li>
<li>If <span class="tt">getpeername()</span> is needed (connected, no cache) and it fails; the exception carries <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt">SocketErrorMessage(GetSocketError())</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1) when the peer is cached; otherwise one <span class="tt">getpeername()</span> call. </dd>
<dd>
Thread-safety: call from the socket’s owning thread; do not race with <span class="tt"><a class="el" href="#ga02b08c333a2f109a3b19ec7b3c0cecf9" title="Disconnect this UDP socket from its current default peer.">disconnect()</a></span> or <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span>.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s;</div>
<div class="line">s.<a class="code hl_function" href="#ga915c790c7cfde485e680ddec2edb2e74">connect</a>(<span class="stringliteral">&quot;2001:db8::10&quot;</span>, 5353, 1000);</div>
<div class="line">std::string ip = s.<a class="code hl_function" href="#ga3afd5b0d48ee9f92759c6f2d4ea9d8f0">getRemoteIp</a>(<span class="keyword">true</span>); <span class="comment">// e.g., &quot;2001:db8::10&quot;</span></div>
<div class="ttc" id="agroup__udp_html_ga3afd5b0d48ee9f92759c6f2d4ea9d8f0"><div class="ttname"><a href="#ga3afd5b0d48ee9f92759c6f2d4ea9d8f0">jsocketpp::DatagramSocket::getRemoteIp</a></div><div class="ttdeci">std::string getRemoteIp(bool convertIPv4Mapped) const</div><div class="ttdoc">Return the remote peer IP address for this socket.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:1751</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga6d1dbfd5b854e120b352a27b541e5841" name="ga6d1dbfd5b854e120b352a27b541e5841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d1dbfd5b854e120b352a27b541e5841">&#9670;&#160;</a></span>getRemotePort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> DatagramSocket::getRemotePort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the remote peer UDP port for this socket. </p>
<p>Obtains the numeric port of the current remote endpoint. The source of truth is:</p><ul>
<li><b>Connected sockets:</b> use the cached peer (if available); otherwise perform a single <span class="tt">getpeername()</span> to query the OS.</li>
<li><b>Unconnected sockets:</b> return the last-seen sender if your receive path has cached one; otherwise this method fails because no remote is known yet.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a> The remote UDP port number.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">isOpen() == true</span>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If the socket is not open.</li>
<li>If the socket is unconnected and no last-seen sender is cached.</li>
<li>If <span class="tt">getpeername()</span> is required (connected, no cache) and it fails; the exception carries <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt">SocketErrorMessage(GetSocketError())</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1) when the remote is cached; otherwise one <span class="tt">getpeername()</span> call. </dd>
<dd>
Thread-safety: intended for the socket’s owning thread. Do not call concurrently with <span class="tt"><a class="el" href="#ga02b08c333a2f109a3b19ec7b3c0cecf9" title="Disconnect this UDP socket from its current default peer.">disconnect()</a></span> or <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> or other operations that mutate connection state.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s;</div>
<div class="line">s.<a class="code hl_function" href="#ga915c790c7cfde485e680ddec2edb2e74">connect</a>(<span class="stringliteral">&quot;203.0.113.7&quot;</span>, 9999, 1000);</div>
<div class="line"><a class="code hl_typedef" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> rp = s.<a class="code hl_function" href="#ga6d1dbfd5b854e120b352a27b541e5841">getRemotePort</a>();  <span class="comment">// e.g., 9999</span></div>
<div class="ttc" id="agroup__udp_html_ga6d1dbfd5b854e120b352a27b541e5841"><div class="ttname"><a href="#ga6d1dbfd5b854e120b352a27b541e5841">jsocketpp::DatagramSocket::getRemotePort</a></div><div class="ttdeci">Port getRemotePort() const</div><div class="ttdoc">Return the remote peer UDP port for this socket.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:1760</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa31790315a4bb8d20cd924157107a166" name="gaa31790315a4bb8d20cd924157107a166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa31790315a4bb8d20cd924157107a166">&#9670;&#160;</a></span>getRemoteSocketAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DatagramSocket::getRemoteSocketAddress </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>convertIPv4Mapped</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the remote endpoint as a single "ip:port" string. </p>
<p>Formats the current remote endpoint into a presentation string. The source of truth is:</p><ul>
<li><b>Connected sockets:</b> use the cached peer if available; otherwise perform at most one <span class="tt">getpeername()</span> to obtain it.</li>
<li><b>Unconnected sockets:</b> use the last-seen sender cached by receive paths; if none is available, the method fails because no remote is known yet.</li>
</ul>
<p>When <code class="param">convertIPv4Mapped</code> is <span class="tt">true</span> and the address is an IPv6 IPv4-mapped form (<span class="tt">::ffff:a.b.c.d</span>), the IP portion is converted to an IPv4 literal (<span class="tt">a.b.c.d</span>) before concatenation. If your IP formatter brackets IPv6 addresses, the result may look like <span class="tt">"[2001:db8::1]:5353"</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convertIPv4Mapped</td><td>If <span class="tt">true</span>, convert IPv4-mapped IPv6 addresses to IPv4 text before building the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The remote endpoint string, e.g., <span class="tt">"192.0.2.10:54321"</span> or <span class="tt">"[2001:db8::1]:54321"</span>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket must be open (<span class="tt">isOpen() == true</span>).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If the socket is not open.</li>
<li>If the socket is unconnected and no last-seen sender is cached.</li>
<li>If <span class="tt">getpeername()</span> is required (connected, no cache) and it fails; the exception carries <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt">SocketErrorMessage(GetSocketError())</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1) when the remote is cached; otherwise at most one <span class="tt">getpeername()</span> call. </dd>
<dd>
Thread-safety: call from the socket’s owning thread; do not race with <span class="tt"><a class="el" href="#ga02b08c333a2f109a3b19ec7b3c0cecf9" title="Disconnect this UDP socket from its current default peer.">disconnect()</a></span> or <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span>.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> s;</div>
<div class="line">s.<a class="code hl_function" href="#ga915c790c7cfde485e680ddec2edb2e74">connect</a>(<span class="stringliteral">&quot;example.net&quot;</span>, 5353, 2000);</div>
<div class="line"><span class="keyword">auto</span> ep = s.<a class="code hl_function" href="#gaa31790315a4bb8d20cd924157107a166">getRemoteSocketAddress</a>(<span class="keyword">true</span>);   <span class="comment">// e.g., &quot;[2001:db8::10]:5353&quot;</span></div>
<div class="ttc" id="agroup__udp_html_gaa31790315a4bb8d20cd924157107a166"><div class="ttname"><a href="#gaa31790315a4bb8d20cd924157107a166">jsocketpp::DatagramSocket::getRemoteSocketAddress</a></div><div class="ttdeci">std::string getRemoteSocketAddress(bool convertIPv4Mapped) const</div><div class="ttdoc">Return the remote endpoint as a single &quot;ip:port&quot; string.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:1769</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga509c53d38c840b0cf95fbb16362a12ce" name="ga509c53d38c840b0cf95fbb16362a12ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga509c53d38c840b0cf95fbb16362a12ce">&#9670;&#160;</a></span>hasDestination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::DatagramPacket::hasDestination </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report whether this packet specifies an explicit destination (address + port). </p>
<p>Returns <span class="tt">true</span> if the packet’s destination fields are set to a usable value for sending: a non-blank <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramPacket.html#a9f0c6f68dc00926fdea15ce77504e954" title="Remote address (IPv4/IPv6) for the destination/source.">address</a></span> (not just whitespace) <b>and</b> a non-zero UDP <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramPacket.html#a6619b7fcd476199e4a9c454d06f1bcd4" title="Remote UDP port for the destination/source.">port</a></span>. This is a <b>syntactic</b> check only; it does not validate that the address string is a resolvable host/IP or that the port is reachable.</p>
<p>Typical uses:</p><ul>
<li>In <span class="tt"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">DatagramSocket::write</a>(const <a class="el" href="classjsocketpp_1_1DatagramPacket.html" title="Represents a UDP datagram packet, encapsulating both payload and addressing information.">DatagramPacket</a>&amp;)</span>, choose between sending to the socket’s connected peer (when this returns <span class="tt">false</span>) or sending to the packet’s explicit destination via <span class="tt">sendto</span> (when this returns <span class="tt">true</span>).</li>
<li>After a receive, indicates whether the source endpoint fields (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramPacket.html#a9f0c6f68dc00926fdea15ce77504e954" title="Remote address (IPv4/IPv6) for the destination/source.">address</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramPacket.html#a6619b7fcd476199e4a9c454d06f1bcd4" title="Remote UDP port for the destination/source.">port</a></span>) were filled.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramPacket.html#a9f0c6f68dc00926fdea15ce77504e954" title="Remote address (IPv4/IPv6) for the destination/source.">address</a></span> contains any non-whitespace character and <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramPacket.html#a6619b7fcd476199e4a9c454d06f1bcd4" title="Remote UDP port for the destination/source.">port</a> != 0</span>; otherwise <span class="tt">false</span>.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="classjsocketpp_1_1DatagramPacket.html#a867c818e26b61fa3c67ddbe787290360">DatagramPacket</a> p;</div>
<div class="line">p.<a class="code hl_variable" href="classjsocketpp_1_1DatagramPacket.html#a5a52a853827976d996fb0f85ae54bfd9">buffer</a>.assign(data.begin(), data.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// No destination yet:</span></div>
<div class="line">assert(!p.<a class="code hl_function" href="#ga509c53d38c840b0cf95fbb16362a12ce">hasDestination</a>());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set destination for send:</span></div>
<div class="line">p.<a class="code hl_variable" href="classjsocketpp_1_1DatagramPacket.html#a9f0c6f68dc00926fdea15ce77504e954">address</a> = <span class="stringliteral">&quot;2001:db8::1&quot;</span>;</div>
<div class="line">p.<a class="code hl_variable" href="classjsocketpp_1_1DatagramPacket.html#a6619b7fcd476199e4a9c454d06f1bcd4">port</a>    = 5353;</div>
<div class="line">assert(p.<a class="code hl_function" href="#ga509c53d38c840b0cf95fbb16362a12ce">hasDestination</a>());</div>
<div class="ttc" id="aclassjsocketpp_1_1DatagramPacket_html_a5a52a853827976d996fb0f85ae54bfd9"><div class="ttname"><a href="classjsocketpp_1_1DatagramPacket.html#a5a52a853827976d996fb0f85ae54bfd9">jsocketpp::DatagramPacket::buffer</a></div><div class="ttdeci">std::vector&lt; char &gt; buffer</div><div class="ttdoc">Data buffer for the packet payload.</div><div class="ttdef"><b>Definition</b> DatagramPacket.hpp:56</div></div>
<div class="ttc" id="aclassjsocketpp_1_1DatagramPacket_html_a6619b7fcd476199e4a9c454d06f1bcd4"><div class="ttname"><a href="classjsocketpp_1_1DatagramPacket.html#a6619b7fcd476199e4a9c454d06f1bcd4">jsocketpp::DatagramPacket::port</a></div><div class="ttdeci">Port port</div><div class="ttdoc">Remote UDP port for the destination/source.</div><div class="ttdef"><b>Definition</b> DatagramPacket.hpp:70</div></div>
<div class="ttc" id="aclassjsocketpp_1_1DatagramPacket_html_a867c818e26b61fa3c67ddbe787290360"><div class="ttname"><a href="classjsocketpp_1_1DatagramPacket.html#a867c818e26b61fa3c67ddbe787290360">jsocketpp::DatagramPacket::DatagramPacket</a></div><div class="ttdeci">DatagramPacket(const size_t size=0)</div><div class="ttdoc">Construct an empty DatagramPacket with a specified buffer size.</div><div class="ttdef"><b>Definition</b> DatagramPacket.hpp:76</div></div>
<div class="ttc" id="aclassjsocketpp_1_1DatagramPacket_html_a9f0c6f68dc00926fdea15ce77504e954"><div class="ttname"><a href="classjsocketpp_1_1DatagramPacket.html#a9f0c6f68dc00926fdea15ce77504e954">jsocketpp::DatagramPacket::address</a></div><div class="ttdeci">std::string address</div><div class="ttdoc">Remote address (IPv4/IPv6) for the destination/source.</div><div class="ttdef"><b>Definition</b> DatagramPacket.hpp:63</div></div>
<div class="ttc" id="agroup__udp_html_ga509c53d38c840b0cf95fbb16362a12ce"><div class="ttname"><a href="#ga509c53d38c840b0cf95fbb16362a12ce">jsocketpp::DatagramPacket::hasDestination</a></div><div class="ttdeci">bool hasDestination() const noexcept</div><div class="ttdoc">Report whether this packet specifies an explicit destination (address + port).</div><div class="ttdef"><b>Definition</b> DatagramPacket.hpp:161</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9befab6dbf6e8fc0dd9ee0e9645ea099" name="ga9befab6dbf6e8fc0dd9ee0e9645ea099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9befab6dbf6e8fc0dd9ee0e9645ea099">&#9670;&#160;</a></span>hasPendingData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DatagramSocket::hasPendingData </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the socket is readable within a timeout (no data is consumed). </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Waits until the socket becomes readable and returns whether at least one datagram is ready to be received. This call does not read or consume data; it only checks readiness. A negative <code class="param">timeoutMillis</code> blocks indefinitely. A zero timeout performs a non-blocking poll.</p>
<p>Implementation uses <span class="tt">poll</span> on POSIX and <span class="tt">WSAPoll</span> on Windows (preferred over <span class="tt">select</span> to avoid FD_SETSIZE limits and provide better EINTR semantics).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Timeout in milliseconds. &lt; 0 = infinite, 0 = immediate, &gt; 0 = bounded wait.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the socket is readable within the timeout; false on timeout (no data ready).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open or if the readiness API reports an error (error code/message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>No data is consumed from the socket; the readability state may change due to races typical of readiness APIs (i.e., data could be gone by the time you attempt to read).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Prefer calling this as a guard before best-effort reads with per-call timeouts (e.g., <span class="tt"><a class="el" href="#ga4d5295306a17e8fdf4a6e00556e043b5" title="Read up to n bytes from the next UDP datagram, waiting up to timeoutMillis for data.">readAtMostWithTimeout</a></span> can delegate to this check). </dd></dl>

</div>
</div>
<a id="gadd6a72af69e4e8e1e8701c60a7e728f1" name="gadd6a72af69e4e8e1e8701c60a7e728f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd6a72af69e4e8e1e8701c60a7e728f1">&#9670;&#160;</a></span>isBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::DatagramSocket::isBound </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the datagram socket has been explicitly bound to a local address or port. </p>
<p>Returns <span class="tt">true</span> if the socket has successfully completed a call to one of the <span class="tt"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a></span> overloads. Binding is optional for UDP sockets, but is commonly required for:</p>
<ul>
<li>Receiving datagrams on a specific port (e.g., UDP server or listener)</li>
<li>Specifying a fixed source port (e.g., for NAT traversal or P2P scenarios)</li>
<li>Selecting a specific local interface in multihomed systems</li>
<li>Participating in multicast or broadcast communication</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>A datagram socket can only be bound once. Attempting to bind again will throw. </dd>
<dd>
If the socket was constructed with a port but <span class="tt"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a></span> is never called, it remains unbound. </dd>
<dd>
Binding must occur before calling <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span> or sending datagrams from an unconnected socket.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="autotoc_md674"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> sock;</div>
<div class="line">sock.<a class="code hl_function" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49">bind</a>(12345);</div>
<div class="line"><span class="keywordflow">if</span> (sock.<a class="code hl_function" href="#gadd6a72af69e4e8e1e8701c60a7e728f1">isBound</a>()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Listening on &quot;</span> &lt;&lt; sock.<a class="code hl_function" href="#ga2b19edc594f75938a6028094744ec107">getLocalSocketAddress</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__udp_html_gadd6a72af69e4e8e1e8701c60a7e728f1"><div class="ttname"><a href="#gadd6a72af69e4e8e1e8701c60a7e728f1">jsocketpp::DatagramSocket::isBound</a></div><div class="ttdeci">bool isBound() const noexcept</div><div class="ttdoc">Indicates whether the datagram socket has been explicitly bound to a local address or port.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:880</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket has been bound to a local address/port, <span class="tt">false</span> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a>, <a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a>, <a class="el" href="#ga2b19edc594f75938a6028094744ec107" title="Return the local endpoint as a single &quot;ip:port&quot; string.">getLocalSocketAddress()</a> </dd></dl>

</div>
</div>
<a id="gae91f746fb4cffa0eb8460c816a476d65" name="gae91f746fb4cffa0eb8460c816a476d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae91f746fb4cffa0eb8460c816a476d65">&#9670;&#160;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::DatagramSocket::isClosed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the datagram socket has been closed or is otherwise invalid. </p>
<p>Returns <span class="tt">true</span> if the socket is no longer usable—either because it was explicitly closed via <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span>, or because it was never successfully initialized (i.e., holds an invalid file descriptor).</p>
<p>This method does <b>not</b> perform any system-level query. It simply checks whether the internal socket descriptor equals <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>. This is the standard invariant for resource management in the jsocketpp UDP API.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md699"></a>
Common Scenarios</h3>
<ul>
<li>The socket was default-initialized or failed during construction</li>
<li>The socket was explicitly closed via <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span></li>
<li>The socket was moved-from, leaving the source in a valid but unusable state</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Once a datagram socket is closed, it cannot be reused. Create a new instance to open a new socket.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket is closed or invalid, <span class="tt">false</span> if it is open and usable.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="autotoc_md700"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1DatagramSocket.html">jsocketpp::DatagramSocket</a> sock(12345);</div>
<div class="line">assert(!sock.isClosed());</div>
<div class="line">sock.close();</div>
<div class="line">assert(sock.isClosed()); <span class="comment">// ✅</span></div>
<div class="ttc" id="aclassjsocketpp_1_1DatagramSocket_html"><div class="ttname"><a href="classjsocketpp_1_1DatagramSocket.html">jsocketpp::DatagramSocket</a></div><div class="ttdoc">Cross-platform UDP socket class with Java-style interface.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:484</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a>, <a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a>, <a class="el" href="#gadd6a72af69e4e8e1e8701c60a7e728f1" title="Indicates whether the datagram socket has been explicitly bound to a local address or port.">isBound()</a>, <a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> </dd></dl>

</div>
</div>
<a id="gac3b7c4a5fc5a21372c4a9cadb3e85efb" name="gac3b7c4a5fc5a21372c4a9cadb3e85efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::DatagramSocket::isConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the datagram socket is connected to a specific remote peer. </p>
<p>Returns <span class="tt">true</span> if the socket has been successfully connected to a remote address and port using the <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span> method. While UDP is a connectionless protocol, invoking <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span> on a datagram socket enables connection-oriented semantics:</p>
<ul>
<li>Filters incoming datagrams to only accept from the connected peer</li>
<li>Allows use of <span class="tt">send()</span> / <span class="tt">recv()</span> instead of <span class="tt">sendto()</span> / <span class="tt">recvfrom()</span></li>
<li>Enables simplified calls like <span class="tt"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write</a>("message")</span> or <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read</a>&lt;T&gt;()</span></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This method reflects the internal connection state as tracked by the library. </dd>
<dd>
It does not verify whether the remote host is reachable or alive. </dd>
<dd>
Unconnected sockets may still send and receive using <span class="tt">write(host, port)</span> or <span class="tt">write(DatagramPacket)</span>.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="autotoc_md675"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 9999);</div>
<div class="line">sock.connect();</div>
<div class="line"><span class="keywordflow">if</span> (sock.isConnected()) {</div>
<div class="line">    sock.write(<span class="stringliteral">&quot;ping&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket has been logically connected to a peer, <span class="tt">false</span> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a>, write(std::string_view), <a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read&lt;T&gt;()</a>, <a class="el" href="#ga02b08c333a2f109a3b19ec7b3c0cecf9" title="Disconnect this UDP socket from its current default peer.">disconnect()</a> </dd></dl>

</div>
</div>
<a id="gab33da807656e2ab920707d60605844f5" name="gab33da807656e2ab920707d60605844f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab33da807656e2ab920707d60605844f5">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::DatagramSocket::isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the datagram socket is valid and ready for use. </p>
<p>Returns <span class="tt">true</span> if the socket has a valid file descriptor and has not been closed or moved-from. A valid datagram socket can be used for sending and receiving UDP packets, though it may or may not be bound or connected.</p>
<p>This method performs a quick, local check:</p><ul>
<li>It does <b>not</b> verify whether the socket is bound (see <span class="tt"><a class="el" href="#gadd6a72af69e4e8e1e8701c60a7e728f1" title="Indicates whether the datagram socket has been explicitly bound to a local address or port.">isBound()</a></span>)</li>
<li>It does <b>not</b> verify whether the socket is connected (see <span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a></span>)</li>
<li>It does <b>not</b> query the operating system or socket state</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md696"></a>
Use Cases</h3>
<ul>
<li>Guarding against use-after-close</li>
<li>Early validation in test or utility code</li>
<li>Precondition checks before <span class="tt"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a></span> or <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md697"></a>
Implementation Details</h3>
<ul>
<li>Returns <span class="tt">true</span> if <span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></li>
<li>Constant-time, thread-safe, no system calls</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket is open and usable; <span class="tt">false</span> if it was closed, moved-from, or failed to initialize.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A valid socket may be unbound or unconnected. Use <span class="tt"><a class="el" href="#gadd6a72af69e4e8e1e8701c60a7e728f1" title="Indicates whether the datagram socket has been explicitly bound to a local address or port.">isBound()</a></span> and <span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a></span> to query those states.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="autotoc_md698"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 9999);</div>
<div class="line">assert(sock.isValid());</div>
<div class="line">sock.connect();</div>
<div class="line">sock.close();</div>
<div class="line">assert(!sock.isValid()); <span class="comment">// ✅ socket no longer usable</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gadd6a72af69e4e8e1e8701c60a7e728f1" title="Indicates whether the datagram socket has been explicitly bound to a local address or port.">isBound()</a>, <a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a>, <a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a>, <a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> </dd></dl>

</div>
</div>
<a id="ga7937b05ccae7d059b4fcfa4b6383c75c" name="ga7937b05ccae7d059b4fcfa4b6383c75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7937b05ccae7d059b4fcfa4b6383c75c">&#9670;&#160;</a></span>joinGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MulticastSocket::joinGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>groupAddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>iface</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a multicast group on an optional interface (string-friendly). </p>
<p>Adds this socket to the multicast group identified by <code class="param">groupAddr</code>, optionally scoping the membership to a specific local interface indicated by <code class="param">iface</code>. The method accepts human-friendly identifiers and performs resolution and validation before delegating to the OS via <span class="tt">setsockopt</span>.</p>
<p>Accepted forms</p><ul>
<li><code class="param">groupAddr:</code> <ul>
<li>IPv4 literal (e.g., "239.1.2.3") or hostname that resolves to IPv4.</li>
<li>IPv6 literal (e.g., "ff15::abcd") or hostname that resolves to IPv6.</li>
<li>Must resolve to a <b>multicast</b> address (IPv4 224.0.0.0/4 or IPv6 ff00::/8).</li>
</ul>
</li>
<li><code class="param">iface</code> (optional selector of the local interface used for membership):<ul>
<li><b>IPv4 membership:</b> IPv4 literal of the interface’s unicast address (e.g., "192.0.2.10"). Empty selects the default (<span class="tt">INADDR_ANY</span>).</li>
<li><b>IPv6 membership:</b> decimal <b>interface index</b> as a string (e.g., "12"). On POSIX, an <b>interface name</b> (e.g., "eth0") is also accepted and converted via <span class="tt">if_nametoindex()</span>. Empty selects index <span class="tt">0</span> (default). On Windows, interface <b>names are not supported</b>; use a numeric index.</li>
</ul>
</li>
</ul>
<p>Behavior</p><ul>
<li>Resolves <code class="param">groupAddr</code> to either <span class="tt">in_addr</span> or <span class="tt">in6_addr</span> (IPv4/IPv6), using a fast literal path first, then the project resolver (<span class="tt">resolveAddress(...)</span>).</li>
<li>Verifies the resolved address is multicast (<span class="tt">IN_MULTICAST</span> / <span class="tt">IN6_IS_ADDR_MULTICAST</span>).</li>
<li>Resolves <code class="param">iface</code> as described above and binds the membership to that interface.</li>
<li>Invokes the centralized option helpers:<ul>
<li>IPv4: <span class="tt"><a class="el" href="group__socketopts.html#ga65375075d5e7b8009730e0d28b199d73" title="Join an IPv4 any-source multicast (ASM) group on a specific interface.">joinGroupIPv4(in_addr group, in_addr iface)</a></span></li>
<li>IPv6: <span class="tt"><a class="el" href="group__socketopts.html#ga26253ae313b6ef1417af775668ffbf24" title="Join an IPv6 any-source multicast (ASM) group on a specific interface index.">joinGroupIPv6(in6_addr group, unsigned int ifindex)</a></span></li>
</ul>
</li>
<li>Updates internal caches (e.g., <span class="tt"><a class="el" href="classjsocketpp_1_1MulticastSocket.html#a76d7a48934af994c867fb2650ccfd83b" title="Last joined multicast group address.">_currentGroup</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1MulticastSocket.html#a441b5a5c2b962e040d8910185fb360c0" title="Interface used for multicast.">_currentInterface</a></span>) <b>only after</b> the OS call succeeds.</li>
</ul>
<p>Notes</p><ul>
<li>This method <b>does not</b> select the <b>egress</b> interface for outbound traffic; use <a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface(const std::string&amp;)</a> (or the per-family variants) to choose where your sends go. Membership here controls <b>what you receive</b>.</li>
<li>For link-local IPv6 groups (<span class="tt">ff02::/16</span>), specifying a correct interface index is often required by the OS; prefer a non-empty <code class="param">iface</code> in that case.</li>
<li>Repeat joins of the same (group, interface) may be ignored or rejected by the OS depending on the stack; behavior is implementation-defined.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">groupAddr</td><td>Multicast group (literal or resolvable name), IPv4 or IPv6. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>Optional interface selector as described above; empty uses the default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><code class="param">groupAddr</code> is empty or does not resolve to a multicast address.</li>
<li><code class="param">iface</code> is malformed (e.g., bad IPv4 literal; unknown POSIX name; non-numeric index string on Windows).</li>
<li>Name resolution fails (exception carries the <span class="tt">getaddrinfo</span> code/message).</li>
<li>The underlying membership call fails:<ul>
<li>IPv4: <span class="tt">setsockopt(IP_ADD_MEMBERSHIP)</span></li>
<li>IPv6 (POSIX): <span class="tt">setsockopt(IPV6_JOIN_GROUP)</span></li>
<li>IPv6 (Windows): <span class="tt">setsockopt(IPV6_ADD_MEMBERSHIP)</span></li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Related</dt><dd><ul>
<li><a class="el" href="#gaf7317567ceae9b90967ec5a29d003af3">leaveGroup(const std::string&amp;, const std::string&amp;)</a> — leave a group.</li>
<li><a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface(const std::string&amp;)</a> — choose egress interface.</li>
<li><a class="el" href="#ga72172a10bc5ba13a908f31c791c90ec5">setTimeToLive(int)</a> / <a class="el" href="group__socketopts.html#gad11b9d3378834eab9c28e32e70fc249a">getTimeToLive()</a> — control cached TTL/hops.</li>
<li><a class="el" href="group__socketopts.html#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> / <a class="el" href="group__socketopts.html#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL()</a> — OS-level multicast TTL/hops.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// IPv4: join on default interface</span></div>
<div class="line">sock.joinGroup(<span class="stringliteral">&quot;239.1.2.3&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// IPv4: join on a specific local interface address</span></div>
<div class="line">sock.joinGroup(<span class="stringliteral">&quot;239.1.2.3&quot;</span>, <span class="stringliteral">&quot;192.0.2.10&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// IPv6: join using numeric interface index (works on all platforms)</span></div>
<div class="line">sock.joinGroup(<span class="stringliteral">&quot;ff15::feed&quot;</span>, <span class="stringliteral">&quot;12&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// POSIX only: join using interface name</span></div>
<div class="line">sock.joinGroup(<span class="stringliteral">&quot;ff15::feed&quot;</span>, <span class="stringliteral">&quot;eth0&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf7317567ceae9b90967ec5a29d003af3" name="gaf7317567ceae9b90967ec5a29d003af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7317567ceae9b90967ec5a29d003af3">&#9670;&#160;</a></span>leaveGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MulticastSocket::leaveGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>groupAddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>iface</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a multicast group on an optional interface (string-friendly). </p>
<p>Removes this socket’s membership from the multicast group identified by <code class="param">groupAddr</code>. The interface used for the leave operation can be selected via <code class="param">iface</code> and follows the same conventions as <a class="el" href="#ga7937b05ccae7d059b4fcfa4b6383c75c">joinGroup</a>.</p>
<p>Accepted forms</p><ul>
<li><code class="param">groupAddr:</code> <ul>
<li>IPv4 literal (e.g., "239.1.2.3") or hostname that resolves to IPv4.</li>
<li>IPv6 literal (e.g., "ff15::abcd") or hostname that resolves to IPv6.</li>
<li>Must resolve to a multicast address (IPv4 224.0.0.0/4, IPv6 ff00::/8).</li>
</ul>
</li>
<li><code class="param">iface</code> (optional; selects the local interface whose membership is removed):<ul>
<li>IPv4 leave: IPv4 literal of the interface’s unicast address (e.g., "192.0.2.10"). Empty string selects the default interface (INADDR_ANY).</li>
<li>IPv6 leave: decimal interface index as a string (e.g., "12"). On POSIX, an interface name (e.g., "eth0") is also accepted and mapped via if_nametoindex(). Empty string selects index 0 (system default). On Windows, names are not supported; use a numeric index.</li>
</ul>
</li>
</ul>
<p>Behavior</p><ul>
<li>Resolves <code class="param">groupAddr</code> to either an in_addr or in6_addr via a fast literal path first, and otherwise through the project resolver (resolveAddress).</li>
<li>Validates that the resolved address is multicast (IN_MULTICAST / IN6_IS_ADDR_MULTICAST).</li>
<li>Interprets <code class="param">iface</code> as described above to obtain the IPv4 interface address or IPv6 interface index used when the membership was created.</li>
<li>Delegates to centralized option helpers:<ul>
<li>IPv4: setsockopt(IP_DROP_MEMBERSHIP) via <a class="el" href="group__socketopts.html#ga31401a44675c8fd07c2e80a674106ce9" title="Leave a previously joined IPv4 multicast group on a specific interface.">leaveGroupIPv4(in_addr group, in_addr iface)</a></li>
<li>IPv6 (POSIX): setsockopt(IPV6_LEAVE_GROUP) via leaveGroupIPv6(in6_addr group, unsigned ifindex)</li>
<li>IPv6 (Windows): setsockopt(IPV6_DROP_MEMBERSHIP) via leaveGroupIPv6(...)</li>
</ul>
</li>
</ul>
<p>Notes</p><ul>
<li>The interface provided to leave should match the one used to join the group on this socket. If it does not, some stacks return an error (for example EADDRNOTAVAIL) or ignore the request.</li>
<li>This method affects only <b>membership</b> (what the socket can receive). It does not change the <b>egress</b> interface for sending; use setMulticastInterface(...) for that.</li>
<li>Repeated leaves for the same (group, interface) may be ignored or may fail depending on the OS; behavior is implementation-defined.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">groupAddr</td><td>Multicast group to leave (literal or resolvable name), IPv4 or IPv6. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>Optional interface selector as described above; default is the empty string, which uses the system default (IPv4 INADDR_ANY, IPv6 index 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The socket was previously joined to the specified group on the selected interface.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The socket is no longer a member of the specified group on that interface. Internal caches tracking the “current” group/interface may be cleared if they match.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><code class="param">groupAddr</code> is empty or does not resolve to a multicast address.</li>
<li><code class="param">iface</code> is malformed (invalid IPv4 literal, unknown POSIX interface name, or non-numeric index on Windows where names are unsupported).</li>
<li>Name resolution fails; the exception carries the getaddrinfo code/message.</li>
<li>The underlying membership removal fails (e.g., ENOTSOCK, EINVAL, EADDRNOTAVAIL, ENOPROTOOPT, or Windows equivalents) when invoking:<ul>
<li>IPv4: IP_DROP_MEMBERSHIP</li>
<li>IPv6 (POSIX): IPV6_LEAVE_GROUP</li>
<li>IPv6 (Windows): IPV6_DROP_MEMBERSHIP</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Related</dt><dd><ul>
<li><a class="el" href="#ga7937b05ccae7d059b4fcfa4b6383c75c">joinGroup(const std::string&amp;, const std::string&amp;)</a> — add membership.</li>
<li><a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface(const std::string&amp;)</a> — choose egress interface.</li>
<li><a class="el" href="#gab6608be5d1aff24ad5077f6ea9a9168a">setLoopbackMode(bool)</a> / <a class="el" href="group__socketopts.html#ga0f0ab03631b48add0e1b8845e553ebab">getLoopbackMode()</a> — control/query local delivery of this socket’s own multicast.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// IPv4: leave on default interface</span></div>
<div class="line">sock.leaveGroup(<span class="stringliteral">&quot;239.1.2.3&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// IPv4: leave on a specific local interface address</span></div>
<div class="line">sock.leaveGroup(<span class="stringliteral">&quot;239.1.2.3&quot;</span>, <span class="stringliteral">&quot;192.0.2.10&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// IPv6: leave using numeric interface index (any platform)</span></div>
<div class="line">sock.leaveGroup(<span class="stringliteral">&quot;ff15::feed&quot;</span>, <span class="stringliteral">&quot;12&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// POSIX-only: leave using interface name</span></div>
<div class="line">sock.leaveGroup(<span class="stringliteral">&quot;ff15::feed&quot;</span>, <span class="stringliteral">&quot;eth0&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga996b99882efa863b01e0fff4a9782a82" name="ga996b99882efa863b01e0fff4a9782a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996b99882efa863b01e0fff4a9782a82">&#9670;&#160;</a></span>MulticastSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MulticastSocket::MulticastSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>localPort</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reuseAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dualStack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>autoBind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a fully configurable multicast socket for receiving and sending datagrams. </p>
<p>This advanced constructor provides complete control over the configuration of a multicast UDP socket, including binding behavior, buffer sizes, timeouts, and dual-stack support. It is designed for power users who need fine-grained socket tuning prior to joining one or more multicast groups using <a class="el" href="#ga7937b05ccae7d059b4fcfa4b6383c75c">joinGroup()</a>.</p>
<p>Unlike simpler constructors, this overload supports use cases such as:</p><ul>
<li>Binding to a specific local interface (e.g., "192.168.1.5" or "::1")</li>
<li>Using system-assigned ephemeral ports (by passing <span class="tt">localPort = 0</span>)</li>
<li>Tuning performance and memory characteristics with custom buffer sizes</li>
<li>Enabling non-blocking mode for asynchronous usage</li>
<li>Configuring receive/send timeouts for socket operations</li>
<li>Enabling dual-stack mode for IPv4-mapped IPv6 support</li>
</ul>
<p>No multicast group is joined automatically — you must call <a class="el" href="#ga7937b05ccae7d059b4fcfa4b6383c75c">joinGroup()</a> after construction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localPort</td><td>The local port to bind to. Use <span class="tt">0</span> to request an ephemeral port assigned by the OS.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localAddress</td><td>Optional local interface or IP address to bind to. Common values:<ul>
<li><span class="tt">"0.0.0.0"</span>: any IPv4 interface</li>
<li><span class="tt">"::"</span>: any IPv6 interface</li>
<li>A specific interface address (e.g., <span class="tt">"192.168.1.10"</span>)</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional size of the OS-level receive buffer, in bytes (e.g., 4096). If <span class="tt">std::nullopt</span>, the default size is used.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional size of the OS-level send buffer, in bytes. If <span class="tt">std::nullopt</span>, the default is used.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Optional size of the internal user-space buffer used by <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read()</a></span> and related methods.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reuseAddress</td><td>Whether to enable <span class="tt">SO_REUSEADDR</span> so multiple sockets can bind to the same port (useful for multiple receivers on the same machine).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Receive timeout in milliseconds. Use <span class="tt">-1</span> to disable.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Send timeout in milliseconds. Use <span class="tt">-1</span> to disable.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>If true, the socket is set to non-blocking mode after creation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dualStack</td><td>Enables IPv4-mapped IPv6 support when using <span class="tt">"::"</span> bind addresses. Has no effect for IPv4-only sockets.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoBind</td><td>If true, the socket will automatically call <span class="tt"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a></span> to the given address and port. If false, you must call <span class="tt"><a class="el" href="#ga550b67d7ad08c5cb068bb2b66d2c2c49" title="Binds the datagram socket to all available interfaces on an ephemeral port.">bind()</a></span> manually before using the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If socket creation, binding, or option setting fails for any reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This constructor does not automatically join a multicast group. Use <a class="el" href="#ga7937b05ccae7d059b4fcfa4b6383c75c">joinGroup()</a> after construction to receive multicast traffic.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="autotoc_md738"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacejsocketpp.html">jsocketpp</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga996b99882efa863b01e0fff4a9782a82">MulticastSocket</a> sock(</div>
<div class="line">    4446,               <span class="comment">// bind to port 4446</span></div>
<div class="line">    <span class="stringliteral">&quot;::&quot;</span>,               <span class="comment">// bind to all interfaces (IPv6)</span></div>
<div class="line">    4096,               <span class="comment">// OS receive buffer size</span></div>
<div class="line">    4096,               <span class="comment">// OS send buffer size</span></div>
<div class="line">    8192,               <span class="comment">// internal buffer size</span></div>
<div class="line">    <span class="keyword">true</span>,               <span class="comment">// reuse address (SO_REUSEADDR)</span></div>
<div class="line">    2000,               <span class="comment">// receive timeout (ms)</span></div>
<div class="line">    2000,               <span class="comment">// send timeout (ms)</span></div>
<div class="line">    <span class="keyword">false</span>,              <span class="comment">// blocking mode</span></div>
<div class="line">    <span class="keyword">true</span>,               <span class="comment">// dual stack enabled</span></div>
<div class="line">    <span class="keyword">true</span>                <span class="comment">// auto-bind</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">sock.joinGroup(<span class="stringliteral">&quot;ff12::1234&quot;</span>); <span class="comment">// Join multicast group explicitly</span></div>
<div class="ttc" id="anamespacejsocketpp_html"><div class="ttname"><a href="namespacejsocketpp.html">jsocketpp</a></div><div class="ttdoc">A C++ socket library providing Java-style networking interfaces.</div><div class="ttdef"><b>Definition</b> BufferView.hpp:16</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7937b05ccae7d059b4fcfa4b6383c75c" title="Join a multicast group on an optional interface (string-friendly).">joinGroup()</a> </dd>
<dd>
<a class="el" href="#gaf7317567ceae9b90967ec5a29d003af3" title="Leave a multicast group on an optional interface (string-friendly).">leaveGroup()</a> </dd>
<dd>
<a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948" title="Select the default outgoing interface for multicast transmissions.">setMulticastInterface()</a> </dd>
<dd>
<a class="el" href="#ga72172a10bc5ba13a908f31c791c90ec5" title="Set the time-to-live (TTL) / hop limit for outgoing multicast packets.">setTimeToLive()</a> </dd>
<dd>
<a class="el" href="#gab6608be5d1aff24ad5077f6ea9a9168a" title="Enable or disable multicast loopback for this socket.">setLoopbackMode()</a> </dd></dl>

</div>
</div>
<a id="gab67aad3e2d477982f19d17ab80607417" name="gab67aad3e2d477982f19d17ab80607417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67aad3e2d477982f19d17ab80607417">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> &amp; jsocketpp::DatagramSocket::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator (deleted) for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>. </p>
<p>The copy assignment operator is explicitly deleted to prevent assignment between <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> instances. This class manages a native socket file descriptor and internal buffers, which must have clear ownership semantics.</p>
<p>Allowing copy assignment would result in:</p><ul>
<li>Multiple objects referring to the same underlying socket</li>
<li>Risk of double-close or concurrent misuse</li>
<li>Broken RAII guarantees and undefined behavior</li>
</ul>
<p>This deletion enforces safe, move-only usage patterns consistent across the socket library.</p>
<dl class="section note"><dt>Note</dt><dd>Use move assignment (<span class="tt">operator=(<a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>&amp;&amp;)</span>) if you need to transfer ownership.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> a(12345);</div>
<div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> b;</div>
<div class="line">b = a; <span class="comment">// ❌ Compilation error (copy assignment is deleted)</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga38397874bcb62f889cb6fefa20b45ba6" title="Move assignment operator for DatagramSocket.">operator=(DatagramSocket&amp;&amp;)</a> noexcept </dd></dl>

</div>
</div>
<a id="ga38397874bcb62f889cb6fefa20b45ba6" name="ga38397874bcb62f889cb6fefa20b45ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38397874bcb62f889cb6fefa20b45ba6">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> &amp; jsocketpp::DatagramSocket::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>. </p>
<p>Releases any resources owned by this socket instance and transfers ownership from another <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> object (<span class="tt">rhs</span>). After the operation:</p>
<ul>
<li>This socket adopts the file descriptor, buffer, and internal state from <span class="tt">rhs</span></li>
<li>The source object is left in a valid but unspecified state (<span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>)</li>
<li>Existing resources in the destination socket are released via <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md665"></a>
Ownership Transferred</h3>
<ul>
<li>Native socket handle (<span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a></span>)</li>
<li>Local address metadata (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a87523b567e1963c683584ed19c1d6f84" title="Cached local socket address (set by bind()/UDP connect() via getsockname()).">_localAddr</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html#a471ce3677773b7fb9fb7766e247bc76f" title="Size in bytes of the cached local address stored in _localAddr.">_localAddrLen</a></span>)</li>
<li>Internal read buffer</li>
<li><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a> number (for tracking purposes)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md666"></a>
Notes</h3>
<dl class="section note"><dt>Note</dt><dd>This method is <span class="tt">noexcept</span> and safe to use in container scenarios (e.g., <span class="tt">std::vector&lt;<a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>&gt;</span>). </dd>
<dd>
After the move, <span class="tt">rhs</span> will be left in an uninitialized state and should not be used except for destruction or reassignment. </dd>
<dd>
If <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> throws during cleanup, the exception is suppressed to preserve noexcept guarantees.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="autotoc_md667"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> a(12345);</div>
<div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> b;</div>
<div class="line">b = std::move(a); <span class="comment">// b now owns the socket previously held by a</span></div>
<div class="line">assert(!a.isValid());</div>
<div class="line">assert(b.<a class="code hl_function" href="#gab33da807656e2ab920707d60605844f5">isValid</a>());</div>
<div class="ttc" id="agroup__udp_html_gab33da807656e2ab920707d60605844f5"><div class="ttname"><a href="#gab33da807656e2ab920707d60605844f5">jsocketpp::DatagramSocket::isValid</a></div><div class="ttdeci">bool isValid() const noexcept</div><div class="ttdoc">Checks whether the datagram socket is valid and ready for use.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:3955</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The source <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the updated <span class="tt">*this</span> object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab613123c8bf1aca6aec451b1140e2f82" title="Move constructor for DatagramSocket.">DatagramSocket(DatagramSocket&amp;&amp;)</a> noexcept </dd>
<dd>
<a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a>, <a class="el" href="#gab33da807656e2ab920707d60605844f5" title="Checks whether the datagram socket is valid and ready for use.">isValid()</a> </dd></dl>

</div>
</div>
<a id="gadfec1ac007add5eddeabee9c19a621cf" name="gadfec1ac007add5eddeabee9c19a621cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfec1ac007add5eddeabee9c19a621cf">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjsocketpp_1_1DatagramPacket.html">DatagramPacket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowResize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at the next UDP datagram without consuming it (single receive with MSG_PEEK). </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Copies up to <code class="param">packet.buffer.size()</code> bytes from the next datagram into <code class="param">packet.buffer</code> using a single kernel receive with MSG_PEEK so the datagram remains queued. The method:</p><ul>
<li>Never removes the datagram from the kernel queue.</li>
<li>Can optionally grow <code class="param">packet.buffer</code> before peeking when <code class="param">allowResize</code> is true: it first tries to probe the next datagram size and, if successful, resizes exactly to that size (clamped to MaxDatagramPayloadSafe); otherwise it uses a safe default.</li>
<li>Reports whether the datagram would be truncated via <span class="tt"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html#a830a7a1e1451dd93f23f44ddb063c4f3" title="Indicates whether datagram truncation occurred.">DatagramReadResult::truncated</a></span> and, when available, returns the full datagram size (<span class="tt">datagramSize</span>).</li>
<li>Does <b>not</b> update the internally tracked “last remote.” If you need that, do a real read.</li>
</ul>
<p>On POSIX, uses <span class="tt">recvmsg</span> with <span class="tt">MSG_PEEK</span>; on Linux it also sets <span class="tt">MSG_TRUNC</span> so the return value reflects the <b>full datagram size</b> even when the user buffer is smaller. On Windows, uses <span class="tt">recvfrom</span> with <span class="tt">MSG_PEEK</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Destination <a class="el" href="classjsocketpp_1_1DatagramPacket.html" title="Represents a UDP datagram packet, encapsulating both payload and addressing information.">DatagramPacket</a>. Its buffer is the peek target; when <code class="param">allowResize</code> is true and the size is known, it may be resized prior to the peek. When <span class="tt">opts.resolveNumeric</span> is true, <span class="tt">packet.address</span> and <span class="tt">packet.port</span> are filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowResize</td><td>When true and a size probe succeeds, grow <code class="param">packet.buffer</code> to fit exactly (clamped to MaxDatagramPayloadSafe). If false and the buffer is empty, the call throws. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options. <span class="tt">resolveNumeric</span> is honored; <span class="tt">recvFlags</span> is OR’ed with <span class="tt">MSG_PEEK</span>. Other fields (e.g., <span class="tt">updateLastRemote</span>) are ignored for peek (no side-effects).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> with:<ul>
<li><span class="tt">bytes</span> Number of bytes copied into <span class="tt">packet.buffer</span> (≤ its capacity),</li>
<li><span class="tt">datagramSize</span> Full datagram size when known (0 if unknown on this platform/path),</li>
<li><span class="tt">truncated</span> True if the datagram is larger than the provided capacity,</li>
<li><span class="tt">src</span>/<span class="tt">srcLen</span> Sender address (not stored as “last remote”).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; <span class="tt">packet.buffer</span> is empty and <code class="param">allowResize</code> is false; OS-level errors occur (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If the socket is non-blocking and no data is available (would-block), or a configured receive timeout elapses (platform-mapped).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>No datagram has been removed from the receive queue; <span class="tt">packet.buffer</span> contains a copy of the leading bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A zero-length datagram is valid: peeking it yields <span class="tt">bytes == 0</span> and does not indicate “connection closed.” </dd></dl>

</div>
</div>
<a id="ga24a48ca4f6711d89e0a89531b3b31807" name="ga24a48ca4f6711d89e0a89531b3b31807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24a48ca4f6711d89e0a89531b3b31807">&#9670;&#160;</a></span>read() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::enable_if_t&lt; <a class="el" href="namespacejsocketpp_1_1detail.html#a18306b136e94e5aaf18c6dd6d5f06f33">detail::is_fixed_buffer_v</a>&lt; T &gt;, int &gt; = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T jsocketpp::DatagramSocket::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read one UDP datagram into a fixed-size, contiguous byte container (zero allocation). </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A fixed-size, contiguous byte-like container (e.g., <code>std::array&lt;char, N&gt;</code>, <code>std::array&lt;unsigned char, N&gt;</code>, <code>std::array&lt;std::byte, N&gt;</code>) exposing <code>data()</code> and <code>size()</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Performs exactly one receive and copies up to <code>T::size()</code> bytes into the returned container. Trailing bytes remain value-initialized (typically zero) if the datagram is shorter. Truncation behavior is controlled by <code class="param">opts.errorOnTruncate:</code> </p><ul>
<li>If a reliable size probe is available and the datagram would not fit while <code class="param">opts.errorOnTruncate</code> is <code>true</code>, the function throws <b>before</b> reading so the datagram stays queued.</li>
<li>Otherwise, if truncation occurs and <code class="param">opts.errorOnTruncate</code> is <code>true</code>, it throws <b>after</b> the read.</li>
<li>If <code class="param">opts.errorOnTruncate</code> is <code>false</code>, the payload is truncated to <code>T::size()</code> without error. When <code class="param">opts.updateLastRemote</code> is <code>true</code>, the internally tracked “last remote” is updated. The requested copy length is always clamped to <code>MaxDatagramPayloadSafe</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options controlling preflight, truncation policy, and sender bookkeeping.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fixed-size container <code class="param">T</code> containing the received bytes in its leading elements. Any unused tail remains value-initialized.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open, on OS-level errors (message via <code>SocketErrorMessage</code>), or when truncation is disallowed by <code class="param">opts.errorOnTruncate</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the first <code>n</code> bytes of the returned container hold the payload, where <code>n</code> ≤ <code>T::size()</code>. If <code class="param">opts.updateLastRemote</code> is <code>true</code>, the internal “last remote” reflects the sender.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Prefer <code>opts.errorOnTruncate</code> = true with <code><a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd" title="Probe the exact size of the next datagram and size the receive accordingly.">DatagramReceiveMode::PreflightSize</a></code> for strict no-truncation behavior when supported by the platform.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 1500&gt; buf = sock.read&lt;std::array&lt;char,1500&gt;&gt;({</div>
<div class="line">    .errorOnTruncate = <span class="keyword">true</span>,</div>
<div class="line">    .mode = <a class="code hl_enumvalue" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd">DatagramReceiveMode::PreflightSize</a></div>
<div class="line">});</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga9f9e08f58d50d29e0f3fa9ccf83c1c97" name="ga9f9e08f58d50d29e0f3fa9ccf83c1c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f9e08f58d50d29e0f3fa9ccf83c1c97">&#9670;&#160;</a></span>read() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::enable_if_t&lt; <a class="el" href="namespacejsocketpp_1_1detail.html#aa46a9243f021ef54b04645f354feea30">detail::is_dynamic_buffer_v</a>&lt; T &gt;, int &gt; = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T jsocketpp::DatagramSocket::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>minCapacity</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__core.html#ga2fb9d73742801c62e90aeb505c618c43">DefaultDatagramReceiveSize</a></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read one UDP datagram into a dynamically resizable, contiguous byte container (zero-copy into caller storage). </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A contiguous, dynamically resizable byte-like container (e.g., std::string, std::vector&lt;char&gt;, std::vector&lt;std::byte&gt;, std::pmr::string) that provides <span class="tt">data()</span>, <span class="tt">size()</span>, and <span class="tt">resize()</span>.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates a buffer in <code class="param">T</code>, receives exactly one datagram into it, and then shrinks the container to the number of bytes actually received. Capacity is chosen as follows:</p><ul>
<li>Start from <code class="param">minCapacity</code>, clamped to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>. If <code class="param">minCapacity</code> is 0, it is treated as 1 to allow clean reception of zero-length datagrams.</li>
<li>If size preflight is requested (see <span class="tt">opts.mode</span>) or strict no-truncation is desired (<span class="tt">opts.errorOnTruncate ==
true</span>), the next datagram size is probed. On success, the container is grown to the <b>exact</b> datagram size (clamped to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>) to avoid truncation and extra copies.</li>
</ul>
<p>The actual copy is performed with a single kernel receive via <span class="tt">readInto(...)</span>. If truncation occurs and <span class="tt">opts.errorOnTruncate == true</span>, <span class="tt">readInto(...)</span> will throw according to its policy (either before the read, when size is known, or after the read otherwise). On success, the container is shrunk to the number of bytes received. No null terminator is appended automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options (preflight mode, truncation policy, sender bookkeeping). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minCapacity</td><td>Minimum initial capacity to allocate before reading. Clamped to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The container <code class="param">T</code> holding the received payload (size equals the number of bytes received).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open, OS-level errors occur (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>), or truncation is disallowed by <span class="tt">opts.errorOnTruncate</span> and would occur. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a configured receive timeout elapses before any datagram is received, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the returned container’s <span class="tt">size()</span> equals the number of bytes received; its content is the payload.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Prefer enabling strict no-truncation (<span class="tt">opts.errorOnTruncate = true</span>) together with size preflight (<span class="tt">opts.mode = <a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd" title="Probe the exact size of the next datagram and size the receive accordingly.">DatagramReceiveMode::PreflightSize</a></span>) when available, so overlarge datagrams are rejected <b>before</b> data is consumed.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code hl_struct" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> ro{};</div>
<div class="line">ro.<a class="code hl_variable" href="structjsocketpp_1_1DatagramReadOptions.html#a135ca2ae6fc586542956653b239f106b">errorOnTruncate</a> = <span class="keyword">true</span>;</div>
<div class="line">ro.<a class="code hl_variable" href="structjsocketpp_1_1DatagramReadOptions.html#aa343a807611fa5b42e9663c4890d4cca">mode</a> = <a class="code hl_enumvalue" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd">DatagramReceiveMode::PreflightSize</a>;</div>
<div class="line">std::string payload = sock.read&lt;std::string&gt;(ro); <span class="comment">// exact-size allocation when preflight succeeds</span></div>
<div class="ttc" id="astructjsocketpp_1_1DatagramReadOptions_html"><div class="ttname"><a href="structjsocketpp_1_1DatagramReadOptions.html">jsocketpp::DatagramReadOptions</a></div><div class="ttdoc">Options controlling a single UDP receive operation.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:136</div></div>
<div class="ttc" id="astructjsocketpp_1_1DatagramReadOptions_html_a135ca2ae6fc586542956653b239f106b"><div class="ttname"><a href="structjsocketpp_1_1DatagramReadOptions.html#a135ca2ae6fc586542956653b239f106b">jsocketpp::DatagramReadOptions::errorOnTruncate</a></div><div class="ttdeci">bool errorOnTruncate</div><div class="ttdoc">When true, the read fails if the incoming datagram would be truncated.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:220</div></div>
<div class="ttc" id="astructjsocketpp_1_1DatagramReadOptions_html_aa343a807611fa5b42e9663c4890d4cca"><div class="ttname"><a href="structjsocketpp_1_1DatagramReadOptions.html#aa343a807611fa5b42e9663c4890d4cca">jsocketpp::DatagramReadOptions::mode</a></div><div class="ttdeci">DatagramReceiveMode mode</div><div class="ttdoc">Datagram sizing policy to use during receive.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:143</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaa7f9cce85a502e58b8d86db95a8e0721" name="gaa7f9cce85a502e58b8d86db95a8e0721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7f9cce85a502e58b8d86db95a8e0721">&#9670;&#160;</a></span>read() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjsocketpp_1_1DatagramPacket.html">DatagramPacket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one UDP datagram into a <a class="el" href="classjsocketpp_1_1DatagramPacket.html" title="Represents a UDP datagram packet, encapsulating both payload and addressing information.">DatagramPacket</a> with optional growth/shrink and strict truncation policy. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Receives exactly one datagram and copies its payload into <code class="param">packet.buffer</code>. Behavior is governed by <code class="param">opts:</code> </p><ul>
<li>If a size preflight succeeds and <code class="param">opts.allowGrow</code> is true, the buffer may be resized up front (clamped to MaxDatagramPayloadSafe) to fit the datagram exactly.</li>
<li>If the buffer is smaller than the datagram and <code class="param">opts.errorOnTruncate</code> is true, the call throws before reading when size is known; otherwise it throws after the read if truncation occurred.</li>
<li>If <code class="param">opts.allowShrink</code> is true and no truncation occurred, the buffer may be resized down to the exact number of bytes received.</li>
<li>If <code class="param">opts.updateLastRemote</code> is true, the internally tracked “last remote” is updated to the sender.</li>
<li>If <code class="param">opts.resolveNumeric</code> is true, <code class="param">packet.address</code> and <code class="param">packet.port</code> are filled with the sender’s numeric host and port. Exactly one kernel receive is performed for the payload copy; all requests are clamped to MaxDatagramPayloadSafe.</li>
</ul>
<dl class="section user"><dt>Implementation notes</dt><dd>Uses a size probe when available (<a class="el" href="namespacejsocketpp_1_1internal.html#a592175a5a77f541b400879a5a4ca8978" title="Query the exact size of the next UDP datagram, if the platform can provide it.">internal::nextDatagramSize</a>). When the size is known and <code class="param">opts.errorOnTruncate</code> is true, the method fails early without consuming the datagram. The actual copy is performed with a single recv/recvmsg call via the internal backbone.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Destination datagram container. On input, its buffer capacity limits the copy unless <code class="param">opts.allowGrow</code> enables pre-read resizing. On success, the first <code>result.bytes</code> bytes contain the payload; address/port fields are updated when requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options controlling preflight, capacity growth/shrink, truncation policy, sender bookkeeping, and numeric address resolution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> with:<ul>
<li><code>bytes</code> Number of bytes copied into <code class="param">packet.buffer</code>.</li>
<li><code>datagramSize</code> Full datagram size when known (0 if unknown on this platform/path).</li>
<li><code>truncated</code> True if the datagram did not fully fit the destination buffer.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open, arguments are invalid, OS-level receive errors occur (message via SocketErrorMessage), or truncation is disallowed by <code class="param">opts.errorOnTruncate</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a configured receive timeout elapses before any datagram is received, or when the socket is non-blocking and no data is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, <code class="param">packet.buffer</code> holds the received payload (possibly resized per <code class="param">opts.allowShrink</code>). When <code class="param">opts.updateLastRemote</code> is true, the internal “last remote” reflects the sender.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When size cannot be probed and <code class="param">opts.errorOnTruncate</code> is false, oversized datagrams are truncated by the kernel and the tail is lost. Enable <code class="param">opts.errorOnTruncate</code> for strict no-truncation behavior.</dd></dl>
<dl class="section user"><dt>Example: grow to exact size, reject truncation</dt><dd><div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1DatagramPacket.html">DatagramPacket</a> pkt(0);</div>
<div class="line"><a class="code hl_struct" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> ro{};</div>
<div class="line">ro.<a class="code hl_variable" href="structjsocketpp_1_1DatagramReadOptions.html#a4253951c03481252f5c1e8928dcb1e9c">allowGrow</a> = <span class="keyword">true</span>;</div>
<div class="line">ro.<a class="code hl_variable" href="structjsocketpp_1_1DatagramReadOptions.html#a135ca2ae6fc586542956653b239f106b">errorOnTruncate</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="keyword">auto</span> r = sock.read(pkt, ro);</div>
<div class="line">std::string_view payload(pkt.buffer.data(), r.bytes);</div>
<div class="ttc" id="astructjsocketpp_1_1DatagramReadOptions_html_a4253951c03481252f5c1e8928dcb1e9c"><div class="ttname"><a href="structjsocketpp_1_1DatagramReadOptions.html#a4253951c03481252f5c1e8928dcb1e9c">jsocketpp::DatagramReadOptions::allowGrow</a></div><div class="ttdeci">bool allowGrow</div><div class="ttdoc">Whether the packet buffer may grow before receive (applies to DatagramPacket).</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:152</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example: fixed buffer, allow truncation</dt><dd><div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1DatagramPacket.html">DatagramPacket</a> small(512);</div>
<div class="line"><a class="code hl_struct" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> op{};</div>
<div class="line">op.<a class="code hl_variable" href="structjsocketpp_1_1DatagramReadOptions.html#a135ca2ae6fc586542956653b239f106b">errorOnTruncate</a> = <span class="keyword">false</span>;</div>
<div class="line"><span class="keyword">auto</span> r2 = sock.read(small, op);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd>readInto(std::span&lt;char&gt;, const DatagramReadOptions&amp;) for zero-allocation reads into caller buffers. </dd>
<dd>
<a class="el" href="#ga85c18071cceb1c0c679b7a444cfa9f65" title="Receive the next UDP datagram and return its payload as a string, attempting to avoid truncation.">readAvailable()</a> for returning the full datagram as a string (tries to avoid truncation). </dd>
<dd>
readAtMost(std::span&lt;char&gt;, const DatagramReadOptions&amp;) for single-recv best-effort reads without preflight. </dd>
<dd>
<a class="el" href="structjsocketpp_1_1DatagramReadOptions.html" title="Options controlling a single UDP receive operation.">DatagramReadOptions</a> for all configurable policies. </dd></dl>

</div>
</div>
<a id="gad5548c6a422e710410315dd6fb92788d" name="gad5548c6a422e710410315dd6fb92788d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5548c6a422e710410315dd6fb92788d">&#9670;&#160;</a></span>readAtMost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t DatagramSocket::readAtMost </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; char &gt;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read up to <code class="param">out.size()</code> bytes from the next UDP datagram into a caller-provided buffer (no allocation). </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Performs exactly one receive with <b>at-most</b> semantics:</p><ul>
<li>If the incoming datagram is smaller than <code class="param">out</code>, only that many bytes are written.</li>
<li>If the datagram is larger than <code class="param">out</code>, only the first <code class="param">out.size()</code> bytes are written and the remainder of the datagram is discarded by the kernel (standard UDP truncation).</li>
</ul>
<p>This API enforces a single <span class="tt">recv(from)</span> with no extra syscalls by using <span class="tt"><a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f" title="Do not probe the datagram size; call recvfrom() directly.">DatagramReceiveMode::NoPreflight</a></span> for the actual receive (any <span class="tt">opts.mode</span> setting is overridden for this method). On unconnected sockets, when <span class="tt">opts.updateLastRemote == true</span>, the internally tracked “last remote” endpoint is updated to the sender.</p>
<p>Blocking/timeout behavior:</p><ul>
<li>In blocking mode, the call waits until a datagram arrives or a configured receive timeout elapses. On timeout, <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> is thrown.</li>
<li>In non-blocking mode with no data available, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> is also thrown (would-block mapped).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Destination span receiving at most <span class="tt">out.size()</span> bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options; fields other than <span class="tt">mode</span> are honored. The effective mode is forced to <span class="tt"><a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f" title="Do not probe the datagram size; call recvfrom() directly.">DatagramReceiveMode::NoPreflight</a></span> to preserve single-recv semantics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually written to <code class="param">out</code> (0 if <code class="param">out</code> is empty).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open, on argument errors, or on other OS-level receive errors (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a configured receive timeout elapses before any datagram is received, or when the socket is non-blocking and no data is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly the returned number of bytes have been written to <code class="param">out</code>. For unconnected sockets, when <span class="tt">opts.updateLastRemote == true</span>, the internal “last remote” reflects the sender of this datagram.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function never allocates and never enlarges the caller’s buffer. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <code class="param">out</code> is smaller than the datagram, the tail of that datagram is dropped (cannot be recovered).</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 1500&gt; buf{};</div>
<div class="line"><a class="code hl_struct" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> ro{};</div>
<div class="line"><span class="keyword">const</span> std::size_t n = sock.readAtMost(std::span&lt;char&gt;(buf.data(), buf.size()), ro);</div>
<div class="line">std::string_view payload(buf.data(), n);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd>readAtMost(std::size_t) for a convenience overload that allocates and returns a string. </dd>
<dd>
readAvailable(std::span&lt;char&gt;, const DatagramReadOptions&amp;) when you need no-truncation semantics. </dd>
<dd>
readInto(void*, std::size_t, const DatagramReadOptions&amp;) for the lower-level primitive. </dd></dl>

</div>
</div>
<a id="ga4d5295306a17e8fdf4a6e00556e043b5" name="ga4d5295306a17e8fdf4a6e00556e043b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d5295306a17e8fdf4a6e00556e043b5">&#9670;&#160;</a></span>readAtMostWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DatagramSocket::readAtMostWithTimeout </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read up to <code class="param">n</code> bytes from the next UDP datagram, waiting up to <code class="param">timeoutMillis</code> for data. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Blocks the caller for at most <code class="param">timeoutMillis</code> milliseconds until the socket is readable, then performs a <b>single-recv, best-effort</b> read (no size preflight), returning up to <code class="param">n</code> bytes. If no datagram arrives before the timeout, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> is thrown.</p>
<p>Implementation notes:</p><ul>
<li>Uses a readiness wait (<span class="tt">poll</span> on POSIX, <span class="tt">WSAPoll</span> on Windows) so the per-call timeout does <b>not</b> alter the socket’s global receive-timeout state.</li>
<li>After readiness, delegates to the <span class="tt">readAtMost(std::size_t)</span> helper which enforces <span class="tt"><a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f" title="Do not probe the datagram size; call recvfrom() directly.">DatagramReceiveMode::NoPreflight</a></span> (one recv) and updates the internally tracked “last remote” on unconnected sockets.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Maximum number of bytes to return. If 0, returns an empty string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Timeout in milliseconds. Must be &gt;= 0. A value of 0 performs a non-blocking check and throws <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> if no data is ready.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bytes received (size ≤ <code class="param">n</code>). Marked <span class="tt">[[nodiscard]]</span> to avoid accidental loss.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open or an OS-level error occurs while waiting/receiving (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If no datagram becomes available within <code class="param">timeoutMillis</code>, or if the socket is non-blocking and no data is available at the moment of the call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. <code class="param">timeoutMillis</code> ≥ 0. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the returned string contains up to <code class="param">n</code> bytes from exactly one datagram; for unconnected sockets, the internal “last remote” reflects that datagram’s sender.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience overload. For zero-allocation reads with the same timeout behavior, wait for readability externally, then call <span class="tt"><a class="el" href="#gad5548c6a422e710410315dd6fb92788d" title="Read up to out.size() bytes from the next UDP datagram into a caller-provided buffer (no allocation).">readAtMost</a>(std::span&lt;char&gt;, ...)</span>. </dd></dl>

</div>
</div>
<a id="ga85c18071cceb1c0c679b7a444cfa9f65" name="ga85c18071cceb1c0c679b7a444cfa9f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c18071cceb1c0c679b7a444cfa9f65">&#9670;&#160;</a></span>readAvailable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DatagramSocket::readAvailable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive the next UDP datagram and return its payload as a string, attempting to avoid truncation. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Tries to return the <b>entire</b> next datagram:</p><ul>
<li>First attempts a size probe (e.g., via an OS-specific query). If successful, it allocates exactly that many bytes (clamped to MaxDatagramPayloadSafe) and performs a single receive.</li>
<li>If a reliable size probe is not available, it allocates a safe maximum buffer (MaxDatagramPayloadSafe) and performs exactly one receive. In this fallback, extremely large datagrams may be truncated.</li>
</ul>
<p>On unconnected sockets, the internally tracked “last remote” endpoint is updated to the sender. This convenience overload forces a single-recv path and <b>does not throw on truncation</b> in the rare fallback case (truncation is accepted and the received bytes are returned).</p>
<p>Blocking/timeout behavior:</p><ul>
<li>In blocking mode, waits until a datagram arrives or a configured receive timeout elapses, then throws <a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a>.</li>
<li>In non-blocking mode with no data available, also throws <a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a> (would-block mapped).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The payload of the next datagram as a string. May be empty for a zero-length datagram.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>On socket not open or other OS-level receive errors (message via SocketErrorMessage). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is received, or when the socket is non-blocking and no data is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the returned string contains the bytes received from exactly one datagram; for unconnected sockets, the internal “last remote” reflects the sender of that datagram.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For strict no-truncation behavior on all platforms, prefer the span overload readAvailable(std::span&lt;char&gt;, const DatagramReadOptions&amp;) and set opts.errorOnTruncate = true.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>On platforms without a reliable size probe, datagrams larger than MaxDatagramPayloadSafe will be truncated in this convenience API.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">[[nodiscard]] std::string payload = sock.readAvailable();</div>
<div class="line"><span class="comment">// use payload</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd>readAvailable(std::span&lt;char&gt;, const DatagramReadOptions&amp;) for zero-allocation reads with explicit policy. </dd>
<dd>
readAtMost(std::size_t) for best-effort single-recv reads without size preflight. </dd>
<dd>
read(DatagramPacket&amp;, const DatagramReadOptions&amp;) when you also need the sender address. </dd></dl>

</div>
</div>
<a id="ga4773cc4b2879db4c5d377505bdb761fa" name="ga4773cc4b2879db4c5d377505bdb761fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4773cc4b2879db4c5d377505bdb761fa">&#9670;&#160;</a></span>readAvailable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t DatagramSocket::readAvailable </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; char &gt;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive the entire next UDP datagram into a caller-provided buffer, with explicit truncation policy. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Attempts to copy the <b>full datagram</b> into <code class="param">out</code> in a single receive:</p><ul>
<li>When the platform can report the next datagram size up front, the method probes it and:<ul>
<li>If <span class="tt">opts.errorOnTruncate == true</span> and <code class="param">out</code> is smaller, it throws <b>before</b> reading (datagram remains queued).</li>
<li>Otherwise it performs exactly one receive sized appropriately to avoid redundant syscalls.</li>
</ul>
</li>
<li>When the platform cannot preflight size, it still performs <b>exactly one receive</b> into <code class="param">out</code> and:<ul>
<li>If truncation occurs and <span class="tt">opts.errorOnTruncate == true</span>, it throws <b>after</b> the read (the tail is lost).</li>
<li>If <span class="tt">opts.errorOnTruncate == false</span>, it returns the truncated bytes without error.</li>
</ul>
</li>
</ul>
<p>On unconnected sockets, when <span class="tt">opts.updateLastRemote == true</span>, the internally tracked “last remote” endpoint is updated to the sender of this datagram.</p>
<p>Blocking/timeout behavior:</p><ul>
<li>In blocking mode, waits until a datagram arrives or a configured receive timeout elapses, then throws <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span>.</li>
<li>In non-blocking mode with no data, also throws <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> (would-block mapped).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Destination span that will receive up to <span class="tt">out.size()</span> bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options controlling size preflight, truncation policy, sender bookkeeping, and receive flags. Other fields are honored; this method may override the internal mode to avoid redundant preflight after a successful probe.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written to <code class="param">out</code>. Equals the datagram size when not truncated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; on OS-level receive errors (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>); or when <code class="param">out</code> is too small and truncation is disallowed by <span class="tt">opts.errorOnTruncate</span>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly the returned number of bytes have been written to <code class="param">out</code>. For unconnected sockets, when <span class="tt">opts.updateLastRemote == true</span>, the internal “last remote” reflects the sender.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For strict no-truncation behavior across platforms, set <span class="tt">opts.errorOnTruncate = true</span>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <code class="param">out</code> is smaller than the datagram and truncation is allowed, the remainder of that datagram is irretrievably dropped by the kernel per UDP semantics.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 2048&gt; buf{};</div>
<div class="line"><a class="code hl_struct" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> ro{};</div>
<div class="line">ro.<a class="code hl_variable" href="structjsocketpp_1_1DatagramReadOptions.html#a135ca2ae6fc586542956653b239f106b">errorOnTruncate</a> = <span class="keyword">true</span>; <span class="comment">// enforce no-truncation policy</span></div>
<div class="line"><span class="keyword">const</span> std::size_t n = sock.readAvailable(std::span&lt;char&gt;(buf.data(), buf.size()), ro);</div>
<div class="line">std::string_view payload(buf.data(), n);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga85c18071cceb1c0c679b7a444cfa9f65" title="Receive the next UDP datagram and return its payload as a string, attempting to avoid truncation.">readAvailable()</a> for the convenience string-returning overload. </dd>
<dd>
readAtMost(std::span&lt;char&gt;, const DatagramReadOptions&amp;) for best-effort, single-recv reads. </dd>
<dd>
readInto(void*, std::size_t, const DatagramReadOptions&amp;) for the lower-level primitive. </dd></dl>

</div>
</div>
<a id="ga00b73bb3707d78fee4b4c11e2e139268" name="ga00b73bb3707d78fee4b4c11e2e139268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00b73bb3707d78fee4b4c11e2e139268">&#9670;&#160;</a></span>readExact() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::readExact </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; char &gt;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1ReadExactOptions.html">ReadExactOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Span overload of readExact(...) (derives <code class="param">exactLen</code> from <code class="param">out.size()</code>). </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>[out] Destination span; on success, exactly <span class="tt">out.size()</span> bytes are written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>[in] Exact-read policy and base receive options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a>; see pointer overload. </dd></dl>

</div>
</div>
<a id="gaf2d8f0e01d69beb2ae22383abf706e2c" name="gaf2d8f0e01d69beb2ae22383abf706e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2d8f0e01d69beb2ae22383abf706e2c">&#9670;&#160;</a></span>readExact() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> jsocketpp::DatagramSocket::readExact </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>exactLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1ReadExactOptions.html">ReadExactOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive exactly <code class="param">exactLen</code> bytes from a single UDP datagram into a contiguous byte container. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A contiguous byte-like container with <span class="tt">data()</span> and <span class="tt">size()</span>. Supported: dynamic (e.g., std::string, std::vector&lt;char/unsigned char/std::byte&gt;) and fixed-size (e.g., std::array&lt;char/unsigned char/std::byte, N&gt;).</td></tr>
  </table>
  </dd>
</dl>
<p>Enforces <b>exact-length</b> semantics on top of a single datagram receive, governed by <code class="param">opts:</code> </p><ul>
<li>If a reliable size probe is available and <span class="tt">opts.requireExact == true</span>, the call throws <b>before</b> reading unless the datagram size equals <code class="param">exactLen</code>. If the datagram is smaller and <span class="tt">opts.padIfSmaller == true</span>, the read proceeds and the tail is zero-padded after copying.</li>
<li>If size cannot be probed, one receive is performed. If the datagram is larger than <code class="param">exactLen</code> and <span class="tt">opts.requireExact == true</span>, the call throws <b>after</b> the read (the kernel truncated the payload). If the datagram is smaller than <code class="param">exactLen</code> and <span class="tt">opts.padIfSmaller == true</span>, the tail is zero-padded; otherwise the call throws due to size mismatch.</li>
<li>For dynamic containers:<ul>
<li>When <span class="tt">opts.autoResizeDynamic == true</span>, the container is resized to <code class="param">exactLen</code> up front (after validating <span class="tt">exactLen &lt;= <a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>).</li>
<li>When <span class="tt">opts.autoResizeDynamic == false</span>, the container must already have <span class="tt">size() &gt;= exactLen</span> or the call throws. After the read, the container is shrunk or extended to exactly <code class="param">exactLen</code> (new bytes are value-initialized).</li>
</ul>
</li>
<li>For fixed-size containers, <span class="tt">T::size()</span> must be <span class="tt">&gt;= exactLen</span>; the size cannot change.</li>
</ul>
<p>Internally delegates to the pointer/span <span class="tt">readExact(...)</span> overload, which performs at most one kernel receive, attempts early failure via a size probe, applies zero-padding when requested, updates “last remote” per options, and returns a <span class="tt"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a></span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Destination container. Must be contiguous and byte-sized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactLen</td><td>Required logical length (&gt; 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Exact-read policy (<span class="tt">requireExact</span>, <span class="tt">padIfSmaller</span>, <span class="tt">autoResizeDynamic</span>) and base options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a>:<ul>
<li><span class="tt">bytes</span> Number of bytes copied from the datagram (≤ <code class="param">exactLen</code>; equals <code class="param">exactLen</code> when padded or exact).</li>
<li><span class="tt">datagramSize</span> Full datagram size when known (0 if unknown on this platform/path).</li>
<li><span class="tt">truncated</span> True if the datagram was larger than <code class="param">exactLen</code> and the kernel truncated the payload.</li>
<li><span class="tt">src</span>/<span class="tt">srcLen</span> Sender address (when available).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; arguments are invalid; <span class="tt">exactLen</span> exceeds <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span> (when auto-resizing); the dynamic container is too small and auto-resize is disabled; OS receive errors occur (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>); or size policy fails (e.g., <span class="tt">requireExact</span> mismatch). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or in non-blocking mode with no data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is open; <code class="param">exactLen</code> &gt; 0. For fixed-size containers, <span class="tt">T::size() &gt;= exactLen</span>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, <code class="param">buffer</code> contains exactly <code class="param">exactLen</code> bytes of payload (plus zero-padding when applicable).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For strictly rejecting any truncation <em>before</em> reading, set <span class="tt">opts.base.mode =
<a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd" title="Probe the exact size of the next datagram and size the receive accordingly.">DatagramReceiveMode::PreflightSize</a></span> (this function will still attempt to probe when useful).</dd></dl>
<dl class="section user"><dt>Example: dynamic buffer, auto-resize, strict exact</dt><dd><div class="fragment"><div class="line">std::vector&lt;char&gt; buf;</div>
<div class="line"><a class="code hl_struct" href="structjsocketpp_1_1ReadExactOptions.html">ReadExactOptions</a> ex{};</div>
<div class="line">ex.<a class="code hl_variable" href="structjsocketpp_1_1ReadExactOptions.html#a0814487705ccc55adc3a25ae47fe9084">requireExact</a>      = <span class="keyword">true</span>;</div>
<div class="line">ex.<a class="code hl_variable" href="structjsocketpp_1_1ReadExactOptions.html#a1b3dca16ac543ff80a42b9468fd11759">padIfSmaller</a>      = <span class="keyword">false</span>;</div>
<div class="line">ex.<a class="code hl_variable" href="structjsocketpp_1_1ReadExactOptions.html#ade6b57f1416832fc093804eb907ce3cf">autoResizeDynamic</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="keyword">auto</span> r = sock.readExact(buf, 1024, ex); <span class="comment">// buf.size() becomes 1024 on success</span></div>
<div class="ttc" id="astructjsocketpp_1_1ReadExactOptions_html"><div class="ttname"><a href="structjsocketpp_1_1ReadExactOptions.html">jsocketpp::ReadExactOptions</a></div><div class="ttdoc">Policy for enforcing an exact-byte receive on a single UDP datagram.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:327</div></div>
<div class="ttc" id="astructjsocketpp_1_1ReadExactOptions_html_a0814487705ccc55adc3a25ae47fe9084"><div class="ttname"><a href="structjsocketpp_1_1ReadExactOptions.html#a0814487705ccc55adc3a25ae47fe9084">jsocketpp::ReadExactOptions::requireExact</a></div><div class="ttdeci">bool requireExact</div><div class="ttdoc">Controls whether the datagram size must match exactly.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:351</div></div>
<div class="ttc" id="astructjsocketpp_1_1ReadExactOptions_html_a1b3dca16ac543ff80a42b9468fd11759"><div class="ttname"><a href="structjsocketpp_1_1ReadExactOptions.html#a1b3dca16ac543ff80a42b9468fd11759">jsocketpp::ReadExactOptions::padIfSmaller</a></div><div class="ttdeci">bool padIfSmaller</div><div class="ttdoc">Controls zero-padding behavior for undersized datagrams.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:363</div></div>
<div class="ttc" id="astructjsocketpp_1_1ReadExactOptions_html_ade6b57f1416832fc093804eb907ce3cf"><div class="ttname"><a href="structjsocketpp_1_1ReadExactOptions.html#ade6b57f1416832fc093804eb907ce3cf">jsocketpp::ReadExactOptions::autoResizeDynamic</a></div><div class="ttdeci">bool autoResizeDynamic</div><div class="ttdoc">Controls automatic resizing of dynamic containers.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:387</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example: fixed buffer, allow padding</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 2048&gt; buf{};</div>
<div class="line"><a class="code hl_struct" href="structjsocketpp_1_1ReadExactOptions.html">ReadExactOptions</a> ex{};</div>
<div class="line">ex.<a class="code hl_variable" href="structjsocketpp_1_1ReadExactOptions.html#a0814487705ccc55adc3a25ae47fe9084">requireExact</a> = <span class="keyword">true</span>;</div>
<div class="line">ex.<a class="code hl_variable" href="structjsocketpp_1_1ReadExactOptions.html#a1b3dca16ac543ff80a42b9468fd11759">padIfSmaller</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="keyword">auto</span> r = sock.readExact(buf, 1500, ex); <span class="comment">// tail zero-padded up to 1500 bytes</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gab34fd67ebc17563f286dde70ba456cf9" name="gab34fd67ebc17563f286dde70ba456cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab34fd67ebc17563f286dde70ba456cf9">&#9670;&#160;</a></span>readExact() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::readExact </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>exactLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1ReadExactOptions.html">ReadExactOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive exactly <code class="param">exactLen</code> bytes from a single UDP datagram into <code class="param">buffer</code>, with strict policy control. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Attempts to ensure the caller ends up with exactly <code class="param">exactLen</code> bytes in <code class="param">buffer</code> from the <b>next datagram</b>:</p><ul>
<li>If a size probe succeeds and <span class="tt">opts.requireExact == true</span>, the call <b>throws before reading</b> unless the datagram size equals <code class="param">exactLen</code>. If the datagram is smaller and <span class="tt">opts.padIfSmaller == true</span>, the read proceeds and the tail is zero-padded after copying.</li>
<li>If a size probe is unavailable, a single receive is performed. If the datagram is larger than <code class="param">exactLen</code> and <span class="tt">opts.requireExact == true</span>, the call throws <b>after</b> the read (the kernel truncated the payload). If the datagram is smaller than <code class="param">exactLen</code> and <span class="tt">opts.padIfSmaller == true</span>, the tail is zero-padded; otherwise the call throws due to size mismatch.</li>
<li><span class="tt">opts.base.updateLastRemote</span> controls whether the internally tracked “last remote” is updated.</li>
</ul>
<p>All requests are clamped to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>. This function performs exactly one kernel receive for the payload copy (no dummy read).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>[out] Destination buffer receiving exactly <code class="param">exactLen</code> bytes on success. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactLen</td><td>[in] Required logical length. Must be &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>[in] Exact-read policy (<span class="tt">requireExact</span>, <span class="tt">padIfSmaller</span>) and base receive options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> with:<ul>
<li><span class="tt">bytes</span> Number of bytes copied (equals min(datagramSize, exactLen)).</li>
<li><span class="tt">datagramSize</span> Full datagram size when known (0 if unknown on this platform/path).</li>
<li><span class="tt">truncated</span> True if the datagram was larger than <code class="param">exactLen</code> and the kernel truncated the payload.</li>
<li><span class="tt">src</span>/<span class="tt">srcLen</span> Sender address information (when available).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open, arguments are invalid, OS errors occur (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>), or the size policy fails (e.g., mismatch with <span class="tt">requireExact</span>, or undersize without <span class="tt">padIfSmaller</span>). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or in non-blocking mode with no data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is open; <code class="param">buffer</code> is non-null; <code class="param">exactLen</code> &gt; 0. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, <code class="param">buffer</code> holds exactly <code class="param">exactLen</code> bytes (payload plus optional zero-padding).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For strictly rejecting any truncation <b>before</b> reading, prefer <span class="tt">opts.base.mode =
<a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd" title="Probe the exact size of the next datagram and size the receive accordingly.">DatagramReceiveMode::PreflightSize</a></span> (or leave <span class="tt">NoPreflight</span>; this method will still attempt to probe when useful). </dd></dl>

</div>
</div>
<a id="ga7fbd62107244e308dc0436f11fae7dad" name="ga7fbd62107244e308dc0436f11fae7dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fbd62107244e308dc0436f11fae7dad">&#9670;&#160;</a></span>readFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> jsocketpp::DatagramSocket::readFrom </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>senderAddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> *</td>          <td class="paramname"><span class="paramname"><em>senderPort</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read one UDP datagram into a caller-provided byte container and optionally return the sender address/port. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A contiguous byte container with <span class="tt">data()</span> and <span class="tt">size()</span>. Supports both dynamic (e.g., <span class="tt">std::string</span>, <span class="tt">std::vector&lt;char&gt;</span>) and fixed-size (e.g., <span class="tt">std::array&lt;char, N&gt;</span>) containers.</td></tr>
  </table>
  </dd>
</dl>
<p>Receives exactly one datagram and copies it into <code class="param">buffer</code>. If <code class="param">T</code> is dynamically resizable and a reliable size probe is available, the function <b>grows</b> <code class="param">buffer</code> up front to the exact datagram size (clamped to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>) to avoid truncation and extra copies. Truncation behavior follows <code class="param">opts.errorOnTruncate:</code> </p><ul>
<li>If a size probe succeeds and the datagram would not fit:<ul>
<li>Dynamic container: the buffer is grown automatically (up to the safety cap).</li>
<li>Fixed container: if <span class="tt">opts.errorOnTruncate == true</span>, the function throws <b>before</b> reading (datagram remains queued); otherwise it will be truncated.</li>
</ul>
</li>
<li>If no size probe is available, a single receive is performed. If truncation occurs and <span class="tt">opts.errorOnTruncate == true</span>, the function throws <b>after</b> the read.</li>
</ul>
<p>When <code class="param">senderAddr</code> and/or <code class="param">senderPort</code> are non-null, the function resolves the numeric host and port of the datagram’s sender and writes them to the provided outputs. This works for both connected and unconnected sockets. If you only need the sender information without copying the payload into a <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramPacket.html" title="Represents a UDP datagram packet, encapsulating both payload and addressing information.">DatagramPacket</a></span>, this overload is convenient and zero-alloc for fixed buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Caller-provided destination container. For dynamic containers, it may be resized to fit the datagram. For fixed containers, its capacity limits the copy. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">senderAddr</td><td>Optional. Receives the sender’s numeric IP string (e.g., "203.0.113.10"). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">senderPort</td><td>Optional. Receives the sender’s port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options controlling preflight, truncation policy, and bookkeeping.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> with:<ul>
<li><span class="tt">bytes</span> — number of bytes copied into <code class="param">buffer</code>,</li>
<li><span class="tt">datagramSize</span> — full datagram size when known (0 if unknown on this platform/path),</li>
<li><span class="tt">truncated</span> — <span class="tt">true</span> if the datagram did not fully fit in <code class="param">buffer</code>,</li>
<li><span class="tt">src</span> / <span class="tt">srcLen</span> — sender socket address (when available in the build; included in this result type).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open, OS-level receive errors occur (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>), or truncation is disallowed by <span class="tt">opts.errorOnTruncate</span> and would occur. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd>
<dd>
For fixed-size containers, <span class="tt">T::size() &gt; 0</span>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the first <span class="tt">result.bytes</span> elements of <code class="param">buffer</code> contain the payload. If <code class="param">senderAddr</code> and/or <code class="param">senderPort</code> are provided, they contain the numeric sender address and port.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requests are clamped to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>. For strict no-truncation behavior across platforms, prefer <span class="tt">opts.errorOnTruncate = true</span>; when available, a preflight size probe avoids consuming the datagram on failure.</dd></dl>
<dl class="section user"><dt>Example: dynamic buffer (auto-grow) and capture sender</dt><dd><div class="fragment"><div class="line">std::vector&lt;char&gt; buf;</div>
<div class="line">std::string fromIp;</div>
<div class="line"><a class="code hl_typedef" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> fromPort{};</div>
<div class="line"><a class="code hl_struct" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> ro{};</div>
<div class="line">ro.<a class="code hl_variable" href="structjsocketpp_1_1DatagramReadOptions.html#a135ca2ae6fc586542956653b239f106b">errorOnTruncate</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="keyword">auto</span> r = sock.readFrom(buf, &amp;fromIp, &amp;fromPort, ro);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example: fixed buffer (truncate allowed)</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 1024&gt; buf{};</div>
<div class="line"><span class="keyword">auto</span> r = sock.readFrom(buf, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, <a class="code hl_struct" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a>{ .errorOnTruncate = <span class="keyword">false</span> });</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga585e06116cd0669c881c4bb8ee3ef99b" name="ga585e06116cd0669c881c4bb8ee3ef99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585e06116cd0669c881c4bb8ee3ef99b">&#9670;&#160;</a></span>readInto() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::readInto </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; char &gt;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read one UDP datagram into a caller-provided span (zero allocation) with explicit truncation policy. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Performs exactly one receive to copy the next datagram into <code class="param">out</code>, applying the policies in <code class="param">opts:</code> </p><ul>
<li>If <span class="tt">opts.mode != <a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f" title="Do not probe the datagram size; call recvfrom() directly.">DatagramReceiveMode::NoPreflight</a></span> or <span class="tt">opts.errorOnTruncate == true</span>, the method attempts to probe the next datagram size first. When the size is known and the span is too small and <span class="tt">opts.errorOnTruncate == true</span>, it throws <b>before</b> reading so the datagram remains queued.</li>
<li>If size cannot be probed (platform/path) or <span class="tt">opts.mode == NoPreflight</span>, a single receive is performed. If truncation occurs and <span class="tt">opts.errorOnTruncate == true</span>, it throws <b>after</b> the read (the tail is lost by UDP semantics). If <span class="tt">opts.errorOnTruncate == false</span>, the truncated bytes are returned.</li>
<li>When <span class="tt">opts.updateLastRemote == true</span>, the internally tracked “last remote” endpoint is updated. The request size is clamped to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>. If <span class="tt">out.size() == 0</span>, the function returns immediately.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Destination span receiving up to <span class="tt">out.size()</span> bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options controlling preflight, truncation policy, and “last remote” updates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> with:<ul>
<li><span class="tt">bytes</span> — number of bytes copied into <code class="param">out</code>,</li>
<li><span class="tt">datagramSize</span> — full datagram size when known (0 if unknown on this platform/path),</li>
<li><span class="tt">truncated</span> — <span class="tt">true</span> if the datagram did not fully fit in <code class="param">out</code>.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open, OS-level receive errors occur (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>), or truncation is disallowed by <span class="tt">opts.errorOnTruncate</span>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the first <span class="tt">result.bytes</span> elements of <code class="param">out</code> contain the payload. When <span class="tt">opts.updateLastRemote == true</span>, the internal “last remote” reflects the sender.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Prefer this overload for <b>zero-allocation</b> reads. For pointer-based interop with legacy APIs, use <span class="tt"><a class="el" href="#gada22ab72b367e5123600bb3276422940" title="Read one UDP datagram into a caller-provided buffer with explicit truncation policy.">readInto</a>(void*, std::size_t, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html" title="Options controlling a single UDP receive operation.">DatagramReadOptions</a>&amp;)</span>. </dd>
<dd>
For strict no-truncation behavior across platforms, set <span class="tt">opts.errorOnTruncate = true</span> and (optionally) <span class="tt">opts.mode = <a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd" title="Probe the exact size of the next datagram and size the receive accordingly.">DatagramReceiveMode::PreflightSize</a></span>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 2048&gt; buf{};</div>
<div class="line"><a class="code hl_struct" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> ro{};</div>
<div class="line">ro.<a class="code hl_variable" href="structjsocketpp_1_1DatagramReadOptions.html#a135ca2ae6fc586542956653b239f106b">errorOnTruncate</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="keyword">auto</span> res = sock.readInto(std::span&lt;char&gt;(buf.data(), buf.size()), ro);</div>
<div class="line">std::string_view payload(buf.data(), res.bytes);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd>readInto(void*, std::size_t, const DatagramReadOptions&amp;) for the pointer overload. </dd>
<dd>
read(DatagramPacket&amp;, const DatagramReadOptions&amp;) when you also need the sender address. </dd>
<dd>
<a class="el" href="#ga85c18071cceb1c0c679b7a444cfa9f65" title="Receive the next UDP datagram and return its payload as a string, attempting to avoid truncation.">readAvailable()</a> for returning the entire datagram as a string. </dd>
<dd>
readAtMost(std::span&lt;char&gt;, const DatagramReadOptions&amp;) for best-effort single-recv reads. </dd></dl>

</div>
</div>
<a id="gada22ab72b367e5123600bb3276422940" name="gada22ab72b367e5123600bb3276422940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada22ab72b367e5123600bb3276422940">&#9670;&#160;</a></span>readInto() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::readInto </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read one UDP datagram into a caller-provided buffer with explicit truncation policy. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Performs exactly one receive to copy the next datagram into <code class="param">buffer</code>, applying the policies in <code class="param">opts:</code> </p><ul>
<li>If <span class="tt">opts.mode != <a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f" title="Do not probe the datagram size; call recvfrom() directly.">DatagramReceiveMode::NoPreflight</a></span> or <span class="tt">opts.errorOnTruncate == true</span>, the method attempts to probe the next datagram size first. When the size is known and the buffer is too small and <span class="tt">opts.errorOnTruncate == true</span>, it throws <b>before</b> reading so the datagram remains queued.</li>
<li>If size cannot be probed (platform/path) or <span class="tt">opts.mode == NoPreflight</span>, a single receive is performed. If truncation occurs and <span class="tt">opts.errorOnTruncate == true</span>, it throws <b>after</b> the read (the tail is lost by UDP semantics). If <span class="tt">opts.errorOnTruncate == false</span>, the truncated bytes are returned.</li>
<li>When <span class="tt">opts.updateLastRemote == true</span>, the internally tracked “last remote” endpoint is updated from the sender address of this datagram. The request size is clamped to <span class="tt"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a></span>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Caller-provided destination buffer receiving up to <code class="param">len</code> bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Capacity of <code class="param">buffer</code> in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options controlling preflight, truncation policy, and “last remote” updates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> with:<ul>
<li><span class="tt">bytes</span> — number of bytes copied into <code class="param">buffer</code>,</li>
<li><span class="tt">datagramSize</span> — full datagram size when known (0 if unknown on this platform/path),</li>
<li><span class="tt">truncated</span> — <span class="tt">true</span> if the datagram did not fully fit in <code class="param">buffer</code>.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open, arguments are invalid, OS-level receive errors occur (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>), or truncation is disallowed by <span class="tt">opts.errorOnTruncate</span>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. If <code class="param">buffer</code> is non-null, <code class="param">len</code> &gt; 0. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the first <span class="tt">result.bytes</span> bytes of <code class="param">buffer</code> contain the payload. When <span class="tt">opts.updateLastRemote == true</span>, the internal “last remote” reflects the sender.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Prefer the span overload for zero-allocation ergonomics: <span class="tt"><a class="el" href="#gada22ab72b367e5123600bb3276422940" title="Read one UDP datagram into a caller-provided buffer with explicit truncation policy.">readInto</a>(std::span&lt;char&gt;, const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html" title="Options controlling a single UDP receive operation.">DatagramReadOptions</a>&amp;)</span>. </dd>
<dd>
For strict no-truncation behavior across platforms, set <span class="tt">opts.errorOnTruncate = true</span> and (optionally) <span class="tt">opts.mode = <a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd" title="Probe the exact size of the next datagram and size the receive accordingly.">DatagramReceiveMode::PreflightSize</a></span>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 2048&gt; buf{};</div>
<div class="line"><a class="code hl_struct" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> ro{};</div>
<div class="line">ro.<a class="code hl_variable" href="structjsocketpp_1_1DatagramReadOptions.html#a135ca2ae6fc586542956653b239f106b">errorOnTruncate</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="keyword">auto</span> res = sock.readInto(buf.data(), buf.size(), ro);</div>
<div class="line">std::string_view payload(buf.data(), res.bytes);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd>readInto(std::span&lt;char&gt;, const DatagramReadOptions&amp;) for the span overload. </dd>
<dd>
read(DatagramPacket&amp;, const DatagramReadOptions&amp;) when you also need the sender address. </dd>
<dd>
<a class="el" href="#ga85c18071cceb1c0c679b7a444cfa9f65" title="Receive the next UDP datagram and return its payload as a string, attempting to avoid truncation.">readAvailable()</a> for returning the entire datagram as a string. </dd>
<dd>
readAtMost(std::span&lt;char&gt;, const DatagramReadOptions&amp;) for best-effort single-recv reads. </dd></dl>

</div>
</div>
<a id="ga30912969f0808f064aaeee9a79025f41" name="ga30912969f0808f064aaeee9a79025f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30912969f0808f064aaeee9a79025f41">&#9670;&#160;</a></span>readIntoBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t DatagramSocket::readIntoBuffer </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga2124eae8cec6709a67be265f14da3bdd">DatagramReceiveMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>recvFlags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr_storage *</td>          <td class="paramname"><span class="paramname"><em>outSrc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *</td>          <td class="paramname"><span class="paramname"><em>outSrcLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *</td>          <td class="paramname"><span class="paramname"><em>outDatagramSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>outTruncated</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level, single-recv primitive that copies one UDP datagram into a caller buffer. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Performs exactly one kernel receive. On POSIX, uses <span class="tt">recvmsg</span> and sets <span class="tt">MSG_TRUNC</span> (on Linux) to obtain precise truncation signaling; on Linux the return value with <span class="tt">MSG_TRUNC</span> reflects the full datagram size even when the buffer is smaller. When a size preflight is requested via <code class="param">mode</code>, the next datagram size is queried (if supported) and the requested copy length is clamped accordingly. This function is policy-free: it never throws solely because truncation happened; instead it reports size and truncation through <code class="param">outDatagramSz</code> and <code class="param">outTruncated</code> so higher-level APIs can decide.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>Destination buffer receiving up to <code class="param">len</code> bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Capacity of <code class="param">buf</code> in bytes; the function never writes more than this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Receive mode. If not <code><a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f" title="Do not probe the datagram size; call recvfrom() directly.">DatagramReceiveMode::NoPreflight</a></code>, a size probe is attempted to refine the requested copy length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvFlags</td><td>Flags passed to the underlying receive. May be OR’ed with platform flags internally (e.g., <span class="tt">MSG_TRUNC</span> on Linux). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outSrc</td><td>Optional. Sender address as returned by the kernel. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outSrcLen</td><td>Optional. On input, capacity of <code class="param">outSrc</code>. On output, actual size written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outDatagramSz</td><td>Optional. Full datagram size when known (preflight or Linux+<span class="tt">MSG_TRUNC</span>); otherwise set to the copied byte count (best effort). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outTruncated</td><td>Optional. Set to <code>true</code> if the datagram did not fully fit in <code class="param">buf</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually written to <code class="param">buf</code> (≤ <code class="param">len</code>). May be 0 for a zero-length datagram.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>On invalid arguments, socket not open, or other OS-level errors (message via <code>SocketErrorMessage</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a configured receive timeout elapses before any datagram is received, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket handle is valid (open). If <code class="param">outSrc</code> is non-null, <code class="param">outSrcLen</code> points to a writable size. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly the returned number of bytes are stored in <code class="param">buf</code>. When provided, <code class="param">outSrc/<code class="param">outSrcLen</code> reflect</code> the sender; <code class="param">outDatagramSz</code> and <code class="param">outTruncated</code> report size and truncation status.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The requested copy length is always clamped to <code>MaxDatagramPayloadSafe</code> for safety. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>On platforms without a reliable size probe and without <span class="tt">MSG_TRUNC</span> semantics, truncation detection may be heuristic (e.g., a full buffer implies possible truncation).</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 2048&gt; buf{};</div>
<div class="line">sockaddr_storage src{};</div>
<div class="line">socklen_t srcLen = <span class="keyword">sizeof</span>(src);</div>
<div class="line">std::size_t pktSize = 0;</div>
<div class="line"><span class="keywordtype">bool</span> wasTrunc = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::size_t n = sock.readIntoBuffer(buf.data(), buf.size(),</div>
<div class="line">                                          <a class="code hl_enumvalue" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f">DatagramReceiveMode::NoPreflight</a>,</div>
<div class="line">                                          0, &amp;src, &amp;srcLen, &amp;pktSize, &amp;wasTrunc);</div>
<div class="line"><span class="comment">// n bytes are in buf; pktSize is the full size when known; wasTrunc indicates truncation.</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gae739db534b15bd856c9d83ac020a7796" name="gae739db534b15bd856c9d83ac020a7796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae739db534b15bd856c9d83ac020a7796">&#9670;&#160;</a></span>readIntoExact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t DatagramSocket::readIntoExact </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strict exact-length UDP receive into a caller-provided buffer (single datagram). </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Copies the next datagram into <code class="param">buffer</code> and enforces that the datagram size matches <code class="param">len</code> exactly. The method prefers an early, non-destructive failure: it attempts to probe the next datagram size first and throws before reading if the size is not exactly <code class="param">len</code>. If a probe is not available on the platform, it performs one receive and throws afterward if the payload was truncated or shorter than <code class="param">len</code>.</p>
<p>Behavior is equivalent to calling <span class="tt"><a class="el" href="#gab34fd67ebc17563f286dde70ba456cf9" title="Receive exactly exactLen bytes from a single UDP datagram into buffer, with strict policy control.">readExact</a>(buffer, len, <a class="el" href="structjsocketpp_1_1ReadExactOptions.html" title="Policy for enforcing an exact-byte receive on a single UDP datagram.">ReadExactOptions</a>{ .requireExact = true,
.padIfSmaller = false, .base.mode = <a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda0882ede215c2d76da1b71837ab80e9bd" title="Probe the exact size of the next datagram and size the receive accordingly.">DatagramReceiveMode::PreflightSize</a> })</span>. A single kernel receive is used for the payload copy; no allocation occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>[out] Destination buffer that must have capacity for exactly <code class="param">len</code> bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>[in] Required length in bytes; the datagram must be exactly this size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written to <code class="param">buffer</code>. On success this equals <code class="param">len</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; arguments are invalid; OS-level receive errors occur (message via SocketErrorMessage); or the datagram size does not equal <code class="param">len</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a configured receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. <code class="param">buffer</code> is non-null. <code class="param">len</code> &gt; 0. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <code class="param">len</code> bytes have been written to <code class="param">buffer</code> and the datagram queue advanced by one. On unconnected sockets, the internal “last remote” reflects the sender.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For variable-length reads or padding behavior, use the more general <span class="tt"><a class="el" href="#gab34fd67ebc17563f286dde70ba456cf9" title="Receive exactly exactLen bytes from a single UDP datagram into buffer, with strict policy control.">readExact</a>(void*, std::size_t, const <a class="el" href="structjsocketpp_1_1ReadExactOptions.html" title="Policy for enforcing an exact-byte receive on a single UDP datagram.">ReadExactOptions</a>&amp;)</span> overload. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the platform cannot preflight size, an oversized datagram will be consumed by the kernel and this function will throw after the read; the excess bytes are lost per UDP semantics.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 512&gt; buf{};</div>
<div class="line"><span class="comment">// Expect exactly 512 bytes in the next datagram; throw otherwise.</span></div>
<div class="line"><span class="keyword">const</span> std::size_t n = sock.readIntoExact(buf.data(), buf.size());</div>
<div class="line"><span class="comment">// n == 512 on success</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gabac0f0e22e72fa908fa49e44302c2a12" name="gabac0f0e22e72fa908fa49e44302c2a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabac0f0e22e72fa908fa49e44302c2a12">&#9670;&#160;</a></span>readPrefixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &amp;&amp;std::is_unsigned_v&lt; T &gt; &amp;&amp;std::is_trivially_copyable_v&lt; T &gt;, int &gt; = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string jsocketpp::DatagramSocket::readPrefixed </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>maxPayloadLen</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89">MaxDatagramPayloadSafe</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::endian</td>          <td class="paramname"><span class="paramname"><em>prefixEndian</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::endian::big</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a length-prefixed UDP datagram and return the payload (prefix type <code class="param">T</code>). </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Unsigned, trivially copyable integer type used for the length prefix (e.g., <code>uint16_t</code>, <code>uint32_t</code>, <code>uint64_t</code>).</td></tr>
  </table>
  </dd>
</dl>
<p>Expects the next datagram’s payload to begin with a <code class="param">T-sized</code> length field followed by exactly that many payload bytes. The prefix is interpreted in the specified byte order and validated against the actual datagram size. The function:</p><ul>
<li>Reads the <b>entire</b> datagram (throws on truncation) using a single receive.</li>
<li>Verifies that the datagram size is at least <code>sizeof(T)</code> and that the prefix equals the remaining payload length.</li>
<li>Enforces <code class="param">maxPayloadLen</code> to guard against oversized frames.</li>
</ul>
<p>Works for connected and unconnected sockets; on unconnected sockets the internally tracked “last remote” endpoint is updated to the sender.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPayloadLen</td><td>Maximum allowed payload length (not counting the prefix). Clamped to <code>MaxDatagramPayloadSafe</code>. Use to prevent pathological allocations. Defaults to <code>MaxDatagramPayloadSafe</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixEndian</td><td>Byte order of the length prefix. Defaults to big-endian.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decoded payload bytes as a <code>std::string</code>. Marked <code></code>[[nodiscard]].</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; the datagram is smaller than <code>sizeof(T)</code>; the prefix/payload sizes mismatch; the payload exceeds <code class="param">maxPayloadLen</code>; or on OS-level receive errors (message via <code>SocketErrorMessage</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the returned string contains exactly the bytes declared by the prefix.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function throws rather than silently truncating. If you want best-effort reads, use <code>readAtMost(...)</code> instead.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="comment">// Datagram format: [u32_be length][payload...]</span></div>
<div class="line">std::string payload = sock.readPrefixed&lt;std::uint32_t&gt;();</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gae1222e5ce7f8c5e48f8fd997f4b57b42" name="gae1222e5ce7f8c5e48f8fd997f4b57b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1222e5ce7f8c5e48f8fd997f4b57b42">&#9670;&#160;</a></span>readv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::readv </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter-gather receive: read one UDP datagram into multiple non-contiguous buffers. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Copies the next datagram across the spans in <code class="param">buffers</code> using a single kernel receive:</p><ul>
<li>Computes total capacity = sum of buffer sizes (clamped to MaxDatagramPayloadSafe).</li>
<li>If size preflight succeeds and <span class="tt">opts.errorOnTruncate == true</span>, throws <b>before</b> reading when the datagram would not fit. Otherwise performs exactly one receive and reports truncation.</li>
<li>On POSIX, uses <span class="tt">recvmsg</span> with <span class="tt">iovec[]</span> (Linux adds <span class="tt">MSG_TRUNC</span> to learn the full size even when truncated). On Windows, uses <span class="tt">WSARecvFrom</span> with <span class="tt">WSABUF[]</span>.</li>
<li>On unconnected sockets, when <span class="tt">opts.updateLastRemote == true</span>, updates the internally tracked “last remote” to the sender of this datagram.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffers</td><td>Scatter list of writable buffers; each entry must have a valid pointer when its size &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options controlling preflight, truncation policy, sender bookkeeping, and flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> { bytes, datagramSize, truncated, src, srcLen }.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; buffer arguments are invalid; OS-level errors occur (message via SocketErrorMessage); or truncation is disallowed by <span class="tt">opts.errorOnTruncate</span>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the first <span class="tt">result.bytes</span> bytes have been written across the buffers in order. For unconnected sockets, when <span class="tt">opts.updateLastRemote == true</span>, the internal “last remote” reflects the sender.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method never allocates payload storage; it only references your buffers. For single-buffer cases, prefer <span class="tt"><a class="el" href="#gada22ab72b367e5123600bb3276422940" title="Read one UDP datagram into a caller-provided buffer with explicit truncation policy.">readInto</a>(std::span&lt;char&gt;, ...)</span>. </dd></dl>

</div>
</div>
<a id="ga59d70a7a49451b0581757861d7fecf46" name="ga59d70a7a49451b0581757861d7fecf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59d70a7a49451b0581757861d7fecf46">&#9670;&#160;</a></span>readvAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::readvAll </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter-gather receive that guarantees the entire next datagram fits the provided buffers. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Performs exactly one kernel receive to copy the <b>full</b> datagram across <code class="param">buffers</code> in order. If the datagram would not fit in the aggregate capacity, the call fails <b>before</b> reading when a size probe is available; otherwise, it performs one receive and fails <b>after</b> the read if truncation occurred. This is a strict, no-truncation variant of <code>readv(...)</code>.</p>
<p>On unconnected sockets, when <code class="param">opts.updateLastRemote</code> == true, the internally tracked “last remote” endpoint is updated to the sender of this datagram.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffers</td><td>Scatter list of writable buffers. Each view must have a valid pointer when its size &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options. This method forces <span class="tt">errorOnTruncate = true</span> and prefers a size preflight (<span class="tt">mode = PreflightSize</span> when the caller left it as <span class="tt">NoPreflight</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> with:<ul>
<li><span class="tt">bytes</span> Number of bytes copied across <code class="param">buffers</code> (equals the datagram size on success),</li>
<li><span class="tt">datagramSize</span> Full datagram size when known (0 if unknown on this platform/path),</li>
<li><span class="tt">truncated</span> Always <span class="tt">false</span> on success (method throws on truncation),</li>
<li><span class="tt">src</span>/<span class="tt">srcLen</span> Sender address information.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; buffer arguments are invalid; OS-level errors occur (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>); or the datagram does not fit the provided capacity. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If a receive timeout elapses before any datagram is available, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the entire datagram has been written across <code class="param">buffers</code> and removed from the queue.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function never allocates payload storage. If you need automatic resizing, use a dynamic container API (e.g., <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read</a>(std::string&amp;)</span> or <span class="tt"><a class="el" href="#gab34fd67ebc17563f286dde70ba456cf9" title="Receive exactly exactLen bytes from a single UDP datagram into buffer, with strict policy control.">readExact</a></span> with <span class="tt">autoResizeDynamic</span>).</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 8&gt;  hdr{};</div>
<div class="line">std::array&lt;char, 64&gt; body{};</div>
<div class="line">BufferView views[] = {</div>
<div class="line">  {hdr.data(),  hdr.size()},</div>
<div class="line">  {body.data(), body.size()}</div>
<div class="line">};</div>
<div class="line">DatagramReadOptions ro{};</div>
<div class="line"><span class="keyword">auto</span> r = sock.readvAll(std::span&lt;BufferView&gt;(views, 2), ro); <span class="comment">// throws if datagram &gt; 72 bytes</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga06d5ac95a81132f8914473d59d333500" name="ga06d5ac95a81132f8914473d59d333500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06d5ac95a81132f8914473d59d333500">&#9670;&#160;</a></span>readvAllBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::DatagramSocket::readvAllBytes </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Back-compat convenience returning only the number of bytes copied. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffers</td><td>See <a class="el" href="#ga59d70a7a49451b0581757861d7fecf46">readvAll(std::span&lt;BufferView&gt;, const DatagramReadOptions&amp;) const</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>See <a class="el" href="#ga59d70a7a49451b0581757861d7fecf46">readvAll(std::span&lt;BufferView&gt;, const DatagramReadOptions&amp;) const</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes copied (equals the datagram size on success). </dd></dl>

</div>
</div>
<a id="ga94a10f136669c41e25fa2be205bd90af" name="ga94a10f136669c41e25fa2be205bd90af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a10f136669c41e25fa2be205bd90af">&#9670;&#160;</a></span>readvAllWithTotalTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::readvAllWithTotalTimeout </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>totalTimeoutMillis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter-gather, strict no-truncation receive with a per-call total timeout. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Waits up to <code class="param">totalTimeoutMillis</code> milliseconds for the socket to become readable, then performs a <b>single</b> scatter-gather receive that <b>must</b> copy the entire next datagram into <code class="param">buffers</code>. If the datagram would not fit in the aggregate capacity, the call fails (either <b>before</b> reading when a size probe is available, or <b>after</b> the read if not). This is a timed variant of <span class="tt">readvAll(...)</span>.</p>
<p>The readiness wait uses <span class="tt">poll</span>/<span class="tt">WSAPoll</span> via <span class="tt">hasPendingData(...)</span>, so this per-call timeout does <b>not</b> modify the socket’s global receive timeout. On unconnected sockets, when <span class="tt">opts.updateLastRemote == true</span>, the internally tracked “last remote” endpoint is updated to the sender of this datagram.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffers</td><td>Scatter list of writable buffers. Each view must have a valid pointer when its size &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalTimeoutMillis</td><td>Total timeout in milliseconds (&gt;= 0). 0 performs a non-blocking readiness check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options. This method enforces strict no-truncation by setting <span class="tt">errorOnTruncate = true</span> and preferring a size preflight (<span class="tt">mode = PreflightSize</span> when left as <span class="tt">NoPreflight</span>). Other fields are honored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> with:<ul>
<li><span class="tt">bytes</span> Number of bytes copied (equals the datagram size on success),</li>
<li><span class="tt">datagramSize</span> Full datagram size when known (0 if unknown on this platform/path),</li>
<li><span class="tt">truncated</span> Always <span class="tt">false</span> on success (the method throws on truncation),</li>
<li><span class="tt">src</span>/<span class="tt">srcLen</span> Sender address information.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; buffer arguments are invalid; OS-level errors occur (message via <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage</a></span>); or the datagram does not fit the provided capacity. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If no datagram becomes ready within <code class="param">totalTimeoutMillis</code>, or when the socket is non-blocking and no data is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. <code class="param">totalTimeoutMillis</code> &gt;= 0. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, the entire datagram has been written across <code class="param">buffers</code> and removed from the queue. For unconnected sockets, when <span class="tt">opts.updateLastRemote == true</span>, the internal “last remote” reflects the sender.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you don’t need a timeout, use <span class="tt">readvAll(...)</span>. If best-effort truncation is acceptable, see <span class="tt">readvAtMostWithTimeout(...)</span>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;char, 8&gt;  hdr{};</div>
<div class="line">std::array&lt;char, 64&gt; body{};</div>
<div class="line">BufferView views[] = {</div>
<div class="line">  {hdr.data(),  hdr.size()},</div>
<div class="line">  {body.data(), body.size()}</div>
<div class="line">};</div>
<div class="line">DatagramReadOptions ro{};</div>
<div class="line"><span class="keyword">auto</span> r = sock.readvAllWithTotalTimeout(std::span&lt;BufferView&gt;(views, 2), 2500, ro);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga037a8dcf56048b94e398842993021f0a" name="ga037a8dcf56048b94e398842993021f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga037a8dcf56048b94e398842993021f0a">&#9670;&#160;</a></span>readvAllWithTotalTimeoutBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::DatagramSocket::readvAllWithTotalTimeoutBytes </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>totalTimeoutMillis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience wrapper returning only the number of bytes copied. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a id="gabddf96e6ee7f156a0fa09a054551744f" name="gabddf96e6ee7f156a0fa09a054551744f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabddf96e6ee7f156a0fa09a054551744f">&#9670;&#160;</a></span>readvAtMostWithTimeout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::DatagramSocket::readvAtMostWithTimeout </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience wrapper returning only the number of bytes read. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a id="ga2e86bfec6de8b35caba5fc00a83489a4" name="ga2e86bfec6de8b35caba5fc00a83489a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e86bfec6de8b35caba5fc00a83489a4">&#9670;&#160;</a></span>readvAtMostWithTimeout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjsocketpp_1_1DatagramReadResult.html">DatagramReadResult</a> DatagramSocket::readvAtMostWithTimeout </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjsocketpp_1_1DatagramReadOptions.html">DatagramReadOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter-gather, best-effort read of the next datagram with a per-call timeout. </p>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<p>Waits up to <code class="param">timeoutMillis</code> milliseconds for the socket to become readable, then performs a <b>single-recv, at-most</b> scatter-gather read into <code class="param">buffers:</code> </p><ul>
<li>Copies up to the aggregate capacity of <code class="param">buffers</code> (clamped by MaxDatagramPayloadSafe).</li>
<li>If the datagram is larger than the aggregate capacity, the excess is discarded (standard UDP truncation).</li>
<li>No size preflight is performed; truncation is <b>accepted</b> (no exception) to preserve best-effort semantics.</li>
</ul>
<p>On unconnected sockets, when <span class="tt">opts.updateLastRemote == true</span>, the internally tracked “last remote” endpoint is updated to the sender of this datagram.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffers</td><td>Scatter list of writable buffers; each entry must have a valid pointer if its size &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Timeout in milliseconds (&gt;= 0). 0 means non-blocking readiness check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Read options; fields other than <span class="tt">mode</span> and <span class="tt">errorOnTruncate</span> are honored. This method forces <span class="tt">mode = <a class="el" href="#gga2124eae8cec6709a67be265f14da3bdda4f0bde0267e64be026814e98c423c47f" title="Do not probe the datagram size; call recvfrom() directly.">DatagramReceiveMode::NoPreflight</a></span> and <span class="tt">errorOnTruncate = false</span> to ensure single-recv, best-effort behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structjsocketpp_1_1DatagramReadResult.html" title="Telemetry data about a single UDP datagram receive operation.">DatagramReadResult</a> { bytes, datagramSize (best effort), truncated, src, srcLen }.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is not open; buffer arguments are invalid; or an OS-level error occurs (message via SocketErrorMessage). </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If no datagram becomes ready within <code class="param">timeoutMillis</code>, or when the socket is non-blocking and no data is available (would-block).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket has been successfully created/opened. <code class="param">timeoutMillis</code> &gt;= 0. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, up to the aggregate buffer capacity has been written across <code class="param">buffers</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For strict no-truncation scatter-gather reads, use <a class="el" href="#ga59d70a7a49451b0581757861d7fecf46">readvAll</a>. </dd></dl>

</div>
</div>
<a id="ga6235d9f1a2f2a9145b1c2c497d2ac26a" name="ga6235d9f1a2f2a9145b1c2c497d2ac26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6235d9f1a2f2a9145b1c2c497d2ac26a">&#9670;&#160;</a></span>resolveIPv4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">in_addr MulticastSocket::resolveIPv4 </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve a host string to an IPv4 address (<span class="tt">in_addr</span>, network byte order). </p>
<p>Converts <code class="param">host</code> into an IPv4 address suitable for socket APIs. Resolution strategy:</p><ol type="1">
<li>Fast path: if <code class="param">host</code> is an IPv4 literal (e.g., "239.1.2.3"), parse it with <span class="tt">inet_pton(AF_INET, ...)</span> without any name-service lookup.</li>
<li>Fallback: otherwise, call the project helper <span class="tt">resolveAddress(host, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a>{0}, AF_INET, SOCK_DGRAM, IPPROTO_UDP, 0)</span> and extract the first <span class="tt">AF_INET</span> result.</li>
</ol>
<p>The returned <span class="tt">in_addr</span> is in network byte order, ready for <span class="tt">setsockopt</span>, <span class="tt">sendto</span>, and multicast membership structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Host string to resolve. Accepts IPv4 literals ("A.B.C.D") or names/hostnames resolvable by the system’s name services. Must not be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resolved IPv4 address in network byte order.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code class="param">host</code> is not empty.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>No persistent side effects; this function does not modify socket state.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If <code class="param">host</code> is empty.</li>
<li>If resolution succeeds but yields no <span class="tt">AF_INET</span> address.</li>
<li>If name resolution fails; the exception carries the OS or getaddrinfo error code and a descriptive message from <span class="tt">SocketErrorMessage(..., true)</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>CIDR notation and interface suffixes are not supported; pass a single host literal or resolvable name.</li>
<li>If a name resolves to multiple IPv4 addresses, the first result from <span class="tt">resolveAddress</span> is used.</li>
<li>Use this helper before joining IPv4 multicast groups to ensure a correct address family and byte order.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related</dt><dd><ul>
<li><a class="el" href="#ga47a296c0592019a915a2046874d98184">resolveIPv6(std::string_view)</a> — IPv6 counterpart.</li>
<li><a class="el" href="group__socketopts.html#ga10fe0331596fddffb6dbd483c95a2490">is_ipv4_multicast(in_addr)</a> — multicast-range predicate.</li>
<li><a class="el" href="group__socketopts.html#ga65375075d5e7b8009730e0d28b199d73">joinGroupIPv4(in_addr, in_addr)</a> — join IPv4 multicast groups.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Parse a literal IPv4 multicast group</span></div>
<div class="line">in_addr g = <a class="code hl_function" href="#ga6235d9f1a2f2a9145b1c2c497d2ac26a">resolveIPv4</a>(<span class="stringliteral">&quot;239.1.2.3&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="group__socketopts.html#ga10fe0331596fddffb6dbd483c95a2490">is_ipv4_multicast</a>(g)) {</div>
<div class="line">    <span class="keywordflow">throw</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>(<span class="stringliteral">&quot;Expected an IPv4 multicast address&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Resolve a hostname and join on the default interface</span></div>
<div class="line">in_addr g2 = <a class="code hl_function" href="#ga6235d9f1a2f2a9145b1c2c497d2ac26a">resolveIPv4</a>(<span class="stringliteral">&quot;mcast.example.com&quot;</span>);</div>
<div class="line">in_addr any{};</div>
<div class="line">any.s_addr = htonl(INADDR_ANY);</div>
<div class="line"><a class="code hl_function" href="group__socketopts.html#ga65375075d5e7b8009730e0d28b199d73">joinGroupIPv4</a>(g2, any);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Resolve an interface IPv4 address (egress) by literal</span></div>
<div class="line">in_addr eg = <a class="code hl_function" href="#ga6235d9f1a2f2a9145b1c2c497d2ac26a">resolveIPv4</a>(<span class="stringliteral">&quot;192.0.2.10&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__socketopts.html#ga65375075d5e7b8009730e0d28b199d73">joinGroupIPv4</a>(g, eg);</div>
<div class="ttc" id="aclassjsocketpp_1_1SocketException_html"><div class="ttname"><a href="classjsocketpp_1_1SocketException.html">jsocketpp::SocketException</a></div><div class="ttdoc">Represents socket-related errors in the jsocketpp library.</div><div class="ttdef"><b>Definition</b> SocketException.hpp:63</div></div>
<div class="ttc" id="agroup__socketopts_html_ga10fe0331596fddffb6dbd483c95a2490"><div class="ttname"><a href="group__socketopts.html#ga10fe0331596fddffb6dbd483c95a2490">jsocketpp::SocketOptions::is_ipv4_multicast</a></div><div class="ttdeci">static bool is_ipv4_multicast(const in_addr v4)</div><div class="ttdoc">Test whether an IPv4 address is in the multicast range (224.0.0.0/4).</div><div class="ttdef"><b>Definition</b> SocketOptions.hpp:2370</div></div>
<div class="ttc" id="agroup__socketopts_html_ga65375075d5e7b8009730e0d28b199d73"><div class="ttname"><a href="group__socketopts.html#ga65375075d5e7b8009730e0d28b199d73">jsocketpp::SocketOptions::joinGroupIPv4</a></div><div class="ttdeci">void joinGroupIPv4(in_addr group, in_addr iface)</div><div class="ttdoc">Join an IPv4 any-source multicast (ASM) group on a specific interface.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:470</div></div>
<div class="ttc" id="agroup__udp_html_ga6235d9f1a2f2a9145b1c2c497d2ac26a"><div class="ttname"><a href="#ga6235d9f1a2f2a9145b1c2c497d2ac26a">jsocketpp::MulticastSocket::resolveIPv4</a></div><div class="ttdeci">static in_addr resolveIPv4(std::string_view host)</div><div class="ttdoc">Resolve a host string to an IPv4 address (in_addr, network byte order).</div><div class="ttdef"><b>Definition</b> MulticastSocket.cpp:94</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga47a296c0592019a915a2046874d98184" name="ga47a296c0592019a915a2046874d98184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47a296c0592019a915a2046874d98184">&#9670;&#160;</a></span>resolveIPv6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">in6_addr MulticastSocket::resolveIPv6 </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve a host string to an IPv6 address (<span class="tt">in6_addr</span>). </p>
<p>Converts <code class="param">host</code> into an IPv6 address suitable for socket APIs. Resolution strategy:</p><ol type="1">
<li>Fast path: if <code class="param">host</code> is an IPv6 literal (e.g., "ff02::1"), parse it with <span class="tt">inet_pton(AF_INET6, ...)</span> and avoid any name-service lookup.</li>
<li>Fallback: otherwise, call the project helper <span class="tt">resolveAddress(host, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a>{0}, AF_INET6, SOCK_DGRAM, IPPROTO_UDP, 0)</span> and extract the first <span class="tt">AF_INET6</span> result.</li>
</ol>
<p>The returned <span class="tt">in6_addr</span> is in the canonical struct form expected by socket calls, multicast membership records, and IPv6 <span class="tt">setsockopt</span> options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Host string to resolve. Accepts IPv6 literals (e.g., "ff02::1", "2001:db8::1") or names/hostnames resolvable by the system’s name services. Must not be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resolved IPv6 address.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code class="param">host</code> is not empty.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>No persistent side effects; this function does not modify socket state.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If <code class="param">host</code> is empty.</li>
<li>If resolution succeeds but yields no <span class="tt">AF_INET6</span> address.</li>
<li>If name resolution fails; the exception carries the OS or getaddrinfo error code and a descriptive message from <span class="tt">SocketErrorMessage(..., true)</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Zone identifiers such as "ff02::1%eth0" are not interpreted here. Supply the interface index separately where required (e.g., for multicast membership or egress selection).</li>
<li>If a name resolves to multiple IPv6 addresses, the first result from <span class="tt">resolveAddress</span> is used.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related</dt><dd><ul>
<li><a class="el" href="#ga6235d9f1a2f2a9145b1c2c497d2ac26a">resolveIPv4(std::string_view)</a> — IPv4 counterpart.</li>
<li><a class="el" href="group__socketopts.html#ga10be210b19c0e6d6deb641cb74ed1c0a">is_ipv6_multicast(const in6_addr&amp;)</a> — multicast-range predicate.</li>
<li><a class="el" href="group__socketopts.html#ga26253ae313b6ef1417af775668ffbf24">joinGroupIPv6(in6_addr, unsigned int)</a> — join IPv6 multicast groups.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Parse a literal IPv6 multicast group and join on interface index 0 (default)</span></div>
<div class="line">in6_addr g6 = <a class="code hl_function" href="#ga47a296c0592019a915a2046874d98184">resolveIPv6</a>(<span class="stringliteral">&quot;ff02::1:3&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="group__socketopts.html#ga10be210b19c0e6d6deb641cb74ed1c0a">is_ipv6_multicast</a>(g6)) {</div>
<div class="line">    <span class="keywordflow">throw</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>(<span class="stringliteral">&quot;Expected an IPv6 multicast address&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__socketopts.html#ga26253ae313b6ef1417af775668ffbf24">joinGroupIPv6</a>(g6, 0); <span class="comment">// 0 = default interface</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Resolve a hostname and join on a specific interface index</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ifidx = 12; <span class="comment">// e.g., result of if_nametoindex(&quot;eth0&quot;) on POSIX</span></div>
<div class="line">in6_addr g6host = <a class="code hl_function" href="#ga47a296c0592019a915a2046874d98184">resolveIPv6</a>(<span class="stringliteral">&quot;mcast6.example.com&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__socketopts.html#ga26253ae313b6ef1417af775668ffbf24">joinGroupIPv6</a>(g6host, ifidx);</div>
<div class="ttc" id="agroup__socketopts_html_ga10be210b19c0e6d6deb641cb74ed1c0a"><div class="ttname"><a href="group__socketopts.html#ga10be210b19c0e6d6deb641cb74ed1c0a">jsocketpp::SocketOptions::is_ipv6_multicast</a></div><div class="ttdeci">static bool is_ipv6_multicast(const in6_addr &amp;v6)</div><div class="ttdoc">Test whether an IPv6 address is in the multicast range (ff00::/8).</div><div class="ttdef"><b>Definition</b> SocketOptions.hpp:2430</div></div>
<div class="ttc" id="agroup__socketopts_html_ga26253ae313b6ef1417af775668ffbf24"><div class="ttname"><a href="group__socketopts.html#ga26253ae313b6ef1417af775668ffbf24">jsocketpp::SocketOptions::joinGroupIPv6</a></div><div class="ttdeci">void joinGroupIPv6(in6_addr group, unsigned int ifindex)</div><div class="ttdoc">Join an IPv6 any-source multicast (ASM) group on a specific interface index.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:500</div></div>
<div class="ttc" id="agroup__udp_html_ga47a296c0592019a915a2046874d98184"><div class="ttname"><a href="#ga47a296c0592019a915a2046874d98184">jsocketpp::MulticastSocket::resolveIPv6</a></div><div class="ttdeci">static in6_addr resolveIPv6(std::string_view host)</div><div class="ttdoc">Resolve a host string to an IPv6 address (in6_addr).</div><div class="ttdef"><b>Definition</b> MulticastSocket.cpp:124</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga463c1511ac0622b623fa2937314e1239" name="ga463c1511ac0622b623fa2937314e1239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga463c1511ac0622b623fa2937314e1239">&#9670;&#160;</a></span>sendPrefixedConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::sendPrefixedConnected </td>
          <td>(</td>
          <td class="paramtype">const std::span&lt; const std::byte &gt;</td>          <td class="paramname"><span class="paramname"><em>payload</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build and send a length-prefixed UDP datagram to the connected peer (no pre-wait). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Unsigned integral type used for the length prefix (e.g., <span class="tt">std::uint8_t</span>, <span class="tt">std::uint16_t</span>, <span class="tt">std::uint32_t</span>, <span class="tt">std::uint64_t</span>). A compile-time check enforces that <span class="tt">T</span> is an unsigned integral.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs a single datagram with layout <b>[ prefix(T, big-endian) | payload ]</b> where the prefix encodes <span class="tt">payload.size()</span> in <b>network byte order</b>. The method: 1) verifies the socket is <b>open</b> and <b>connected</b>; 2) encodes the prefix via <span class="tt"><a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE</a>&lt;T&gt;(payload.size())</span>; 3) computes <span class="tt">total = sizeof(T) + payload.size()</span> and enforces the connected peer’s protocol maxima via <span class="tt">enforceSendCapConnected(total)</span> (prevents guaranteed <span class="tt">EMSGSIZE</span>); 4) coalesces <span class="tt">[prefix|payload]</span> into one contiguous buffer and performs <b>one</b> send.</p>
<p>This function does <b>not</b> poll for writability. On non-blocking sockets, if the send buffer is temporarily full, the underlying send may fail (e.g., <span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span>) and will be surfaced as a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>. For blocking behavior, prefer <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> or <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span>.</p>
<p><b>Atomicity:</b> UDP is message-oriented; on success, the <em>entire</em> <span class="tt">[prefix|payload]</span> frame is sent in a single datagram. On exception, no bytes are considered transmitted.</p>
<p>Zero-length payloads are valid: a datagram containing only the prefix is sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Binary bytes to append after the length prefix (may be empty).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">sizeof(T) + payload.size()</span> bytes are handed to the kernel as one UDP datagram. <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state and options are unchanged.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open or not connected.</li>
<li><span class="tt">payload.size()</span> exceeds <span class="tt">std::numeric_limits&lt;T&gt;::max()</span> (from <span class="tt"><a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE</a>&lt;T&gt;()</span>).</li>
<li>Total frame exceeds the permitted maximum for the connected peer’s family (from <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
</ul>
</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b><ul>
<li>Send failures such as <span class="tt">EWOULDBLOCK</span>, <span class="tt">ENOBUFS</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, etc.</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>writePrefixed&lt;T&gt;(std::string_view), writePrefixed&lt;T&gt;(std::span&lt;const std::byte&gt;), writeWithTimeout(std::string_view, int), writeAll(std::string_view), <a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE&lt;T&gt;(std::size_t)</a>, enforceSendCapConnected(std::size_t)</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send a length-prefixed frame with a 16-bit prefix</span></div>
<div class="line">std::string_view text = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line">sock.sendPrefixedConnected&lt;std::uint16_t&gt;(<a class="code hl_function" href="#ga20eb26c65ff8d9c880494e028509e0a8">DatagramSocket::asBytes</a>(text));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga5c4761b07760b1eadf84b9fbed700c98" name="ga5c4761b07760b1eadf84b9fbed700c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c4761b07760b1eadf84b9fbed700c98">&#9670;&#160;</a></span>sendPrefixedUnconnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::sendPrefixedUnconnected </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::byte &gt;</td>          <td class="paramname"><span class="paramname"><em>payload</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build and send a length-prefixed UDP datagram to (host, port) on the unconnected path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Unsigned integral type for the length prefix (e.g., <span class="tt">std::uint8_t</span>, <span class="tt">std::uint16_t</span>, <span class="tt">std::uint32_t</span>, <span class="tt">std::uint64_t</span>). A compile-time check enforces that <span class="tt">T</span> is unsigned integral.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs a single frame <b>[ prefix(T, big-endian) | payload ]</b>, where the prefix encodes <span class="tt">payload.size()</span> in <b>network byte order</b>, then transmits it to the specified destination using <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span>. That helper resolves A/AAAA records, <b>skips</b> address families whose theoretical UDP maximum cannot carry the frame, attempts a single send to the first compatible candidate, and caches the last destination (without marking the socket connected).</p>
<p>Processing steps: 1) Verify socket is <b>open</b>. 2) Encode prefix via <span class="tt"><a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE</a>&lt;T&gt;(payload.size())</span> (validates that size fits in <span class="tt">T</span>). 3) Coalesce <span class="tt">[prefix|payload]</span> once and dispatch through <span class="tt">sendUnconnectedTo(host, port, ...)</span>.</p>
<p>Zero-length payloads are valid: a datagram containing only the prefix is sent.</p>
<p><b>Atomicity:</b> UDP is message-oriented; on success the entire <span class="tt">[prefix|payload]</span> frame is sent in one datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Destination hostname or numeric address (IPv4/IPv6). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Destination UDP port (&gt; 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Binary bytes to append after the length prefix (may be empty).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">sizeof(T) + payload.size()</span> bytes are handed to the kernel as one datagram.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open.</li>
<li><span class="tt">payload.size()</span> exceeds <span class="tt">std::numeric_limits&lt;T&gt;::max()</span> (from <span class="tt"><a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE</a>&lt;T&gt;()</span>).</li>
<li>No address family can carry the frame size (surfaced by <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span>).</li>
</ul>
</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b><ul>
<li>Resolution or send failures reported by the OS (e.g., <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, <span class="tt">ENOBUFS</span>).</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Family-specific size enforcement (IPv4 vs IPv6) and destination caching are handled inside <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span>. This method does not pre-wait for writability; if you need blocking behavior, perform an explicit readiness wait on a connected socket or design a higher-level retry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>writePrefixedTo&lt;T&gt;(std::string_view, Port, std::string_view), writePrefixed&lt;T&gt;(std::span&lt;const std::byte&gt;), <a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE&lt;T&gt;(std::size_t)</a>, <a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo(std::string_view, Port, const void*, std::size_t)</a>, <a class="el" href="group__core.html#ga63ed4637719268844616341e0f8908cb" title="Maximum UDP payload size (in bytes) over IPv4.">MaxUdpPayloadIPv4</a>, <a class="el" href="group__core.html#ga041bcd9d09d1d8e134c7b8af72523d66" title="Theoretical maximum UDP payload size (in bytes) over IPv6.">MaxUdpPayloadIPv6</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send a length-prefixed binary frame to a host/port using a 16-bit prefix.</span></div>
<div class="line">std::array&lt;std::byte, 3&gt; data{std::byte{0xDE}, std::byte{0xAD}, std::byte{0xBE}};</div>
<div class="line">sock.sendPrefixedUnconnected&lt;std::uint16_t&gt;(<span class="stringliteral">&quot;239.0.0.1&quot;</span>, 5000, std::span&lt;const std::byte&gt;{data});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gab12e38ad202aa788d89980864d3e83bc" name="gab12e38ad202aa788d89980864d3e83bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12e38ad202aa788d89980864d3e83bc">&#9670;&#160;</a></span>sendUnconnectedTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::sendUnconnectedTo </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve and send one unconnected UDP datagram to the first compatible destination. </p>
<p>Resolves <code class="param">host</code> and <code class="param">port</code> (AF_UNSPEC, UDP), iterates all A/AAAA candidates, and:</p><ul>
<li><b>Skips</b> any family whose theoretical UDP maximum would be exceeded by <code class="param">len</code> (<span class="tt"><a class="el" href="group__core.html#ga63ed4637719268844616341e0f8908cb" title="Maximum UDP payload size (in bytes) over IPv4.">MaxUdpPayloadIPv4</a></span>/<span class="tt"><a class="el" href="group__core.html#ga041bcd9d09d1d8e134c7b8af72523d66" title="Theoretical maximum UDP payload size (in bytes) over IPv6.">MaxUdpPayloadIPv6</a></span>).</li>
<li>Sends the datagram with a single syscall (<span class="tt"><a class="el" href="group__internal.html#ga67bcc094472935bce938ff821b7ce8d8" title="Sends an entire datagram to a specific destination using sendto().">internal::sendExactTo</a></span>) to the <b>first</b> compatible candidate that succeeds.</li>
<li>On success, remembers the last remote endpoint for helpers (without flipping the socket into a connected state).</li>
</ul>
<p>If no candidates can even be <em>attempted</em> (e.g., payload &gt; IPv6 max or only A records for a payload that requires IPv6), throws a <b>logical</b> <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with a clear diagnostic. If at least one attempt is made and all fail, throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with the last OS error (<span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span>/<span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage()</a></span>).</p>
<p>This helper is intended for all <b>unconnected</b> write paths (e.g., <span class="tt">writeTo(...)</span>, <span class="tt"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write</a>(const <a class="el" href="classjsocketpp_1_1DatagramPacket.html" title="Represents a UDP datagram packet, encapsulating both payload and addressing information.">DatagramPacket</a>&amp;)</span> when the packet specifies a destination).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Destination hostname or numeric address (IPv4/IPv6). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Destination UDP port (&gt; 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to payload (may be null iff <code class="param">len</code> == 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to send in a single UDP datagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>With code <span class="tt">0</span> and an explanatory message if no address family can carry the payload.</li>
<li>With the last OS error code/message if all attempted sends fail.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Zero-length datagrams are valid; this helper returns <span class="tt">0</span> without sending. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo()</a>, <a class="el" href="#gafb2439eddc4ce6db4915e02ed7946444" title="Send one UDP datagram using a packet’s buffer and optional explicit destination.">write(const DatagramPacket&amp;)</a>, <a class="el" href="group__core.html#ga63ed4637719268844616341e0f8908cb" title="Maximum UDP payload size (in bytes) over IPv4.">MaxUdpPayloadIPv4</a>, <a class="el" href="group__core.html#ga041bcd9d09d1d8e134c7b8af72523d66" title="Theoretical maximum UDP payload size (in bytes) over IPv6.">MaxUdpPayloadIPv6</a> </dd></dl>

</div>
</div>
<a id="ga1b017c1366655d32a2ec5d19deef9d37" name="ga1b017c1366655d32a2ec5d19deef9d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b017c1366655d32a2ec5d19deef9d37">&#9670;&#160;</a></span>setInternalBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::setInternalBufferSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>newLen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the internal buffer used for string-based UDP receive operations. </p>
<p>This method controls the size of the internal buffer used internally by <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read</a>&lt;std::string&gt;()</span>. It does <b>not</b> affect the operating system's socket-level receive buffer (<span class="tt">SO_RCVBUF</span>), nor does it apply to fixed-size <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read</a>&lt;T&gt;()</span> calls.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md684"></a>
🧠 Purpose</h3>
<ul>
<li>Limits the maximum number of bytes <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read</a>&lt;std::string&gt;()</span> can receive in a single call</li>
<li>Controls the size of the internally managed <span class="tt">std::vector&lt;char&gt;</span> buffer</li>
<li>Affects only high-level string reads from <b>connected</b> UDP sockets</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md686"></a>
⚙️ Implementation Details</h3>
<ul>
<li>Resizes an internal <span class="tt">std::vector&lt;char&gt;</span> used exclusively by <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read</a>&lt;std::string&gt;()</span></li>
<li><b>Does not</b> impact <span class="tt"><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read</a>&lt;T&gt;()</span> or <span class="tt">receiveFrom()</span> which use their own fixed-size buffers</li>
<li>Thread-safe with respect to other <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> instances</li>
<li>Safe to call at any time after construction</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md688"></a>
🧪 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> udp(12345);</div>
<div class="line">udp.setInternalBufferSize(8192); <span class="comment">// set 8 KB for string reads</span></div>
<div class="line"> </div>
<div class="line">udp.connect(<span class="stringliteral">&quot;192.168.1.100&quot;</span>, 12345);</div>
<div class="line">std::string message = udp.read&lt;std::string&gt;();</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newLen</td><td>New size (in bytes) for the internal buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If resizing the buffer fails due to memory allocation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa7f9cce85a502e58b8d86db95a8e0721" title="Read one UDP datagram into a DatagramPacket with optional growth/shrink and strict truncation policy.">read&lt;std::string&gt;()</a> Uses this buffer for connected-mode string reads </dd>
<dd>
receiveFrom() Uses its own <a class="el" href="namespacejsocketpp_1_1internal.html" title="Implementation-only utilities and platform abstractions for jsocketpp.">internal</a> buffer, not affected by this setting </dd>
<dd>
<a class="el" href="group__socketopts.html#ga69fdecc0aaaef4bbd2826c448a8bbe1d" title="Sets the socket&#39;s receive buffer size (SO_RCVBUF).">setReceiveBufferSize()</a> Sets the OS-level socket buffer </dd>
<dd>
<a class="el" href="group__socketopts.html#ga8279b0c70f6a0fddf73d84aac691422b" title="Sets the socket&#39;s send buffer size (SO_SNDBUF).">setSendBufferSize()</a> For tuning datagram send capacity </dd></dl>

</div>
</div>
<a id="gab6608be5d1aff24ad5077f6ea9a9168a" name="gab6608be5d1aff24ad5077f6ea9a9168a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6608be5d1aff24ad5077f6ea9a9168a">&#9670;&#160;</a></span>setLoopbackMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MulticastSocket::setLoopbackMode </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable multicast loopback for this socket. </p>
<p>Controls whether <b>multicast datagrams sent by this socket</b> may be delivered back to the local host (i.e., whether the sender can observe its own multicast transmissions). This affects <b>local delivery only</b> &mdash; it does not change what remote receivers get.</p>
<ul>
<li><b>Enabled (<span class="tt">true</span>)</b>: the kernel may deliver local copies of outbound multicast to sockets on the same host that have joined the destination group, including this socket if it has joined.</li>
<li><b>Disabled (<span class="tt">false</span>)</b>: local delivery of this socket’s own multicast traffic is suppressed; other hosts on the network are unaffected.</li>
</ul>
<p>This setting is <b>per-socket</b> and applies to <b>multicast</b> only. It does not affect unicast traffic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Set <span class="tt">true</span> to allow local delivery of this socket’s multicast transmissions, or <span class="tt">false</span> to suppress local delivery.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The underlying descriptor is a valid UDP-capable socket (<span class="tt">AF_INET</span> or <span class="tt">AF_INET6</span>).</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The socket’s multicast loopback policy is updated. Future multicast sends from this socket follow the new policy; in-flight packets are unaffected.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Platform mapping</dt><dd><ul>
<li><b>IPv4:</b> <span class="tt">setsockopt(fd, IPPROTO_IP,  IP_MULTICAST_LOOP,  &amp;flag, sizeof(flag))</span></li>
<li><b>IPv6:</b> <span class="tt">setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &amp;flag, sizeof(flag))</span></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error conditions</dt><dd><ul>
<li>The socket is invalid or closed.</li>
<li>The socket family cannot be determined or is unsupported on this platform.</li>
<li>The underlying <span class="tt">setsockopt</span> call fails, e.g., <span class="tt">ENOTSOCK</span>, <span class="tt">EINVAL</span>, <span class="tt">ENOPROTOOPT</span> (Windows: <span class="tt">WSAENOTSOCK</span>, <span class="tt">WSAEINVAL</span>, <span class="tt">WSAENOPROTOOPT</span>).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the option cannot be applied. The exception carries the OS error code and a descriptive message produced by <span class="tt">SocketErrorMessage(...)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>To actually receive your own multicast transmissions on this socket, two conditions must hold: (1) loopback is enabled here, and (2) the socket has <b>joined</b> the destination group.</li>
<li>Typical default is enabled on many stacks, but this is implementation-defined. Use <a class="el" href="group__socketopts.html#gad11b9d3378834eab9c28e32e70fc249a">getTimeToLive()</a> / <a class="el" href="group__socketopts.html#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL()</a> and <a class="el" href="group__socketopts.html#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> to confirm defaults in your environment.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="group__socketopts.html#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> &mdash; query the current loopback flag.</li>
<li><a class="el" href="#ga72172a10bc5ba13a908f31c791c90ec5">setTimeToLive(int)</a> / <a class="el" href="group__socketopts.html#gad11b9d3378834eab9c28e32e70fc249a">getTimeToLive()</a> &mdash; control/query multicast TTL.</li>
<li><a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface(const std::string&amp;)</a> &mdash; select the outgoing interface.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Suppress receiving our own announcements on this host</span></div>
<div class="line"><a class="code hl_function" href="#ga996b99882efa863b01e0fff4a9782a82">MulticastSocket</a> sock;</div>
<div class="line">sock.<a class="code hl_function" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;eth0&quot;</span>);</div>
<div class="line">sock.<a class="code hl_function" href="#ga7937b05ccae7d059b4fcfa4b6383c75c">joinGroup</a>(<span class="stringliteral">&quot;239.1.2.3&quot;</span>);</div>
<div class="line">sock.<a class="code hl_function" href="#gab6608be5d1aff24ad5077f6ea9a9168a">setLoopbackMode</a>(<span class="keyword">false</span>);  <span class="comment">// do not receive our own packets locally</span></div>
<div class="ttc" id="agroup__udp_html_ga7937b05ccae7d059b4fcfa4b6383c75c"><div class="ttname"><a href="#ga7937b05ccae7d059b4fcfa4b6383c75c">jsocketpp::MulticastSocket::joinGroup</a></div><div class="ttdeci">void joinGroup(const std::string &amp;groupAddr, const std::string &amp;iface)</div><div class="ttdoc">Join a multicast group on an optional interface (string-friendly).</div><div class="ttdef"><b>Definition</b> MulticastSocket.cpp:173</div></div>
<div class="ttc" id="agroup__udp_html_gab6608be5d1aff24ad5077f6ea9a9168a"><div class="ttname"><a href="#gab6608be5d1aff24ad5077f6ea9a9168a">jsocketpp::MulticastSocket::setLoopbackMode</a></div><div class="ttdeci">void setLoopbackMode(bool enable)</div><div class="ttdoc">Enable or disable multicast loopback for this socket.</div><div class="ttdef"><b>Definition</b> MulticastSocket.cpp:79</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf0d5d684dcbfcf62907482ae3ac98948" name="gaf0d5d684dcbfcf62907482ae3ac98948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0d5d684dcbfcf62907482ae3ac98948">&#9670;&#160;</a></span>setMulticastInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MulticastSocket::setMulticastInterface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>iface</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the default outgoing interface for multicast transmissions. </p>
<p>Sets the per-socket <b>egress interface</b> that will be used for subsequent <b>multicast</b> sends. This is a convenience wrapper that accepts human-friendly identifiers and delegates to the per-family setters.</p>
<p>Accepted forms for <code class="param">iface</code> </p><ul>
<li>Empty string: reset the egress to the <b>system default</b> for this socket’s family only (IPv4: <span class="tt">INADDR_ANY</span>; IPv6: index <span class="tt">0</span>). The family is determined via <span class="tt">detectFamily(_sockFd)</span>, so a single-family socket will not attempt to set options for the other family.</li>
<li>IPv4 literal (e.g., "192.0.2.10"): choose that address as the <b>IPv4</b> multicast egress; maps to <span class="tt">IP_MULTICAST_IF</span>.</li>
<li>IPv6 interface identifier:<ul>
<li>Decimal <b>interface index</b> string (e.g., "12") on any platform.</li>
<li><b>POSIX only:</b> an interface <b>name</b> (e.g., "eth0"), resolved with <span class="tt">if_nametoindex()</span>. These map to <span class="tt">IPV6_MULTICAST_IF</span>. On Windows, names are <b>not</b> supported; supply a numeric index string instead.</li>
</ul>
</li>
</ul>
<p>Behavior</p><ul>
<li>If <code class="param">iface</code> is empty, the method resets the egress <b>only</b> for the socket’s actual family (IPv4 or IPv6) and clears the cached <span class="tt"><a class="el" href="classjsocketpp_1_1MulticastSocket.html#a441b5a5c2b962e040d8910185fb360c0" title="Interface used for multicast.">_currentInterface</a></span>.</li>
<li>If <code class="param">iface</code> parses as an IPv4 literal, the IPv4 egress is set and the cache is updated to the provided string.</li>
<li>Otherwise, <code class="param">iface</code> is interpreted as an IPv6 identifier and converted to an index using <span class="tt">toIfIndexFromString(iface)</span>; the IPv6 egress is set and the cache is updated to the provided string.</li>
<li>The cached <span class="tt"><a class="el" href="classjsocketpp_1_1MulticastSocket.html#a441b5a5c2b962e040d8910185fb360c0" title="Interface used for multicast.">_currentInterface</a></span> is updated <b>only after</b> the OS call succeeds.</li>
</ul>
<p>Notes</p><ul>
<li>This method does <b>not</b> join or leave multicast groups; it affects only where <em>outbound</em> multicast is sent. Use the join/leave APIs to control what the socket receives.</li>
<li>For link-local IPv6 destinations, using a correct interface index is often mandatory; prefer a non-empty IPv6 identifier in those cases.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>Interface selector as described above. Pass <span class="tt">""</span> to reset to the per-family system default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>The socket family cannot be determined or is unsupported.</li>
<li><code class="param">iface</code> is malformed or unsupported on the current platform (e.g., an interface name on Windows for IPv6).</li>
<li>The underlying <span class="tt">setsockopt</span> call fails (<span class="tt">IP_MULTICAST_IF</span> for IPv4, <span class="tt">IPV6_MULTICAST_IF</span> for IPv6). The exception includes an OS error code and a descriptive message.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Related</dt><dd><ul>
<li><a class="el" href="group__socketopts.html#ga0303c931f324a501e2502df58b8a9232" title="Select the outgoing IPv4 interface for multicast.">setMulticastInterfaceIPv4(in_addr)</a>, <a class="el" href="group__socketopts.html#gad8e171cfa4daf58cde0f27d26794e35c" title="Select the outgoing IPv6 interface for multicast.">setMulticastInterfaceIPv6(unsigned int)</a></li>
<li><a class="el" href="#ga7937b05ccae7d059b4fcfa4b6383c75c" title="Join a multicast group on an optional interface (string-friendly).">joinGroup(const std::string&amp;, const std::string&amp;)</a></li>
<li><a class="el" href="#ga72172a10bc5ba13a908f31c791c90ec5" title="Set the time-to-live (TTL) / hop limit for outgoing multicast packets.">setTimeToLive(int)</a> / <a class="el" href="group__socketopts.html#gad11b9d3378834eab9c28e32e70fc249a" title="Get the current default multicast TTL / hop limit cached on this socket.">getTimeToLive()</a></li>
<li><a class="el" href="group__socketopts.html#ga147307de53a210acda7c64dc1540c40e" title="Set the default multicast hop limit / TTL for this socket.">setMulticastTTL(int)</a> / <a class="el" href="group__socketopts.html#ga55f73b7c90f7f6b507c69eead5cfc10f" title="Get the socket’s default multicast hop limit / TTL.">getMulticastTTL()</a></li>
<li><a class="el" href="#gab6608be5d1aff24ad5077f6ea9a9168a" title="Enable or disable multicast loopback for this socket.">setLoopbackMode(bool)</a> / <a class="el" href="group__socketopts.html#ga0f0ab03631b48add0e1b8845e553ebab" title="Get the current multicast loopback mode cached on this socket.">getLoopbackMode()</a></li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga996b99882efa863b01e0fff4a9782a82">MulticastSocket</a> sock;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reset to system default for this socket&#39;s family</span></div>
<div class="line">sock.<a class="code hl_function" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Choose a specific IPv4 egress address</span></div>
<div class="line">sock.<a class="code hl_function" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;192.0.2.10&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Choose IPv6 egress by numeric index (any platform)</span></div>
<div class="line">sock.<a class="code hl_function" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;12&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// POSIX: choose IPv6 egress by interface name</span></div>
<div class="line">sock.<a class="code hl_function" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;eth0&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga72172a10bc5ba13a908f31c791c90ec5" name="ga72172a10bc5ba13a908f31c791c90ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72172a10bc5ba13a908f31c791c90ec5">&#9670;&#160;</a></span>setTimeToLive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MulticastSocket::setTimeToLive </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ttl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the time-to-live (TTL) / hop limit for outgoing multicast packets. </p>
<p>Sets this socket’s <b>default multicast scope</b> for subsequent transmissions:</p><ul>
<li><b>IPv4:</b> applies to <span class="tt">IP_MULTICAST_TTL</span> (time-to-live).</li>
<li><b>IPv6:</b> applies to <span class="tt">IPV6_MULTICAST_HOPS</span> (hop limit).</li>
</ul>
<p>The value constrains how far outbound <b>multicast</b> packets may propagate:</p><ul>
<li><span class="tt">0</span> — restricted to the local host (no egress onto the network);</li>
<li><span class="tt">1</span> — restricted to the local link/subnet (commonly the default);</li>
<li>higher values — permit traversal across additional multicast routers up to the limit (e.g., <span class="tt">32</span> ~ site, <span class="tt">64</span> ~ region, <span class="tt">128</span> ~ continent, <span class="tt">255</span> ~ unrestricted).</li>
</ul>
<p>This setting is <b>per-socket</b> and affects <b>multicast only</b>. Unicast scope is controlled independently via <span class="tt">IP_TTL</span> / <span class="tt">IPV6_UNICAST_HOPS</span>. Per-message control data (e.g., <span class="tt">IP_MULTICAST_TTL</span> or <span class="tt">IPV6_HOPLIMIT</span> with <span class="tt">sendmsg</span>) can override this default for individual packets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl</td><td>Hop limit (IPv6) or TTL (IPv4), in the range <span class="tt">[0, 255]</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The underlying descriptor is a valid socket for <span class="tt">AF_INET</span> or <span class="tt">AF_INET6</span> (typically UDP).</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The socket’s default multicast TTL/hop limit is updated. Future multicast sends from this socket use the new value unless overridden per message.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Platform mapping</dt><dd><ul>
<li><b>IPv4:</b> <span class="tt">setsockopt(fd, IPPROTO_IP,  IP_MULTICAST_TTL,  &amp;v, sizeof(v))</span></li>
<li><b>IPv6:</b> <span class="tt">setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &amp;v, sizeof(v))</span></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error conditions</dt><dd><ul>
<li><span class="tt">ttl</span> is outside <span class="tt">[0, 255]</span>.</li>
<li>The socket is invalid or closed.</li>
<li>The socket family cannot be determined or is unsupported.</li>
<li>The underlying <span class="tt">setsockopt</span> call fails (e.g., <span class="tt">ENOTSOCK</span>, <span class="tt">EINVAL</span>, <span class="tt">ENOPROTOOPT</span>; Windows equivalents: <span class="tt">WSAENOTSOCK</span>, <span class="tt">WSAEINVAL</span>, <span class="tt">WSAENOPROTOOPT</span>).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If validation fails or the operating system rejects the option. The exception includes the OS error code and a descriptive message from <span class="tt">SocketErrorMessage(...)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Typical initial values are implementation-defined (often <span class="tt">1</span>); set an explicit value during initialization for deterministic behavior.</li>
<li>If other threads call this function concurrently with sends, packets already queued by the kernel may still carry the previous TTL/hop limit.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="group__socketopts.html#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL()</a> — query the current default TTL/hop limit.</li>
<li><a class="el" href="group__socketopts.html#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> / <a class="el" href="group__socketopts.html#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> — control/query local receipt of this socket’s own multicast.</li>
<li><a class="el" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface(const std::string&amp;)</a> — select the outgoing interface.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Limit announcements to the local link</span></div>
<div class="line"><a class="code hl_function" href="#ga996b99882efa863b01e0fff4a9782a82">MulticastSocket</a> sock;</div>
<div class="line">sock.<a class="code hl_function" href="#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;eth0&quot;</span>); <span class="comment">// choose an egress (POSIX name or index string)</span></div>
<div class="line">sock.<a class="code hl_function" href="#ga72172a10bc5ba13a908f31c791c90ec5">setTimeToLive</a>(1);              <span class="comment">// link-local only</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Widen scope later (e.g., site level)</span></div>
<div class="line">sock.<a class="code hl_function" href="#ga72172a10bc5ba13a908f31c791c90ec5">setTimeToLive</a>(32);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Confirm current default</span></div>
<div class="line"><span class="keywordtype">int</span> ttl = sock.<a class="code hl_function" href="group__socketopts.html#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL</a>();</div>
<div class="ttc" id="agroup__socketopts_html_ga55f73b7c90f7f6b507c69eead5cfc10f"><div class="ttname"><a href="group__socketopts.html#ga55f73b7c90f7f6b507c69eead5cfc10f">jsocketpp::SocketOptions::getMulticastTTL</a></div><div class="ttdeci">int getMulticastTTL() const</div><div class="ttdoc">Get the socket’s default multicast hop limit / TTL.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:415</div></div>
<div class="ttc" id="agroup__udp_html_ga72172a10bc5ba13a908f31c791c90ec5"><div class="ttname"><a href="#ga72172a10bc5ba13a908f31c791c90ec5">jsocketpp::MulticastSocket::setTimeToLive</a></div><div class="ttdeci">void setTimeToLive(int ttl)</div><div class="ttdoc">Set the time-to-live (TTL) / hop limit for outgoing multicast packets.</div><div class="ttdef"><b>Definition</b> MulticastSocket.cpp:69</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3f8607eac97767c09210d8836fdd860f" name="ga3f8607eac97767c09210d8836fdd860f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f8607eac97767c09210d8836fdd860f">&#9670;&#160;</a></span>throwSizeMismatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::throwSizeMismatch </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>expected</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>actual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>isProbedKnown</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a descriptive exception when a UDP datagram’s size differs from what was expected. </p>
<p>Emits a uniform, user-friendly error when the size of the next datagram does not match the caller’s expectation. This is typically used after either:</p><ul>
<li>A <b>size probe</b> (e.g., via <span class="tt">FIONREAD</span> or <span class="tt">MSG_PEEK|MSG_TRUNC</span>) indicated an expected size, or</li>
<li>The caller required an <b>exact</b> payload size (e.g., fixed-size read into a POD object).</li>
</ul>
<p>The exception message intentionally distinguishes whether the <span class="tt">actual</span> value came from a prior <b>probe</b> versus a <b>receive</b> operation, to aid debugging (reordering, truncation, or races between probe and read).</p>
<p>This function does not perform any I/O and does not modify socket state; it simply constructs and throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with a clear message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>The number of bytes the caller expected to be present in the next datagram. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actual</td><td>The number of bytes observed (either probed or received). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isProbedKnown</td><td>Set to <span class="tt">true</span> if <code class="param">actual</code> comes from a size probe; set to <span class="tt">false</span> if it reflects the size actually received from a <span class="tt">recv</span>/<span class="tt">recvfrom</span> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>Always throws (logical error; not a system error).</li>
<li>Uses error code <span class="tt">0</span> and a message of the form: <span class="tt">"UDP datagram size mismatch: expected &lt;E&gt;, &lt;probed|received&gt; &lt;A&gt;"</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function <b>always throws</b> and never returns. </dd>
<dd>
No system error is consulted or reported; this represents a violated size invariant in the caller’s logic rather than a kernel failure.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: after probing size, enforce exact-size semantics</span></div>
<div class="line"><span class="keyword">const</span> std::size_t probed = probeNextDatagramSize();</div>
<div class="line"><span class="keyword">const</span> std::size_t received = recvExact(buf, probed);</div>
<div class="line"><span class="keywordflow">if</span> (received != probed) {</div>
<div class="line">    <a class="code hl_function" href="#ga3f8607eac97767c09210d8836fdd860f">DatagramSocket::throwSizeMismatch</a>(probed, received, <span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__udp_html_ga3f8607eac97767c09210d8836fdd860f"><div class="ttname"><a href="#ga3f8607eac97767c09210d8836fdd860f">jsocketpp::DatagramSocket::throwSizeMismatch</a></div><div class="ttdeci">static void throwSizeMismatch(const std::size_t expected, const std::size_t actual, const bool isProbedKnown)</div><div class="ttdoc">Throw a descriptive exception when a UDP datagram’s size differs from what was expected.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:4343</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga30912969f0808f064aaeee9a79025f41" title="Low-level, single-recv primitive that copies one UDP datagram into a caller buffer.">readIntoBuffer()</a>, <a class="el" href="group__core.html#ga2fb9d73742801c62e90aeb505c618c43" title="Fallback receive size (in bytes) for UDP datagrams when the exact size is unknown.">DefaultDatagramReceiveSize</a>, <a class="el" href="group__core.html#ga25eb16703a608853bca500682345bb89" title="Maximum UDP payload size (in bytes) that is safely valid across common stacks.">MaxDatagramPayloadSafe</a> </dd></dl>

</div>
</div>
<a id="ga219654befe4bb7c3024e9fab59f0ca64" name="ga219654befe4bb7c3024e9fab59f0ca64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga219654befe4bb7c3024e9fab59f0ca64">&#9670;&#160;</a></span>tryGetRemoteSockaddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DatagramSocket::tryGetRemoteSockaddr </td>
          <td>(</td>
          <td class="paramtype">sockaddr_storage &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t &amp;</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the remote endpoint sockaddr for this socket, if available. </p>
<p>Determines the current remote peer (address + port) and writes it to the provided output buffers. The method prefers already-cached information:</p><ul>
<li>If the socket is <b>connected</b> and a remote endpoint was cached (e.g., by <span class="tt"><a class="el" href="#ga915c790c7cfde485e680ddec2edb2e74" title="Connect this UDP socket to a default peer (set the default destination).">connect()</a></span>), it copies the cached value to the outputs with <b>no syscall</b>.</li>
<li>If the socket is <b>connected</b> but no cache is present, it performs a single <span class="tt">getpeername()</span> to obtain the peer and writes it to the outputs.</li>
<li>If the socket is <b>unconnected</b>, it returns the <b>last-seen sender</b> only if your receive paths have cached one; otherwise it indicates that no remote is known yet.</li>
</ul>
<p>This function is <span class="tt">const</span> and <b>does not</b> mutate any internal cache; it only reads cached values if present, or queries the OS once when connected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Destination for the remote endpoint (<span class="tt">sockaddr_storage</span>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outLen</td><td>Receives the byte size of <code class="param">out</code> (e.g., <span class="tt">sizeof(sockaddr_in)</span> or <span class="tt">sizeof(sockaddr_in6)</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>A remote endpoint was available and has been written to <code class="param">out/<code class="param">outLen</code>.</code> </td></tr>
    <tr><td class="paramname">false</td><td>The socket is unconnected and no last-seen sender has been cached yet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The socket must be open (<span class="tt">isOpen() == true</span>).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If the socket is not open.</li>
<li>If <span class="tt">getpeername()</span> is required (connected, no cache) and it fails; the exception carries <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt">SocketErrorMessage(GetSocketError())</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1) when the remote is cached; otherwise one <span class="tt">getpeername()</span> call. </dd>
<dd>
Thread-safety: intended for the socket’s owning thread. Do not call concurrently with <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> or state mutations such as <span class="tt"><a class="el" href="#ga02b08c333a2f109a3b19ec7b3c0cecf9" title="Disconnect this UDP socket from its current default peer.">disconnect()</a></span>.</dd></dl>
<div class="fragment"><div class="line">sockaddr_storage peer{};</div>
<div class="line">socklen_t        peerLen{};</div>
<div class="line"><span class="keywordflow">if</span> (!sock.tryGetRemoteSockaddr(peer, peerLen)) {</div>
<div class="line">    <span class="comment">// Unconnected socket and no datagrams seen yet — no remote known.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Use peer / peerLen (e.g., for logging or formatting).</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga53fd92734f14407ce6c78d8df246c319" name="ga53fd92734f14407ce6c78d8df246c319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53fd92734f14407ce6c78d8df246c319">&#9670;&#160;</a></span>waitReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::waitReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8272a360bdf6e0377f31ac8ce251a837">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until the socket is ready for I/O or a timeout occurs. </p>
<p>Waits for the connected UDP socket to become ready for the requested operation(s) using a portable polling primitive (<span class="tt">poll</span> on POSIX, <span class="tt">WSAPoll</span> on Windows). This method does <b>not</b> change the socket’s blocking mode and is safe to call on both blocking and non-blocking sockets.</p>
<p><b>Timeout semantics</b></p><ul>
<li><span class="tt">timeoutMillis &lt; 0</span> → wait indefinitely (no timeout).</li>
<li><span class="tt">timeoutMillis == 0</span> → non-blocking poll (immediate). If not ready, throws <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span>.</li>
<li><span class="tt">timeoutMillis &gt; 0</span> → wait up to the specified milliseconds.</li>
</ul>
<p>If an exceptional condition is reported by the OS (e.g., <span class="tt">POLLERR</span>, <span class="tt">POLLNVAL</span>, <span class="tt">POLLHUP</span>), this function retrieves <span class="tt">SO_ERROR</span> when available and throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with that error code/message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>Readiness to wait for: <span class="tt"><a class="el" href="#gga8272a360bdf6e0377f31ac8ce251a837a7a1a5f3e79fdc91edf2f5ead9d66abb4" title="Wait until the socket is readable (one or more datagrams available).">Direction::Read</a></span>, <span class="tt"><a class="el" href="#gga8272a360bdf6e0377f31ac8ce251a837a1129c0e4d43f2d121652a7302712cff6" title="Wait until the socket is writable (can send a datagram without blocking).">Direction::Write</a></span>, or <span class="tt"><a class="el" href="#gga8272a360bdf6e0377f31ac8ce251a837a70a2a84088d405a2e3f1e3accaa16723" title="Wait until the socket is readable or writable (logical OR).">Direction::ReadWrite</a></span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Timeout in milliseconds (see semantics above).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If the requested readiness is not achieved before the timeout. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>On polling failure or detected socket error (uses <span class="tt"><a class="el" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError()</a></span> and <span class="tt"><a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage()</a></span>).</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// Example: wait up to 500 ms to become writable, then send one datagram</span></div>
<div class="line"><a class="code hl_function" href="#ga53fd92734f14407ce6c78d8df246c319">waitReady</a>(<a class="code hl_enumvalue" href="#gga8272a360bdf6e0377f31ac8ce251a837a1129c0e4d43f2d121652a7302712cff6">Direction::Write</a>, 500);</div>
<div class="line"><a class="code hl_function" href="group__internal.html#ga8826c90e1bb9e0023b75940ff4cd72f8">internal::sendExact</a>(<a class="code hl_function" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794">getSocketFd</a>(), data, len);</div>
<div class="ttc" id="agroup__udp_html_ga53fd92734f14407ce6c78d8df246c319"><div class="ttname"><a href="#ga53fd92734f14407ce6c78d8df246c319">jsocketpp::DatagramSocket::waitReady</a></div><div class="ttdeci">void waitReady(Direction dir, int timeoutMillis) const</div><div class="ttdoc">Block until the socket is ready for I/O or a timeout occurs.</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:2085</div></div>
<div class="ttc" id="agroup__udp_html_gga8272a360bdf6e0377f31ac8ce251a837a1129c0e4d43f2d121652a7302712cff6"><div class="ttname"><a href="#gga8272a360bdf6e0377f31ac8ce251a837a1129c0e4d43f2d121652a7302712cff6">jsocketpp::Direction::Write</a></div><div class="ttdeci">@ Write</div><div class="ttdoc">Wait until the socket is writable (can send a datagram without blocking).</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:415</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gafb2439eddc4ce6db4915e02ed7946444" name="gafb2439eddc4ce6db4915e02ed7946444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2439eddc4ce6db4915e02ed7946444">&#9670;&#160;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjsocketpp_1_1DatagramPacket.html">DatagramPacket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one UDP datagram using a packet’s buffer and optional explicit destination. </p>
<p>Emits exactly one datagram whose payload is <span class="tt">packet.buffer</span>. Behavior depends on whether the packet specifies a destination:</p>
<ul>
<li><b>Packet has a destination (<span class="tt">packet.hasDestination()</span> is true):</b> Uses the <b>unconnected</b> send path via <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo</a>(packet.address, packet.port, ...)</span>. That helper resolves A/AAAA, <b>skips</b> families that cannot carry the payload size, attempts one send to the first compatible candidate, and caches the last destination (without marking the socket as connected).</li>
<li><b>Packet has no destination:</b> Requires the socket to be <b>already connected</b>. The method enforces the connected peer’s protocol maxima via <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected</a>(packet.buffer.size())</span> and sends once.</li>
</ul>
<p>Processing steps: 1) Verify the socket is <b>open</b>. 2) If <span class="tt">packet.buffer.empty()</span>, return immediately (zero-length datagrams are valid but skipped). 3) If the packet carries a destination, forward to <span class="tt">sendUnconnectedTo(...)</span>. 4) Otherwise, require <span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span>, guard size with <span class="tt">enforceSendCapConnected(...)</span>, and send.</p>
<p><b>Atomicity:</b> UDP is message-oriented; on success, the <em>entire</em> <span class="tt">packet.buffer</span> is sent as one datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The packet whose <span class="tt">buffer</span> supplies the payload and whose <span class="tt">address</span>/<span class="tt">port</span> (if present) select the destination for unconnected sends.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
If <span class="tt">!packet.hasDestination()</span>, then <span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">packet.buffer.size()</span> bytes are handed to the kernel as one datagram. <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state and options are unchanged. Unconnected sends may update the cached last-remote endpoint for diagnostics, but do not connect the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open.</li>
<li>No destination in the packet <b>and</b> socket is not connected.</li>
<li>For connected sends, payload exceeds the permitted maximum for the peer’s family (detected by <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
<li>For unconnected sends, no address family can carry the payload size (surfaced by <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span>).</li>
</ul>
</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b><ul>
<li>Resolution or send failures reported by the OS (e.g., <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, <span class="tt">ENOBUFS</span>, <span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span> on non-blocking sockets), or poll-derived errors inside helpers.</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Zero-length payloads: this method returns without sending. If your protocol needs to signal an empty frame, consider a prefix/marker instead of an empty datagram.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>write(std::string_view), writeFrom(const void*, std::size_t), <a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo(std::string_view, Port, std::string_view)</a>, <a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo(std::string_view, Port, const void*, std::size_t)</a>, enforceSendCapConnected(std::size_t) </dd></dl>

</div>
</div>
<a id="ga3d9722c04df6d147773249d94df09135" name="ga3d9722c04df6d147773249d94df09135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d9722c04df6d147773249d94df09135">&#9670;&#160;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::write </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send one UDP datagram whose payload is the raw object representation of <code class="param">value</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Trivially copyable, standard-layout type whose in-memory object representation will be sent verbatim as the datagram payload. (See Implementation notes.)</td></tr>
  </table>
  </dd>
</dl>
<p>Emits exactly one datagram containing the bytes of <code class="param">value</code>. This method performs an <b>immediate</b> send attempt (no pre-wait). Use <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> or <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span> if you need the call to block until the socket is writable.</p>
<p>Processing steps:</p><ol type="1">
<li>Verifies the socket is <b>open</b> and <b>connected</b>.</li>
<li>Computes <span class="tt">sizeof(T)</span> and enforces address-family maxima via <span class="tt">enforceSendCapConnected(sizeof(T))</span> to preempt guaranteed <span class="tt">EMSGSIZE</span> failures.</li>
<li>Transmits the payload in a <b>single</b> system call; on success, the <em>entire</em> object representation is handed to the kernel as one UDP datagram (no partial sends).</li>
</ol>
<p>⚠️ <b>Serialization &amp; portability</b></p><ul>
<li>The bytes sent are the raw object representation of <span class="tt">T</span> (including padding). Endianness, padding, and ABI differences make this suitable mainly for homogeneous peers or debugging. For interoperable protocols, prefer explicit serialization (fixed-width integers in network byte order, packed layouts, etc.).</li>
<li>If <span class="tt">T</span> contains padding, ensure it is initialized to avoid leaking stale memory.</li>
</ul>
<p><b>Atomicity:</b> UDP is message-oriented; on success, there are no partial sends. Any failure is reported via exception and <b>no</b> bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to send; its bytes (object representation) become the datagram payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">sizeof(T)</span> bytes are queued to the kernel as a single datagram.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open or not connected.</li>
<li>Payload exceeds the permitted maximum for the connected peer’s family (detected by <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
</ul>
</li>
<li><b>System (OS error code + <span class="tt">SocketErrorMessage(...)</span>):</b><ul>
<li>Transient non-blocking condition (<span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span>).</li>
<li>Resource/network issues (<span class="tt">ENOBUFS</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, etc.).</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method does <b>not</b> wait for writability. Use <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> (infinite wait) or <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span> (bounded wait) for backpressure handling.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>write(std::string_view), <a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a>, <a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a>, <a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo(std::string_view, Port, std::string_view)</a>, <a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></dd></dl>
<dl class="section user"><dt>Implementation notes</dt><dd>Uses <span class="tt">std::bit_cast&lt;std::array&lt;std::byte, sizeof(T)&gt;&gt;</span> (C++20) to capture the exact object representation. Compile-time constraints: <div class="fragment"><div class="line"><span class="keyword">static_assert</span>(std::is_trivially_copyable_v&lt;T&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_standard_layout_v&lt;T&gt;);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga22f349cb1f93f2fc18e4c6e19d7ba1ff" name="ga22f349cb1f93f2fc18e4c6e19d7ba1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22f349cb1f93f2fc18e4c6e19d7ba1ff">&#9670;&#160;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::write </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one UDP datagram to the connected peer from a raw byte span (no pre-wait). </p>
<p>Emits exactly one datagram containing the bytes referenced by <code class="param">data</code>. This method performs an <b>immediate</b> send attempt:</p>
<ol type="1">
<li>Verifies the socket is <b>open</b> and <b>connected</b>.</li>
<li>If the span is empty, it returns immediately (zero-length datagrams are valid in UDP, but this implementation skips the syscall as a micro-optimization).</li>
<li>Enforces protocol-level size limits for the connected peer’s address family via <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected</a>(data.size())</span> to preempt guaranteed <span class="tt">EMSGSIZE</span> failures.</li>
<li>Transmits the payload in a <b>single</b> system call (no partial sends).</li>
</ol>
<p>This function does <b>not</b> poll for writability. On non-blocking sockets, if the send buffer is full, the send may fail (e.g., <span class="tt">EWOULDBLOCK</span>/<span class="tt">WSAEWOULDBLOCK</span>) and a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown. If you need backpressure handling, use <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> (infinite wait) or <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span> (bounded wait) instead.</p>
<p><b>Atomicity:</b> UDP is message-oriented; on success the <em>entire</em> span is sent as one datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Contiguous read-only bytes to send as a single datagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">data.size()</span> bytes are handed to the kernel as one datagram.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open or not connected.</li>
<li>Payload exceeds the permitted maximum for the connected peer’s family (detected by <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
</ul>
</li>
<li><b>System (OS error code + <span class="tt">SocketErrorMessage(...)</span>):</b><ul>
<li>Transient non-blocking condition (<span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span>).</li>
<li>Resource/network issues (<span class="tt">ENOBUFS</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, etc.).</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is ideal when you already have binary data as bytes. For textual data, prefer <span class="tt">write(std::string_view)</span>. For POD types, see <span class="tt"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write</a>&lt;T&gt;(const T&amp;)</span>. </dd>
<dd>
Zero-length payloads: this method returns without sending. If you must signal an “empty message,” consider a protocol marker instead of an empty datagram.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>write(std::string_view), <a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a>, <a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a>, write(const T&amp;), writeFrom(const void*, std::size_t), writev(std::span&lt;const std::string_view&gt;), <a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send raw binary using std::byte</span></div>
<div class="line">std::array&lt;std::byte, 4&gt; magic{ std::byte{0xDE}, std::byte{0xAD},</div>
<div class="line">                                std::byte{0xBE}, std::byte{0xEF} };</div>
<div class="line">sock.write(std::span&lt;const std::byte&gt;{magic});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// From an existing buffer:</span></div>
<div class="line"><span class="keyword">const</span> std::byte* p = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::byte*<span class="keyword">&gt;</span>(buffer.data());</div>
<div class="line">sock.write(std::span&lt;const std::byte&gt;{p, buffer.size()});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga96bc239f42265d5c408c8f15046f24c8" name="ga96bc239f42265d5c408c8f15046f24c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96bc239f42265d5c408c8f15046f24c8">&#9670;&#160;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::write </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one UDP datagram to the currently connected peer (no pre-wait). </p>
<p>Emits exactly one datagram containing the bytes in <code class="param">message</code>. This method performs an immediate send attempt:</p>
<ol type="1">
<li>Validates that the socket is <b>open</b> and <b>connected</b>.</li>
<li>If the payload is empty, it returns immediately (zero-length datagrams are valid per UDP, but this implementation avoids the syscall as a micro-optimization).</li>
<li>Enforces protocol-level size limits for the connected peer’s address family via <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected</a>(message.size())</span> (prevents guaranteed <span class="tt">EMSGSIZE</span> failures).</li>
<li>Calls the internal single-syscall sender to transmit the datagram.</li>
</ol>
<p>This function does <b>not</b> poll or wait for writability. On non-blocking sockets, if the send buffer is temporarily full, the underlying send may fail (e.g., <span class="tt">EWOULDBLOCK</span>/<span class="tt">WSAEWOULDBLOCK</span>) and a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown. If you need the method to wait until the socket is writable, use <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> or one of the timeout variants instead.</p>
<p><b>Atomicity:</b> UDP is message-oriented; on success, the <em>entire</em> payload is sent in one datagram (no partial sends). Failures are reported via exceptions—no bytes are considered transmitted on exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Bytes to send as a single datagram. Accepts <span class="tt">std::string</span>, string literals, and other contiguous character sequences via implicit conversion to <span class="tt">std::string_view</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">message.size()</span> bytes are handed to the kernel as a single datagram. The connection state and socket options are unchanged.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical errors (error code = 0):</b><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open or not connected.</li>
<li>Payload exceeds the permitted maximum for the connected peer’s family (detected by <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
</ul>
</li>
<li><b>System errors (OS error code + <span class="tt">SocketErrorMessage(...)</span>):</b><ul>
<li>Transient non-blocking condition (<span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span>).</li>
<li>Resource/network issues (<span class="tt">ENOBUFS</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, etc.).</li>
<li>Other send failures surfaced by the OS.</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Zero-length payloads: this method returns without sending. If you need to intentionally transmit an empty datagram as a signal, use an explicit flag in your protocol or send a 1-byte marker instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a>, <a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a>, <a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo()</a>, <a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga4b4c631816f82eea0b6048a16682079e">DatagramSocket</a> sock;</div>
<div class="line"><span class="comment">// ... socket opened and connected elsewhere ...</span></div>
<div class="line">sock.<a class="code hl_function" href="#ga96bc239f42265d5c408c8f15046f24c8">write</a>(<span class="stringliteral">&quot;ping&quot;</span>);                      <span class="comment">// immediate attempt; may throw on EWOULDBLOCK</span></div>
<div class="line">sock.<a class="code hl_function" href="#ga96bc239f42265d5c408c8f15046f24c8">write</a>(std::string_view{<span class="stringliteral">&quot;hello&quot;</span>});   <span class="comment">// same, using string_view explicitly</span></div>
<div class="ttc" id="agroup__udp_html_ga96bc239f42265d5c408c8f15046f24c8"><div class="ttname"><a href="#ga96bc239f42265d5c408c8f15046f24c8">jsocketpp::DatagramSocket::write</a></div><div class="ttdeci">void write(std::string_view message) const</div><div class="ttdoc">Send one UDP datagram to the currently connected peer (no pre-wait).</div><div class="ttdef"><b>Definition</b> DatagramSocket.cpp:458</div></div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a id="gabb163d329ca77150019c3e430f415209" name="gabb163d329ca77150019c3e430f415209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb163d329ca77150019c3e430f415209">&#9670;&#160;</a></span>writeAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::writeAll </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one UDP datagram to the connected peer, waiting indefinitely for writability. </p>
<p>Emits exactly one datagram containing <code class="param">message</code>. Unlike <span class="tt"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write()</a></span>, this method <b>pre-waits</b> for the socket to become writable so it behaves consistently on both blocking and non-blocking sockets:</p>
<ol type="1">
<li>Verifies the socket is <b>open</b> and <b>connected</b>.</li>
<li>If the payload is empty, returns immediately (zero-length UDP datagrams are valid, but this implementation skips the syscall as a micro-optimization).</li>
<li>Enforces protocol-level size limits for the connected peer via <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected</a>(message.size())</span>.</li>
<li>Calls <span class="tt"><a class="el" href="#ga53fd92734f14407ce6c78d8df246c319" title="Block until the socket is ready for I/O or a timeout occurs.">waitReady</a>(<a class="el" href="#gga8272a360bdf6e0377f31ac8ce251a837a1129c0e4d43f2d121652a7302712cff6" title="Wait until the socket is writable (can send a datagram without blocking).">Direction::Write</a>, -1)</span> to wait <b>without timeout</b> until writable.</li>
<li>Transmits the datagram in a <b>single</b> syscall (no partial sends).</li>
</ol>
<p><b>Atomicity:</b> On success the <em>entire</em> payload is sent in one datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Bytes to send as a single datagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">message.size()</span> bytes are handed to the kernel as one datagram.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b> socket not open/connected; payload exceeds permitted maximum for the connected family (via <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b> polling or send failures.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method never throws <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> because it waits indefinitely. For a bounded wait, use <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>write(std::string_view), writeWithTimeout(std::string_view, int), writevAll(std::span&lt;const std::string_view&gt;), <a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a>, <a class="el" href="#ga53fd92734f14407ce6c78d8df246c319" title="Block until the socket is ready for I/O or a timeout occurs.">waitReady()</a> </dd></dl>

</div>
</div>
<a id="ga5fd49284f279d17c851a356caafdd216" name="ga5fd49284f279d17c851a356caafdd216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fd49284f279d17c851a356caafdd216">&#9670;&#160;</a></span>writeFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::writeFrom </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one UDP datagram to the connected peer from a raw memory buffer (no pre-wait). </p>
<p>Emits exactly one datagram containing the first <code class="param">len</code> bytes starting at <code class="param">data</code>. This method performs an <b>immediate</b> send attempt (it does not poll for writability):</p>
<ol type="1">
<li>Verifies the socket is <b>open</b> and <b>connected</b>.</li>
<li>If <code class="param">len</code> is zero, returns immediately (zero-length UDP datagrams are valid, but this implementation skips the syscall as a micro-optimization).</li>
<li>Enforces protocol-level size limits for the connected peer’s family via <span class="tt">enforceSendCapConnected(len)</span> to preempt guaranteed <span class="tt">EMSGSIZE</span>.</li>
<li>Transmits the datagram in a <b>single</b> system call (no partial sends).</li>
</ol>
<p>This function does <b>not</b> pre-wait for writability. On non-blocking sockets, if the send buffer is temporarily full, the underlying send may fail (e.g., <span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span>) and a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown. For blocking behavior, use <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> (infinite wait) or <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span> (bounded wait).</p>
<p><b>Ownership/Lifetime:</b> The memory referenced by <code class="param">data</code> is not copied or retained beyond the duration of the call; it must remain valid and readable until the call returns.</p>
<p><b>Atomicity:</b> UDP is message-oriented; on success, the <em>entire</em> buffer is sent as one datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the first byte of the payload. May be <span class="tt">nullptr</span> iff <code class="param">len</code> == 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to send as a single datagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span> </dd>
<dd>
<span class="tt">data != nullptr || len == 0</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <code class="param">len</code> bytes are handed to the kernel as one datagram. <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state and options are unchanged.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open or not connected.</li>
<li>Payload exceeds the permitted maximum for the connected peer’s family (detected by <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
</ul>
</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b><ul>
<li>Transient non-blocking condition (<span class="tt">EWOULDBLOCK</span>, <span class="tt">WSAEWOULDBLOCK</span>).</li>
<li>Resource/network issues (<span class="tt">ENOBUFS</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, etc.).</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your payload is already in <span class="tt">std::byte</span> form, prefer <span class="tt"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write</a>(std::span&lt;const std::byte&gt;)</span>. For text, prefer <span class="tt">write(std::string_view)</span>. For POD objects, consider <span class="tt"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write</a>&lt;T&gt;(const T&amp;)</span>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>write(std::string_view), write(std::span&lt;const std::byte&gt;), writeAll(std::string_view), writeWithTimeout(std::string_view, int), writev(std::span&lt;const std::string_view&gt;), enforceSendCapConnected(std::size_t)</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send a raw buffer</span></div>
<div class="line">std::array&lt;std::uint8_t, 4&gt; buf{0xDE, 0xAD, 0xBE, 0xEF};</div>
<div class="line">sock.writeFrom(buf.data(), buf.size());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// From a std::vector&lt;char&gt;</span></div>
<div class="line">std::vector&lt;char&gt; payload = get_payload();</div>
<div class="line">sock.writeFrom(payload.data(), payload.size());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaffb1e99dbfcac72f8936e43d2d35467e" name="gaffb1e99dbfcac72f8936e43d2d35467e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffb1e99dbfcac72f8936e43d2d35467e">&#9670;&#160;</a></span>writePrefixed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::writePrefixed </td>
          <td>(</td>
          <td class="paramtype">const std::span&lt; const std::byte &gt;</td>          <td class="paramname"><span class="paramname"><em>payload</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a length-prefixed UDP datagram to the connected peer from a byte span (no pre-wait). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Unsigned integral type for the length prefix.</td></tr>
  </table>
  </dd>
</dl>
<p>Builds <b>[ prefix(T, big-endian) | payload ]</b> and forwards to <span class="tt"><a class="el" href="#ga463c1511ac0622b623fa2937314e1239" title="Build and send a length-prefixed UDP datagram to the connected peer (no pre-wait).">sendPrefixedConnected</a>&lt;T&gt;()</span>. Zero-length payloads yield a prefix-only datagram. This method performs an <b>immediate</b> send attempt (no pre-wait).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Binary payload to append after the length prefix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>(same categories as the <span class="tt">std::string_view</span> overload).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>sendPrefixedConnected&lt;T&gt;(std::span&lt;const std::byte&gt;), writePrefixed&lt;T&gt;(std::string_view), <a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE&lt;T&gt;(std::size_t)</a>, enforceSendCapConnected(std::size_t) </dd></dl>

</div>
</div>
<a id="gaa848031032de9438dd560a8a9eba38d6" name="gaa848031032de9438dd560a8a9eba38d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa848031032de9438dd560a8a9eba38d6">&#9670;&#160;</a></span>writePrefixed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::writePrefixed </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>payload</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a length-prefixed UDP datagram to the connected peer from text bytes (no pre-wait). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Unsigned integral type for the length prefix (e.g., <span class="tt">std::uint8_t</span>, <span class="tt">std::uint16_t</span>, <span class="tt">std::uint32_t</span>, <span class="tt">std::uint64_t</span>). A compile-time check in the helper enforces this.</td></tr>
  </table>
  </dd>
</dl>
<p>Wraps the payload as <b>[ prefix(T, big-endian) | payload ]</b> and forwards to <span class="tt"><a class="el" href="#ga463c1511ac0622b623fa2937314e1239" title="Build and send a length-prefixed UDP datagram to the connected peer (no pre-wait).">sendPrefixedConnected</a>&lt;T&gt;()</span>. Zero-length payloads are valid: a prefix-only datagram is sent. This method performs an <b>immediate</b> send attempt (no pre-wait).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Text bytes to send after the length prefix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error=0):</b> socket not open/connected; <span class="tt">payload.size()</span> exceeds <span class="tt">std::numeric_limits&lt;T&gt;::max()</span>; total size exceeds the connected family’s limit.</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b> send failures (e.g., <span class="tt">EWOULDBLOCK</span>, <span class="tt">ENOBUFS</span>).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>sendPrefixedConnected&lt;T&gt;(std::span&lt;const std::byte&gt;), writePrefixedTo&lt;T&gt;(std::string_view, Port, std::string_view), <a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE&lt;T&gt;(std::size_t)</a>, enforceSendCapConnected(std::size_t) </dd></dl>

</div>
</div>
<a id="ga568d0cb2e5888b3dca1f949e171c98ec" name="ga568d0cb2e5888b3dca1f949e171c98ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga568d0cb2e5888b3dca1f949e171c98ec">&#9670;&#160;</a></span>writePrefixedTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::writePrefixedTo </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::span&lt; const std::byte &gt;</td>          <td class="paramname"><span class="paramname"><em>payload</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a length-prefixed UDP datagram to (host, port) from a byte span (unconnected path). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Unsigned integral type for the length prefix.</td></tr>
  </table>
  </dd>
</dl>
<p>Builds <b>[ prefix(T, big-endian) | payload ]</b> and forwards to <span class="tt"><a class="el" href="#ga5c4761b07760b1eadf84b9fbed700c98" title="Build and send a length-prefixed UDP datagram to (host, port) on the unconnected path.">sendPrefixedUnconnected</a>&lt;T&gt;()</span>. The helper resolves and selects a compatible destination (skipping families that can’t carry the frame) and sends once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Destination hostname or numeric address (IPv4/IPv6). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Destination UDP port (&gt; 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Binary payload to append after the length prefix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>(same categories as the text overload).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga5c4761b07760b1eadf84b9fbed700c98" title="Build and send a length-prefixed UDP datagram to (host, port) on the unconnected path.">sendPrefixedUnconnected&lt;T&gt;(std::string_view, Port, std::span&lt;const std::byte&gt;)</a>, writePrefixedTo&lt;T&gt;(std::string_view, Port, std::string_view), <a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE&lt;T&gt;(std::size_t)</a>, <a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo(std::string_view, Port, const void*, std::size_t)</a> </dd></dl>

</div>
</div>
<a id="gaf2398346dc295a530a70cc0f11bc5928" name="gaf2398346dc295a530a70cc0f11bc5928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2398346dc295a530a70cc0f11bc5928">&#9670;&#160;</a></span>writePrefixedTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::writePrefixedTo </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>payload</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a length-prefixed UDP datagram to (host, port) from text bytes (unconnected path). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Unsigned integral type for the length prefix.</td></tr>
  </table>
  </dd>
</dl>
<p>Builds <b>[ prefix(T, big-endian) | payload ]</b> and forwards to <span class="tt"><a class="el" href="#ga5c4761b07760b1eadf84b9fbed700c98" title="Build and send a length-prefixed UDP datagram to (host, port) on the unconnected path.">sendPrefixedUnconnected</a>&lt;T&gt;()</span>, which resolves A/AAAA, skips families that cannot carry the frame, and sends once to the first compatible destination. Zero-length payloads produce a prefix-only datagram.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Destination hostname or numeric address (IPv4/IPv6). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Destination UDP port (&gt; 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Text bytes to append after the length prefix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error=0):</b> socket not open; <span class="tt">payload.size()</span> exceeds <span class="tt">std::numeric_limits&lt;T&gt;::max()</span>; or no address family can carry the total size (surfaced by the helper).</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b> resolution/send failures.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga5c4761b07760b1eadf84b9fbed700c98" title="Build and send a length-prefixed UDP datagram to (host, port) on the unconnected path.">sendPrefixedUnconnected&lt;T&gt;(std::string_view, Port, std::span&lt;const std::byte&gt;)</a>, writePrefixedTo&lt;T&gt;(std::string_view, Port, std::span&lt;const std::byte&gt;), <a class="el" href="#ga6de9a0542180215e2f2520148c71f1b4" title="Encode a length value into a fixed-size, big-endian (network-order) byte array.">encodeLengthPrefixBE&lt;T&gt;(std::size_t)</a>, <a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo(std::string_view, Port, const void*, std::size_t)</a> </dd></dl>

</div>
</div>
<a id="gac74d3b4a3f6c64919382f8d3a9805eb8" name="gac74d3b4a3f6c64919382f8d3a9805eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac74d3b4a3f6c64919382f8d3a9805eb8">&#9670;&#160;</a></span>writeTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::DatagramSocket::writeTo </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send one unconnected UDP datagram to (host, port) containing the raw bytes of <code class="param">value</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Trivially copyable, standard-layout type whose in-memory object representation will be sent verbatim as the datagram payload. Compile-time checks in the implementation enforce these constraints.</td></tr>
  </table>
  </dd>
</dl>
<p>Emits exactly one datagram whose payload is the raw bytes of <code class="param">value</code>. This overload uses the unconnected send path and delegates to <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span>, which:</p>
<ul>
<li>Resolves A/AAAA candidates for <code class="param">host</code>.</li>
<li>Skips any address family whose theoretical UDP maximum cannot carry <span class="tt">sizeof(T)</span>.</li>
<li>Attempts a single send to the first compatible candidate, returning on success.</li>
<li>Caches the last destination endpoint for diagnostics (does not connect the socket).</li>
</ul>
<p>Steps performed by this method: 1) Verify the socket is open. 2) If <span class="tt">sizeof(T) == 0</span>, return immediately. 3) Bit-cast <code class="param">value</code> to a contiguous byte buffer. 4) Forward to <span class="tt">sendUnconnectedTo(host, port, buf, sizeof(T))</span>.</p>
<p>This function does not poll for writability. On non-blocking sockets, if a send is attempted and the send buffer is full, the underlying send may fail (<span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span>) and will be surfaced as a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>. For blocking semantics on a connected socket, prefer <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> or <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span>.</p>
<p>Serialization and portability:</p><ul>
<li>The bytes sent are the raw object representation of <span class="tt">T</span> (including any padding). Endianness, padding, and ABI differences mean this is typically suitable only for homogeneous peers or debugging. For interoperable protocols, use explicit serialization (fixed-width integers in network byte order, packed layouts, and so on).</li>
<li>If <span class="tt">T</span> contains padding, ensure it is initialized to avoid leaking stale memory.</li>
</ul>
<p>Atomicity:</p><ul>
<li>UDP is message-oriented; on success, the entire <span class="tt">sizeof(T)</span> bytes are sent as one datagram. On exception, no bytes are considered transmitted.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Destination hostname or numeric address (IPv4/IPv6). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Destination UDP port (&gt; 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value whose bytes form the datagram payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">sizeof(T)</span> bytes are handed to the kernel as one datagram. <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state and options are unchanged. The last-remote endpoint may be cached internally for diagnostics.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>Logical (error code = 0):<ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open.</li>
<li>No address family can carry <span class="tt">sizeof(T)</span> (for example, payload exceeds IPv4 limit and only A records are available; surfaced by <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span> with a clear message).</li>
</ul>
</li>
<li>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):<ul>
<li>Resolution or send failures reported by the OS (for example, <span class="tt">EAI_*</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, <span class="tt">ENOBUFS</span>, <span class="tt">EWOULDBLOCK</span>).</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo(std::string_view, Port, std::string_view)</a>, write(std::string_view), writeFrom(const void*, std::size_t), <a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo(std::string_view, Port, const void*, std::size_t)</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send a POD header to a destination without connecting the socket</span></div>
<div class="line"><span class="keyword">struct </span>Header {</div>
<div class="line">  std::uint32_t magic;</div>
<div class="line">  std::uint16_t version;</div>
<div class="line">  std::uint16_t flags;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_trivially_copyable_v&lt;Header&gt; &amp;&amp; std::is_standard_layout_v&lt;Header&gt;);</div>
<div class="line"> </div>
<div class="line">Header h{0xABCD1234u, 1u, 0u};</div>
<div class="line">sock.writeTo(<span class="stringliteral">&quot;example.com&quot;</span>, 5000, h);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga0239bea129ff0084aba9cd68e8a66f3c" name="ga0239bea129ff0084aba9cd68e8a66f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0239bea129ff0084aba9cd68e8a66f3c">&#9670;&#160;</a></span>writeTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::writeTo </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one unconnected UDP datagram to (host, port) from a raw byte span (no pre-wait). </p>
<p>Emits exactly one datagram containing <code class="param">data</code> to the specified destination. This overload uses the unconnected send path and delegates to <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span>, which:</p>
<ul>
<li>Resolves A/AAAA candidates for <code class="param">host</code>.</li>
<li>Skips any address family whose theoretical UDP maximum cannot carry the payload size (IPv4 vs IPv6 caps).</li>
<li>Attempts a single send to the first compatible candidate, returning on success.</li>
<li>Caches the last destination endpoint for diagnostics (does not connect the socket).</li>
</ul>
<p>Steps performed by this method: 1) Verify the socket is open. 2) If <span class="tt">data.empty()</span>, return immediately (zero-length UDP datagrams are valid, but this implementation skips the syscall as a micro-optimization). 3) Forward to <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo</a>(host, port, data.data(), data.size())</span>.</p>
<p>This function does not poll for writability. On non-blocking sockets, if an attempt is made and the send buffer is full, the underlying send may fail (<span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span>) and will be surfaced as a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>. For blocking semantics on a connected socket, prefer <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> or <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span>.</p>
<p><b>Atomicity:</b> UDP is message-oriented; on success, the entire span is sent as one datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Destination hostname or numeric address (IPv4/IPv6). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Destination UDP port (&gt; 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Contiguous read-only bytes to send as a single datagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">data.size()</span> bytes are handed to the kernel as one datagram. <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state and options are unchanged. The last-remote endpoint may be cached internally for diagnostics.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>Logical (error code = 0):<ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open.</li>
<li>No address family can carry the datagram size (for example, payload exceeds IPv4 limit and only A records are available; surfaced by <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span> with a clear message).</li>
</ul>
</li>
<li>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):<ul>
<li>Resolution or send failures reported by the OS (for example, <span class="tt">EAI_*</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, <span class="tt">ENOBUFS</span>, <span class="tt">EWOULDBLOCK</span>).</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Family-specific size enforcement (IPv4 vs IPv6) and destination selection are handled inside <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span>. This method performs no pre-wait; if you need bounded or indefinite waiting, connect the socket and use <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span> or <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafed0d7b0bbe66da82d795d013ed2b29d" title="Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait).">writeTo(std::string_view, Port, std::string_view)</a>, write(std::span&lt;const std::byte&gt;), writeAll(std::string_view), writeWithTimeout(std::string_view, int), <a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo(std::string_view, Port, const void*, std::size_t)</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send binary payload to a destination without connecting the socket</span></div>
<div class="line">std::array&lt;std::byte, 4&gt; magic{std::byte{0xDE}, std::byte{0xAD},</div>
<div class="line">                               std::byte{0xBE}, std::byte{0xEF}};</div>
<div class="line">sock.writeTo(<span class="stringliteral">&quot;239.0.0.1&quot;</span>, 5000, std::span&lt;const std::byte&gt;{magic});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// From a dynamic buffer</span></div>
<div class="line">std::vector&lt;std::byte&gt; payload(3);</div>
<div class="line">payload[0] = std::byte{0x01};</div>
<div class="line">payload[1] = std::byte{0x02};</div>
<div class="line">payload[2] = std::byte{0x03};</div>
<div class="line">sock.writeTo(<span class="stringliteral">&quot;2001:db8::1&quot;</span>, 6000, std::span&lt;const std::byte&gt;{payload.data(), payload.size()});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gafed0d7b0bbe66da82d795d013ed2b29d" name="gafed0d7b0bbe66da82d795d013ed2b29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafed0d7b0bbe66da82d795d013ed2b29d">&#9670;&#160;</a></span>writeTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::writeTo </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one unconnected UDP datagram to (host, port) from text bytes (no pre-wait). </p>
<p>Emits exactly one datagram containing <code class="param">message</code> to the specified destination. This overload uses the unconnected send path and delegates the heavy lifting to <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span>, which:</p>
<ul>
<li>Resolves A/AAAA candidates for <code class="param">host</code>.</li>
<li><b>Skips</b> any address family whose theoretical UDP maximum cannot carry the payload size (IPv4 vs IPv6 caps).</li>
<li>Attempts a single send to the first compatible candidate, returning on success.</li>
<li>Caches the last destination endpoint for diagnostics (does <b>not</b> mark the socket as connected).</li>
</ul>
<p>Steps performed by this method: 1) Verify the socket is <b>open</b>. 2) If <span class="tt">message.empty()</span>, return immediately (zero-length UDP datagrams are valid, but this implementation skips the syscall as a micro-optimization). 3) Forward to <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo</a>(host, port, message.data(), message.size())</span>.</p>
<p>This function does <b>not</b> poll for writability. On non-blocking sockets, if an attempt is made and the send buffer is full, the underlying send may fail (<span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span>) and will be surfaced as a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>. For blocking semantics on a <em>connected</em> socket, prefer <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> or <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span>.</p>
<p><b>Atomicity:</b> UDP is message-oriented; on success, the <em>entire</em> payload is sent as one datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Destination hostname or numeric address (IPv4/IPv6). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Destination UDP port (&gt; 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Bytes to send as a single datagram (accepts <span class="tt">std::string</span>, string literals, etc., via implicit conversion to <span class="tt">std::string_view</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">message.size()</span> bytes are handed to the kernel as one datagram. <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state and options are unchanged. The last-remote endpoint may be cached internally for diagnostics.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not open.</li>
<li>No address family can carry the datagram size (e.g., payload exceeds IPv4 limit and only A records are available; surfaced by <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span> with a clear message).</li>
</ul>
</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b><ul>
<li>Resolution or send failures reported by the OS (e.g., <span class="tt">EAI_*</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, <span class="tt">ENOBUFS</span>, <span class="tt">EWOULDBLOCK</span>).</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Family-specific size enforcement (IPv4 vs IPv6) and destination selection are handled inside <span class="tt"><a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo()</a></span>. This method performs no pre-wait; if you need bounded or indefinite waiting, connect the socket and use <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span> or <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>write(std::string_view), writeAll(std::string_view), writeWithTimeout(std::string_view, int), writePrefixedTo&lt;T&gt;(std::string_view, Port, std::string_view), <a class="el" href="#gab12e38ad202aa788d89980864d3e83bc" title="Resolve and send one unconnected UDP datagram to the first compatible destination.">sendUnconnectedTo(std::string_view, Port, const void*, std::size_t)</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send a message to a host/port without connecting the socket</span></div>
<div class="line">sock.writeTo(<span class="stringliteral">&quot;example.com&quot;</span>, 8125, <span class="stringliteral">&quot;metric:1|c&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// IPv6 numeric address is fine too:</span></div>
<div class="line">sock.writeTo(<span class="stringliteral">&quot;2001:db8::1&quot;</span>, 5000, <span class="stringliteral">&quot;hello&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga6fff302b8483605f25254bf0a1f00baf" name="ga6fff302b8483605f25254bf0a1f00baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fff302b8483605f25254bf0a1f00baf">&#9670;&#160;</a></span>writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::writev </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::string_view &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one UDP datagram to the connected peer by concatenating multiple fragments (no pre-wait). </p>
<p>Emits exactly one datagram whose payload is the concatenation of all strings in <code class="param">buffers</code>. This method performs an <b>immediate</b> send attempt (it does not wait for writability):</p>
<ol type="1">
<li>Verifies the socket is <b>open</b> and <b>connected</b>.</li>
<li>Computes the total byte count <span class="tt">sum(buffers[i].size())</span>. If the sum is zero, returns immediately (zero-length UDP datagrams are valid, but this implementation skips the syscall).</li>
<li>Enforces protocol-level maxima for the connected peer’s family via <span class="tt">enforceSendCapConnected(total)</span> to preempt guaranteed <span class="tt">EMSGSIZE</span>.</li>
<li>Sends in a <b>single</b> syscall:<ul>
<li>Fast path: if there is exactly one fragment, it is sent directly.</li>
<li>Otherwise, the fragments are coalesced into a temporary contiguous buffer and sent once.</li>
</ul>
</li>
</ol>
<p>This function does <b>not</b> pre-wait for writability. On non-blocking sockets, if the send buffer is full, the send may fail (e.g., <span class="tt">EWOULDBLOCK</span> / <span class="tt">WSAEWOULDBLOCK</span>) and a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown. Use <span class="tt"><a class="el" href="#gac69845676b984d0876f7ad9311571846" title="Send one UDP datagram to the connected peer by concatenating multiple fragments, waiting indefinitely...">writevAll()</a></span> or <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span> for blocking behavior.</p>
<p><b>Atomicity:</b> UDP is message-oriented; on success the <em>entire</em> concatenated payload is sent as a single datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Sequence of string fragments that will be concatenated in-order into the datagram payload. Individual elements may be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly the sum of all fragment sizes is handed to the kernel as one datagram.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b> socket not open/connected; total payload exceeds the permitted maximum for the connected peer’s family (detected by <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b> send failures such as <span class="tt">EWOULDBLOCK</span>, <span class="tt">ENOBUFS</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, etc.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you later add a scatter/gather <span class="tt">internal::sendExactv(...)</span>, this method can switch to a vectored send to avoid the temporary copy in the multi-fragment case.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>writevAll(std::span&lt;const std::string_view&gt;), write(std::string_view), writeAll(std::string_view), writeWithTimeout(std::string_view, int), enforceSendCapConnected(std::size_t)</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send header + body as one UDP datagram</span></div>
<div class="line">std::string_view header = <span class="stringliteral">&quot;HDR:&quot;</span>;</div>
<div class="line">std::string_view body   = <span class="stringliteral">&quot;payload&quot;</span>;</div>
<div class="line">sock.writev({header, body});  <span class="comment">// immediate attempt; may throw on EWOULDBLOCK</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gac69845676b984d0876f7ad9311571846" name="gac69845676b984d0876f7ad9311571846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac69845676b984d0876f7ad9311571846">&#9670;&#160;</a></span>writevAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::writevAll </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::string_view &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one UDP datagram to the connected peer by concatenating multiple fragments, waiting indefinitely. </p>
<p>Emits exactly one datagram whose payload is the concatenation of all strings in <code class="param">buffers</code>. Unlike <span class="tt"><a class="el" href="#ga6fff302b8483605f25254bf0a1f00baf" title="Send one UDP datagram to the connected peer by concatenating multiple fragments (no pre-wait).">writev()</a></span>, this method <b>pre-waits</b> for writability so it behaves consistently on both blocking and non-blocking sockets:</p>
<ol type="1">
<li>Verifies the socket is <b>open</b> and <b>connected</b>.</li>
<li>Computes the total byte count <span class="tt">sum(buffers[i].size())</span>. If the sum is zero, returns immediately (zero-length UDP datagrams are valid, but this implementation skips the syscall).</li>
<li>Enforces protocol-level maxima for the connected peer’s family via <span class="tt">enforceSendCapConnected(total)</span> to preempt guaranteed <span class="tt">EMSGSIZE</span>.</li>
<li>Calls <span class="tt"><a class="el" href="#ga53fd92734f14407ce6c78d8df246c319" title="Block until the socket is ready for I/O or a timeout occurs.">waitReady</a>(<a class="el" href="#gga8272a360bdf6e0377f31ac8ce251a837a1129c0e4d43f2d121652a7302712cff6" title="Wait until the socket is writable (can send a datagram without blocking).">Direction::Write</a>, -1)</span> to wait <b>without timeout</b> until the socket is writable (poll errors are surfaced as <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>).</li>
<li>Sends in a <b>single</b> syscall:<ul>
<li>Fast path: if there is exactly one fragment, it is sent directly.</li>
<li>Otherwise, the fragments are coalesced into a temporary contiguous buffer and sent once.</li>
</ul>
</li>
</ol>
<p><b>Atomicity:</b> UDP is message-oriented; on success, the <em>entire</em> concatenated payload is sent as a single datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Sequence of string fragments concatenated in-order into the datagram payload. Individual elements may be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly the sum of all fragment sizes is handed to the kernel as one datagram. <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state and options are unchanged.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b> socket not open/connected; total payload exceeds the permitted maximum for the connected peer’s family (detected by <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b> polling or send failures (e.g., <span class="tt">POLLERR</span>, <span class="tt">POLLNVAL</span>, <span class="tt">POLLHUP</span>, <span class="tt">ENOBUFS</span>, <span class="tt">ENETUNREACH</span>, <span class="tt">EHOSTUNREACH</span>, etc.).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method never throws <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> because it waits indefinitely. For a bounded wait, use <span class="tt"><a class="el" href="#ga4a22b644010f53c741a8ea733e4abf0f" title="Send one UDP datagram to the connected peer, waiting up to timeoutMillis for writability.">writeWithTimeout()</a></span>. </dd>
<dd>
If you later add a scatter/gather <span class="tt">internal::sendExactv(...)</span>, this method can switch to a vectored send to avoid the temporary copy in the multi-fragment case.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>writev(std::span&lt;const std::string_view&gt;), write(std::string_view), writeAll(std::string_view), writeWithTimeout(std::string_view, int), enforceSendCapConnected(std::size_t), waitReady(Direction, int)</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send header + separator + body as one UDP datagram, blocking until writable</span></div>
<div class="line">std::string_view hdr = <span class="stringliteral">&quot;HDR&quot;</span>;</div>
<div class="line">std::string_view sep = <span class="stringliteral">&quot;:&quot;</span>;</div>
<div class="line">std::string_view body = <span class="stringliteral">&quot;payload&quot;</span>;</div>
<div class="line">sock.writevAll({hdr, sep, body});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga4a22b644010f53c741a8ea733e4abf0f" name="ga4a22b644010f53c741a8ea733e4abf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a22b644010f53c741a8ea733e4abf0f">&#9670;&#160;</a></span>writeWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DatagramSocket::writeWithTimeout </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one UDP datagram to the connected peer, waiting up to <code class="param">timeoutMillis</code> for writability. </p>
<p>Emits exactly one datagram containing <code class="param">data</code>. This method <b>bounds</b> the wait for socket writability, then performs a single send:</p>
<ol type="1">
<li>Verifies the socket is <b>open</b> and <b>connected</b>.</li>
<li>If the payload is empty, returns immediately (zero-length UDP datagrams are valid, but this implementation skips the syscall as a micro-optimization).</li>
<li>Enforces protocol-level size limits for the connected peer’s address family via <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected</a>(data.size())</span> to preempt guaranteed <span class="tt">EMSGSIZE</span>.</li>
<li>Calls <span class="tt">waitReady(Direction::Write, timeoutMillis)</span>; if the socket does not become writable before the timeout, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> is thrown.</li>
<li>On readiness, transmits the datagram in a <b>single</b> system call (no partial sends).</li>
</ol>
<p><b>Timeout semantics</b> (delegated to <span class="tt"><a class="el" href="#ga53fd92734f14407ce6c78d8df246c319" title="Block until the socket is ready for I/O or a timeout occurs.">waitReady()</a></span>):</p><ul>
<li><span class="tt">timeoutMillis &gt; 0</span> — wait up to the specified milliseconds.</li>
<li><span class="tt">timeoutMillis == 0</span> — non-blocking poll (immediate).</li>
<li><span class="tt">timeoutMillis &lt; 0</span> — wait indefinitely (equivalent to <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> behavior).</li>
</ul>
<p><b>Atomicity:</b> UDP is message-oriented; on success, the <em>entire</em> payload is sent as one datagram. On exception, no bytes are considered transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Bytes to send as a single datagram (accepts <span class="tt">std::string</span>, string literals, etc., via implicit conversion to <span class="tt">std::string_view</span>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>See timeout semantics above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> </dd>
<dd>
<span class="tt"><a class="el" href="#gac3b7c4a5fc5a21372c4a9cadb3e85efb" title="Indicates whether the datagram socket is connected to a specific remote peer.">isConnected()</a> == true</span></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>On success, exactly <span class="tt">data.size()</span> bytes are handed to the kernel as one datagram. <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state and options are unchanged.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If the socket does not become writable within <code class="param">timeoutMillis</code> (when it is &gt;= 0).</td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li><b>Logical (error code = 0):</b> socket not open/connected; payload exceeds the permitted maximum for the connected peer’s family (detected by <span class="tt"><a class="el" href="#ga71ea4f3e14d566fe91a188f4cc4a5f64" title="Enforce UDP payload size limits for connected datagram sends.">enforceSendCapConnected()</a></span>).</li>
<li><b>System (OS error + <span class="tt">SocketErrorMessage(...)</span>):</b> polling or send failures (e.g., <span class="tt">POLLERR</span>, <span class="tt">POLLNVAL</span>, <span class="tt">POLLHUP</span>, <span class="tt">EWOULDBLOCK</span>, <span class="tt">ENOBUFS</span>, <span class="tt">ENETUNREACH</span>, etc.).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Prefer <span class="tt"><a class="el" href="#gabb163d329ca77150019c3e430f415209" title="Send one UDP datagram to the connected peer, waiting indefinitely for writability.">writeAll()</a></span> when you intentionally want an infinite wait; pass a negative <code class="param">timeoutMillis</code> to mimic that behavior if you must stick to a single API. </dd>
<dd>
For an immediate, no-wait attempt, use <span class="tt"><a class="el" href="#ga96bc239f42265d5c408c8f15046f24c8" title="Send one UDP datagram to the currently connected peer (no pre-wait).">write()</a></span> instead.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>write(std::string_view), writeAll(std::string_view), writevAll(std::span&lt;const std::string_view&gt;), enforceSendCapConnected(std::size_t), waitReady(Direction, int)</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: send with a 500 ms bound</span></div>
<div class="line">sock.writeWithTimeout(<span class="stringliteral">&quot;payload&quot;</span>, 500);   <span class="comment">// throws SocketTimeoutException on timeout</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Immediate attempt (non-blocking poll)</span></div>
<div class="line">sock.writeWithTimeout(<span class="stringliteral">&quot;ping&quot;</span>, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Equivalent to writeAll() (infinite wait)</span></div>
<div class="line">sock.writeWithTimeout(<span class="stringliteral">&quot;large message&quot;</span>, -1);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf2be0b146f197d55cc55a5ba8b619166" name="gaf2be0b146f197d55cc55a5ba8b619166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2be0b146f197d55cc55a5ba8b619166">&#9670;&#160;</a></span>~DatagramSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DatagramSocket::~DatagramSocket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor for <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>. Ensures socket resources are released. </p>
<p>Automatically closes the underlying UDP socket and releases all associated system resources. This follows RAII principles, guaranteeing cleanup when the object goes out of scope.</p>
<ul>
<li>Closes the socket file descriptor (using <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> or platform equivalent)</li>
<li>Suppresses all exceptions during cleanup to maintain noexcept guarantees</li>
<li>Prevents resource leaks even in exception scenarios</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Errors during destruction are ignored. For explicit error handling, call <span class="tt"><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a></span> manually. </dd>
<dd>
Do not use a <a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a> after destruction or move.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga9d0a9582b3a2a72bf62f182dbc33c352" title="Closes the datagram socket and releases its underlying system resources.">close()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
