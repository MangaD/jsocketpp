<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jsocketpp: TCP Sockets</title>
<link rel="icon" href="logo55px.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo55px.png"/></td>
  <td id="projectalign">
   <div id="projectname">jsocketpp<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A cross-platform C++20 socket library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__tcp.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">TCP Sockets <div class="ingroups"><a class="el" href="group__jsocketpp.html">jsocketpp: C++20 cross-platform socket library</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Classes and functions for TCP networking.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for TCP Sockets:</div>
<div class="dyncontent">
<div class="center"><img src="group__tcp.png" border="0" usemap="#agroup____tcp" loading="lazy" alt=""/></div>
<map name="agroup____tcp" id="agroup____tcp">
<area shape="rect" href="group__jsocketpp.html" title="All core classes and functions of the jsocketpp networking library." alt="" coords="5,5,182,50"/>
<area shape="rect" title="Classes and functions for TCP networking." alt="" coords="230,14,329,42"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jsocketpp_3A_3AServerSocket" id="r_jsocketpp_3A_3AServerSocket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP server socket abstraction for cross-platform C++ networking.  <a href="classjsocketpp_1_1ServerSocket.html#details">More...</a><br /></td></tr>
<tr class="memitem:jsocketpp_3A_3ASocket" id="r_jsocketpp_3A_3ASocket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsocketpp_1_1Socket.html">jsocketpp::Socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP client connection abstraction (Java-like interface).  <a href="classjsocketpp_1_1Socket.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga58290010ec759550485b8eeede8d931a" id="r_ga58290010ec759550485b8eeede8d931a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga58290010ec759550485b8eeede8d931a">jsocketpp::ServerSocket::ServerSocket</a> ()=delete</td></tr>
<tr class="memdesc:ga58290010ec759550485b8eeede8d931a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (deleted) for <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> class.  <br /></td></tr>
<tr class="memitem:gad389848c3e0fcadcfe5f581ab8c8fbb8" id="r_gad389848c3e0fcadcfe5f581ab8c8fbb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad389848c3e0fcadcfe5f581ab8c8fbb8">jsocketpp::ServerSocket::ServerSocket</a> (<a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, std::string_view localAddress={}, bool autoBindListen=true, bool reuseAddress=true, int soTimeoutMillis=-1, bool dualStack=true)</td></tr>
<tr class="memdesc:gad389848c3e0fcadcfe5f581ab8c8fbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> for listening to incoming TCP connections with full configuration control.  <br /></td></tr>
<tr class="memitem:gad3b2807577129c652044f17626c6e01a" id="r_gad3b2807577129c652044f17626c6e01a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad3b2807577129c652044f17626c6e01a">jsocketpp::ServerSocket::getLocalPort</a> () const</td></tr>
<tr class="memdesc:gad3b2807577129c652044f17626c6e01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the local port number to which the server socket is bound.  <br /></td></tr>
<tr class="memitem:ga5e035235b554db37df4492b5725e78cc" id="r_ga5e035235b554db37df4492b5725e78cc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5e035235b554db37df4492b5725e78cc">jsocketpp::ServerSocket::getLocalSocketAddress</a> () const</td></tr>
<tr class="memdesc:ga5e035235b554db37df4492b5725e78cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local socket address (IP and port) to which the server socket is bound.  <br /></td></tr>
<tr class="memitem:gac6eeb69e3b15334e7c224edf30248fe3" id="r_gac6eeb69e3b15334e7c224edf30248fe3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6eeb69e3b15334e7c224edf30248fe3">jsocketpp::ServerSocket::ServerSocket</a> (const ServerSocket &amp;rhs)=delete</td></tr>
<tr class="memdesc:gac6eeb69e3b15334e7c224edf30248fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (deleted).  <br /></td></tr>
<tr class="memitem:ga82ef44f032a357bd470b4b756bdba37c" id="r_ga82ef44f032a357bd470b4b756bdba37c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga82ef44f032a357bd470b4b756bdba37c">jsocketpp::ServerSocket::operator=</a> (const <a class="el" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> &amp;rhs)=delete</td></tr>
<tr class="memdesc:ga82ef44f032a357bd470b4b756bdba37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator (deleted).  <br /></td></tr>
<tr class="memitem:gace3560ea1b99e15c1564e430e8848500" id="r_gace3560ea1b99e15c1564e430e8848500"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gace3560ea1b99e15c1564e430e8848500">jsocketpp::ServerSocket::ServerSocket</a> (ServerSocket &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:gace3560ea1b99e15c1564e430e8848500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that transfers ownership of server socket resources.  <br /></td></tr>
<tr class="memitem:ga9fb02efd71b7800a17f7dc64214a8e4a" id="r_ga9fb02efd71b7800a17f7dc64214a8e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9fb02efd71b7800a17f7dc64214a8e4a">jsocketpp::ServerSocket::operator=</a> (<a class="el" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga9fb02efd71b7800a17f7dc64214a8e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a>.  <br /></td></tr>
<tr class="memitem:ga06c96fc5f87b1cde4c12cb6175b8a129" id="r_ga06c96fc5f87b1cde4c12cb6175b8a129"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga06c96fc5f87b1cde4c12cb6175b8a129">jsocketpp::ServerSocket::~ServerSocket</a> () noexcept override</td></tr>
<tr class="memdesc:ga06c96fc5f87b1cde4c12cb6175b8a129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor that automatically closes the server socket and releases all associated resources.  <br /></td></tr>
<tr class="memitem:ga1ca989ba16d32862dd4fa9bbb2b165b5" id="r_ga1ca989ba16d32862dd4fa9bbb2b165b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5">jsocketpp::ServerSocket::bind</a> ()</td></tr>
<tr class="memdesc:ga1ca989ba16d32862dd4fa9bbb2b165b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the server socket to the configured port and network interface.  <br /></td></tr>
<tr class="memitem:ga0b3a5cb732c669b678e03549e5af2427" id="r_ga0b3a5cb732c669b678e03549e5af2427"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0b3a5cb732c669b678e03549e5af2427">jsocketpp::ServerSocket::isBound</a> () const noexcept</td></tr>
<tr class="memdesc:ga0b3a5cb732c669b678e03549e5af2427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the server socket is bound to a local address.  <br /></td></tr>
<tr class="memitem:ga4780ea0cf2fb98d0081ed91d8dbecfa3" id="r_ga4780ea0cf2fb98d0081ed91d8dbecfa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3">jsocketpp::ServerSocket::listen</a> (int backlog=128)</td></tr>
<tr class="memdesc:ga4780ea0cf2fb98d0081ed91d8dbecfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.  <br /></td></tr>
<tr class="memitem:ga1717f9859e5aeeba77c3d463ec53e735" id="r_ga1717f9859e5aeeba77c3d463ec53e735"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1717f9859e5aeeba77c3d463ec53e735">jsocketpp::ServerSocket::isListening</a> () const noexcept</td></tr>
<tr class="memdesc:ga1717f9859e5aeeba77c3d463ec53e735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the server socket is currently listening for incoming connections.  <br /></td></tr>
<tr class="memitem:gac645e511797a5c5cffd1ee490ece0e96" id="r_gac645e511797a5c5cffd1ee490ece0e96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjsocketpp_1_1Socket.html">Socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96">jsocketpp::ServerSocket::accept</a> (std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false) const</td></tr>
<tr class="memdesc:gac645e511797a5c5cffd1ee490ece0e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept an incoming client connection, respecting the configured socket timeout and applying tuning options.  <br /></td></tr>
<tr class="memitem:ga5a797cf5d657594189d4fc14fcb87788" id="r_ga5a797cf5d657594189d4fc14fcb87788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjsocketpp_1_1Socket.html">Socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a797cf5d657594189d4fc14fcb87788">jsocketpp::ServerSocket::accept</a> (int timeoutMillis, std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false) const</td></tr>
<tr class="memdesc:ga5a797cf5d657594189d4fc14fcb87788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept an incoming client connection, waiting up to the specified timeout and applying socket tuning options.  <br /></td></tr>
<tr class="memitem:ga6eff2e5c775318cfd2813ee72e716571" id="r_ga6eff2e5c775318cfd2813ee72e716571"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571">jsocketpp::ServerSocket::tryAccept</a> (std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false) const</td></tr>
<tr class="memdesc:ga6eff2e5c775318cfd2813ee72e716571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to accept an incoming client connection, returning <span class="tt">std::nullopt</span> on timeout instead of throwing.  <br /></td></tr>
<tr class="memitem:ga93a186b3fcb925c3a6c30f1c5d5bf8a8" id="r_ga93a186b3fcb925c3a6c30f1c5d5bf8a8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga93a186b3fcb925c3a6c30f1c5d5bf8a8">jsocketpp::ServerSocket::tryAccept</a> (int timeoutMillis, std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false) const</td></tr>
<tr class="memdesc:ga93a186b3fcb925c3a6c30f1c5d5bf8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to accept an incoming client connection, waiting up to a specified timeout and returning <span class="tt">std::nullopt</span> on timeout.  <br /></td></tr>
<tr class="memitem:ga4cc6cc771e29a9d1964cb8b351262318" id="r_ga4cc6cc771e29a9d1964cb8b351262318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjsocketpp_1_1Socket.html">Socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318">jsocketpp::ServerSocket::acceptBlocking</a> (std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false) const</td></tr>
<tr class="memdesc:ga4cc6cc771e29a9d1964cb8b351262318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a TCP client connection, configures the socket, and returns a high-level <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> object.  <br /></td></tr>
<tr class="memitem:gaa825d267c5cba8febdd2824282869ac1" id="r_gaa825d267c5cba8febdd2824282869ac1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa825d267c5cba8febdd2824282869ac1">jsocketpp::ServerSocket::acceptNonBlocking</a> (std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false) const</td></tr>
<tr class="memdesc:gaa825d267c5cba8febdd2824282869ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to accept a client connection in non-blocking mode and returns a fully configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>.  <br /></td></tr>
<tr class="memitem:gad31e3456825d69842685b8826a0ad346" id="r_gad31e3456825d69842685b8826a0ad346"><td class="memItemLeft" align="right" valign="top">std::future&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad31e3456825d69842685b8826a0ad346">jsocketpp::ServerSocket::acceptAsync</a> (std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false) const</td></tr>
<tr class="memdesc:gad31e3456825d69842685b8826a0ad346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously accept an incoming client connection, returning a <span class="tt">std::future</span> that resolves to a configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>.  <br /></td></tr>
<tr class="memitem:gafc1d1883c490172751065d491001e049" id="r_gafc1d1883c490172751065d491001e049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafc1d1883c490172751065d491001e049">jsocketpp::ServerSocket::acceptAsync</a> (std::function&lt; void(std::optional&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt;, std::exception_ptr)&gt; callback, std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false) const</td></tr>
<tr class="memdesc:gafc1d1883c490172751065d491001e049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously accept a client connection and invoke a callback upon completion or error.  <br /></td></tr>
<tr class="memitem:ga0245d40096ca089255c67303eebf17e6" id="r_ga0245d40096ca089255c67303eebf17e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0245d40096ca089255c67303eebf17e6">jsocketpp::ServerSocket::close</a> ()</td></tr>
<tr class="memdesc:ga0245d40096ca089255c67303eebf17e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the server socket and releases its associated system resources.  <br /></td></tr>
<tr class="memitem:ga4e3ff54722a55e7500fdd76f26c53dac" id="r_ga4e3ff54722a55e7500fdd76f26c53dac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4e3ff54722a55e7500fdd76f26c53dac">jsocketpp::ServerSocket::isValid</a> () const noexcept</td></tr>
<tr class="memdesc:ga4e3ff54722a55e7500fdd76f26c53dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the server socket is currently open and valid.  <br /></td></tr>
<tr class="memitem:gaeb5adb24bd7f50eaf8b52aa4441ffe71" id="r_gaeb5adb24bd7f50eaf8b52aa4441ffe71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb5adb24bd7f50eaf8b52aa4441ffe71">jsocketpp::ServerSocket::isClosed</a> () const noexcept</td></tr>
<tr class="memdesc:gaeb5adb24bd7f50eaf8b52aa4441ffe71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the server socket has been closed.  <br /></td></tr>
<tr class="memitem:ga61c1904213b0971817ec917fd2a01ccf" id="r_ga61c1904213b0971817ec917fd2a01ccf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga61c1904213b0971817ec917fd2a01ccf">jsocketpp::ServerSocket::waitReady</a> (std::optional&lt; int &gt; timeoutMillis=std::nullopt) const</td></tr>
<tr class="memdesc:ga61c1904213b0971817ec917fd2a01ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the server socket to become ready to accept an incoming connection.  <br /></td></tr>
<tr class="memitem:gaf644d3fccaebced95dd6bc2055bbed3e" id="r_gaf644d3fccaebced95dd6bc2055bbed3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf644d3fccaebced95dd6bc2055bbed3e">jsocketpp::ServerSocket::setDefaultReceiveBufferSize</a> (const std::size_t size)</td></tr>
<tr class="memdesc:gaf644d3fccaebced95dd6bc2055bbed3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default receive buffer size for accepted client sockets.  <br /></td></tr>
<tr class="memitem:ga29de003fbad91f7302115d26b89ac888" id="r_ga29de003fbad91f7302115d26b89ac888"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga29de003fbad91f7302115d26b89ac888">jsocketpp::ServerSocket::getDefaultReceiveBufferSize</a> () const noexcept</td></tr>
<tr class="memdesc:ga29de003fbad91f7302115d26b89ac888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current default receive buffer size for accepted client sockets.  <br /></td></tr>
<tr class="memitem:gadbeecdd1d47fb8244dab210fa297fcf9" id="r_gadbeecdd1d47fb8244dab210fa297fcf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadbeecdd1d47fb8244dab210fa297fcf9">jsocketpp::ServerSocket::setDefaultSendBufferSize</a> (const std::size_t size)</td></tr>
<tr class="memdesc:gadbeecdd1d47fb8244dab210fa297fcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default send buffer size for accepted client sockets.  <br /></td></tr>
<tr class="memitem:ga80d2d5fc59fa2b10e586287d6ffd84f7" id="r_ga80d2d5fc59fa2b10e586287d6ffd84f7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80d2d5fc59fa2b10e586287d6ffd84f7">jsocketpp::ServerSocket::getDefaultSendBufferSize</a> () const noexcept</td></tr>
<tr class="memdesc:ga80d2d5fc59fa2b10e586287d6ffd84f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current default send buffer size for accepted client sockets.  <br /></td></tr>
<tr class="memitem:gab42832248058c119c99ef60c4d72d478" id="r_gab42832248058c119c99ef60c4d72d478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab42832248058c119c99ef60c4d72d478">jsocketpp::ServerSocket::setDefaultInternalBufferSize</a> (const std::size_t size)</td></tr>
<tr class="memdesc:gab42832248058c119c99ef60c4d72d478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the per-instance default internal buffer size used for buffered read operations.  <br /></td></tr>
<tr class="memitem:gac1f9d646223bb7c733216b484f517d46" id="r_gac1f9d646223bb7c733216b484f517d46"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac1f9d646223bb7c733216b484f517d46">jsocketpp::ServerSocket::getDefaultInternalBufferSize</a> () const noexcept</td></tr>
<tr class="memdesc:gac1f9d646223bb7c733216b484f517d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the per-instance default internal buffer size used for buffered read operations.  <br /></td></tr>
<tr class="memitem:ga2a630f28a613224176ff17f7ee0c6a4c" id="r_ga2a630f28a613224176ff17f7ee0c6a4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2a630f28a613224176ff17f7ee0c6a4c">jsocketpp::ServerSocket::cleanup</a> ()</td></tr>
<tr class="memdesc:ga2a630f28a613224176ff17f7ee0c6a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up internal resources and resets the server socket state.  <br /></td></tr>
<tr class="memitem:gab5572cb795d9b45ee50a0ddf9cb9c075" id="r_gab5572cb795d9b45ee50a0ddf9cb9c075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab5572cb795d9b45ee50a0ddf9cb9c075">jsocketpp::ServerSocket::cleanupAndThrow</a> (int errorCode)</td></tr>
<tr class="memdesc:gab5572cb795d9b45ee50a0ddf9cb9c075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up internal resources and throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>.  <br /></td></tr>
<tr class="memitem:ga33183210cdc2a1e281006e325cc2a173" id="r_ga33183210cdc2a1e281006e325cc2a173"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga33183210cdc2a1e281006e325cc2a173">jsocketpp::ServerSocket::cleanupAndRethrow</a> ()</td></tr>
<tr class="memdesc:ga33183210cdc2a1e281006e325cc2a173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up internal resources and rethrows the current exception.  <br /></td></tr>
<tr class="memitem:gae01e7a531be7a5addb83ff6b9bb111e8" id="r_gae01e7a531be7a5addb83ff6b9bb111e8"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae01e7a531be7a5addb83ff6b9bb111e8">jsocketpp::ServerSocket::getEffectiveReceiveBufferSize</a> (const std::optional&lt; std::size_t &gt; recvBufferSize) const</td></tr>
<tr class="memdesc:gae01e7a531be7a5addb83ff6b9bb111e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the effective receive buffer size to use for socket read operations.  <br /></td></tr>
<tr class="memitem:ga1308a8d172508999834853ccb35607e8" id="r_ga1308a8d172508999834853ccb35607e8"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1308a8d172508999834853ccb35607e8">jsocketpp::ServerSocket::getEffectiveSendBufferSize</a> (std::optional&lt; std::size_t &gt; sendBufferSize) const</td></tr>
<tr class="memdesc:ga1308a8d172508999834853ccb35607e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the effective send buffer size to use for socket write operations.  <br /></td></tr>
<tr class="memitem:ga474741cb104a36bab217ea478608439c" id="r_ga474741cb104a36bab217ea478608439c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga474741cb104a36bab217ea478608439c">jsocketpp::ServerSocket::getEffectiveInternalBufferSize</a> (const std::optional&lt; std::size_t &gt; internalBufferSize) const</td></tr>
<tr class="memdesc:ga474741cb104a36bab217ea478608439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the effective internal buffer size to use for buffered socket read operations.  <br /></td></tr>
<tr class="memitem:ga069d29c3ff8b80ee9a7cb9e1e39f930a" id="r_ga069d29c3ff8b80ee9a7cb9e1e39f930a"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga069d29c3ff8b80ee9a7cb9e1e39f930a">jsocketpp::ServerSocket::resolveBuffers</a> (const std::optional&lt; std::size_t &gt; recv, const std::optional&lt; std::size_t &gt; send, const std::optional&lt; std::size_t &gt; <a class="el" href="namespacejsocketpp_1_1internal.html">internal</a>) const</td></tr>
<tr class="memdesc:ga069d29c3ff8b80ee9a7cb9e1e39f930a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves effective receive and send buffer sizes from optional user inputs.  <br /></td></tr>
<tr class="memitem:ga6da94c322a3ed5f85efd26a7fbadbe0a" id="r_ga6da94c322a3ed5f85efd26a7fbadbe0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">jsocketpp::Socket::Socket</a> (<a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a> client, const sockaddr_storage &amp;addr, socklen_t len, std::size_t recvBufferSize=<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">DefaultBufferSize</a>, std::size_t sendBufferSize=<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">DefaultBufferSize</a>, std::size_t internalBufferSize=<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">DefaultBufferSize</a>, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false)</td></tr>
<tr class="memdesc:ga6da94c322a3ed5f85efd26a7fbadbe0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an accepted TCP client socket with optional tuning parameters.  <br /></td></tr>
<tr class="memitem:gabc4e14475484e596ac62509e627a9baf" id="r_gabc4e14475484e596ac62509e627a9baf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabc4e14475484e596ac62509e627a9baf">jsocketpp::Socket::Socket</a> ()=delete</td></tr>
<tr class="memdesc:gabc4e14475484e596ac62509e627a9baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (deleted) for <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> class.  <br /></td></tr>
<tr class="memitem:ga201308e71110af1410e39920f02adf89" id="r_ga201308e71110af1410e39920f02adf89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga201308e71110af1410e39920f02adf89">jsocketpp::Socket::Socket</a> (std::string_view host, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port, std::optional&lt; std::size_t &gt; recvBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; sendBufferSize=std::nullopt, std::optional&lt; std::size_t &gt; internalBufferSize=std::nullopt, bool reuseAddress=true, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool dualStack=true, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false, bool autoConnect=true, bool autoBind=false, std::string_view localAddress=&quot;&quot;, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> localPort=0)</td></tr>
<tr class="memdesc:ga201308e71110af1410e39920f02adf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a TCP client socket, resolves the remote host and port, and optionally binds or connects.  <br /></td></tr>
<tr class="memitem:gaf5a4ddebfbca7bfe6c9a88462cc9ada8" id="r_gaf5a4ddebfbca7bfe6c9a88462cc9ada8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5a4ddebfbca7bfe6c9a88462cc9ada8">jsocketpp::Socket::Socket</a> (const Socket &amp;rhs)=delete</td></tr>
<tr class="memdesc:gaf5a4ddebfbca7bfe6c9a88462cc9ada8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (deleted) for <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> class.  <br /></td></tr>
<tr class="memitem:gad0612bda82c378dbaf99e0839f5aa815" id="r_gad0612bda82c378dbaf99e0839f5aa815"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad0612bda82c378dbaf99e0839f5aa815">jsocketpp::Socket::Socket</a> (Socket &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:gad0612bda82c378dbaf99e0839f5aa815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that transfers ownership of socket resources.  <br /></td></tr>
<tr class="memitem:ga4d2721350ef6a3cad7edf7b778d436c4" id="r_ga4d2721350ef6a3cad7edf7b778d436c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4d2721350ef6a3cad7edf7b778d436c4">jsocketpp::Socket::operator=</a> (const <a class="el" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> &amp;rhs)=delete</td></tr>
<tr class="memdesc:ga4d2721350ef6a3cad7edf7b778d436c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator (deleted) for <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> class.  <br /></td></tr>
<tr class="memitem:ga05b1ae2ec76833370c809c53fe550a95" id="r_ga05b1ae2ec76833370c809c53fe550a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga05b1ae2ec76833370c809c53fe550a95">jsocketpp::Socket::operator=</a> (<a class="el" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga05b1ae2ec76833370c809c53fe550a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that transfers socket ownership safely.  <br /></td></tr>
<tr class="memitem:gafa933f0914d99522c857b30f64c9ce32" id="r_gafa933f0914d99522c857b30f64c9ce32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafa933f0914d99522c857b30f64c9ce32">jsocketpp::Socket::~Socket</a> () noexcept override</td></tr>
<tr class="memdesc:gafa933f0914d99522c857b30f64c9ce32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object, closing connections and freeing resources.  <br /></td></tr>
<tr class="memitem:gae9a523509c0b63f91a801613dec85b39" id="r_gae9a523509c0b63f91a801613dec85b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9a523509c0b63f91a801613dec85b39">jsocketpp::Socket::bind</a> (std::string_view localHost, <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port)</td></tr>
<tr class="memdesc:gae9a523509c0b63f91a801613dec85b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the client socket to a specific local IP address and/or port.  <br /></td></tr>
<tr class="memitem:ga477422f8e69c0114cc539926b7f6bc68" id="r_ga477422f8e69c0114cc539926b7f6bc68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga477422f8e69c0114cc539926b7f6bc68">jsocketpp::Socket::bind</a> (<a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port)</td></tr>
<tr class="memdesc:ga477422f8e69c0114cc539926b7f6bc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the client socket to all interfaces (INADDR_ANY) using the specified port.  <br /></td></tr>
<tr class="memitem:gace1da4f860ac0af46d702cb5fc875a51" id="r_gace1da4f860ac0af46d702cb5fc875a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51">jsocketpp::Socket::bind</a> ()</td></tr>
<tr class="memdesc:gace1da4f860ac0af46d702cb5fc875a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the client socket to all interfaces using an ephemeral port.  <br /></td></tr>
<tr class="memitem:gac5d9708cad057d6d608fb732eb1bb117" id="r_gac5d9708cad057d6d608fb732eb1bb117"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac5d9708cad057d6d608fb732eb1bb117">jsocketpp::Socket::isBound</a> () const noexcept</td></tr>
<tr class="memdesc:gac5d9708cad057d6d608fb732eb1bb117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the socket has been explicitly bound to a local address and/or port.  <br /></td></tr>
<tr class="memitem:gab1e4f32614be9a3609820f75dbcb4fc2" id="r_gab1e4f32614be9a3609820f75dbcb4fc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2">jsocketpp::Socket::isConnected</a> () const noexcept</td></tr>
<tr class="memdesc:gab1e4f32614be9a3609820f75dbcb4fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the socket has been successfully connected to a remote host.  <br /></td></tr>
<tr class="memitem:ga6cd36845f959c2bf075c475e5fdc7620" id="r_ga6cd36845f959c2bf075c475e5fdc7620"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6cd36845f959c2bf075c475e5fdc7620">jsocketpp::Socket::getLocalIp</a> (bool convertIPv4Mapped=true) const</td></tr>
<tr class="memdesc:ga6cd36845f959c2bf075c475e5fdc7620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the local IP address this socket is bound to.  <br /></td></tr>
<tr class="memitem:gac10f731a7d1e90c18688266fe5db969e" id="r_gac10f731a7d1e90c18688266fe5db969e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac10f731a7d1e90c18688266fe5db969e">jsocketpp::Socket::getLocalPort</a> () const</td></tr>
<tr class="memdesc:gac10f731a7d1e90c18688266fe5db969e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the local port number this socket is bound to.  <br /></td></tr>
<tr class="memitem:gab716648ffb451640b18f4f4363a22eb3" id="r_gab716648ffb451640b18f4f4363a22eb3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab716648ffb451640b18f4f4363a22eb3">jsocketpp::Socket::getLocalSocketAddress</a> (bool convertIPv4Mapped=true) const</td></tr>
<tr class="memdesc:gab716648ffb451640b18f4f4363a22eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the full local socket address in the form "IP:port".  <br /></td></tr>
<tr class="memitem:ga273e2d4847b5407bb8eef56d9e88996e" id="r_ga273e2d4847b5407bb8eef56d9e88996e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga273e2d4847b5407bb8eef56d9e88996e">jsocketpp::Socket::getRemoteIp</a> (bool convertIPv4Mapped=true) const</td></tr>
<tr class="memdesc:ga273e2d4847b5407bb8eef56d9e88996e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the IP address of the remote peer this TCP socket is connected to.  <br /></td></tr>
<tr class="memitem:ga2840142258bae9535c6421d6cd3dce1c" id="r_ga2840142258bae9535c6421d6cd3dce1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2840142258bae9535c6421d6cd3dce1c">jsocketpp::Socket::getRemotePort</a> () const</td></tr>
<tr class="memdesc:ga2840142258bae9535c6421d6cd3dce1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the port number of the remote peer this TCP socket is connected to.  <br /></td></tr>
<tr class="memitem:ga92c62bf727779c6d7395809084f9e4dc" id="r_ga92c62bf727779c6d7395809084f9e4dc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga92c62bf727779c6d7395809084f9e4dc">jsocketpp::Socket::getRemoteSocketAddress</a> (bool convertIPv4Mapped=true) const</td></tr>
<tr class="memdesc:ga92c62bf727779c6d7395809084f9e4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the connected peer's socket address as a formatted string.  <br /></td></tr>
<tr class="memitem:ga93cc325113abb7433288338ca3facde1" id="r_ga93cc325113abb7433288338ca3facde1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga93cc325113abb7433288338ca3facde1">jsocketpp::Socket::connect</a> (int timeoutMillis=-1)</td></tr>
<tr class="memdesc:ga93cc325113abb7433288338ca3facde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a TCP connection to the remote host with optional timeout control.  <br /></td></tr>
<tr class="memitem:gaa7498d51b547b52699055bdb16b9d68b" id="r_gaa7498d51b547b52699055bdb16b9d68b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaa7498d51b547b52699055bdb16b9d68b template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b">jsocketpp::Socket::read</a> ()</td></tr>
<tr class="memdesc:gaa7498d51b547b52699055bdb16b9d68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a fixed-size, trivially copyable object of type <span class="tt">T</span> from the socket.  <br /></td></tr>
<tr class="memitem:ga3d194596258a3b1117b3437d969019b6" id="r_ga3d194596258a3b1117b3437d969019b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d194596258a3b1117b3437d969019b6">jsocketpp::Socket::readExact</a> (std::size_t n) const</td></tr>
<tr class="memdesc:ga3d194596258a3b1117b3437d969019b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads exactly <span class="tt">n</span> bytes from the socket into a <span class="tt">std::string</span>.  <br /></td></tr>
<tr class="memitem:ga46777f128a2a23cba8972aefd4b86828" id="r_ga46777f128a2a23cba8972aefd4b86828"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga46777f128a2a23cba8972aefd4b86828">jsocketpp::Socket::readUntil</a> (char delimiter, std::size_t maxLen=8192, bool includeDelimiter=true)</td></tr>
<tr class="memdesc:ga46777f128a2a23cba8972aefd4b86828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the socket until a specified delimiter character is encountered.  <br /></td></tr>
<tr class="memitem:ga21767c46469a8cee88a87f45405d36fd" id="r_ga21767c46469a8cee88a87f45405d36fd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga21767c46469a8cee88a87f45405d36fd">jsocketpp::Socket::readLine</a> (const std::size_t maxLen=8192, const bool includeDelimiter=true)</td></tr>
<tr class="memdesc:ga21767c46469a8cee88a87f45405d36fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a line terminated by '<br  />
' from the socket.  <br /></td></tr>
<tr class="memitem:ga7c3a39505b6c65a9c4db03c081cd4de7" id="r_ga7c3a39505b6c65a9c4db03c081cd4de7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7c3a39505b6c65a9c4db03c081cd4de7">jsocketpp::Socket::readAtMost</a> (std::size_t n) const</td></tr>
<tr class="memdesc:ga7c3a39505b6c65a9c4db03c081cd4de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a single best-effort read of up to <span class="tt">n</span> bytes from the socket.  <br /></td></tr>
<tr class="memitem:gac2bfca99305ede78697fc0b39fbbeed8" id="r_gac2bfca99305ede78697fc0b39fbbeed8"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac2bfca99305ede78697fc0b39fbbeed8">jsocketpp::Socket::readInto</a> (void *buffer, const std::size_t len) const</td></tr>
<tr class="memdesc:gac2bfca99305ede78697fc0b39fbbeed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads available data from the socket into the provided buffer.  <br /></td></tr>
<tr class="memitem:gabb8631cb8242b3573a2679da0b6a4f4d" id="r_gabb8631cb8242b3573a2679da0b6a4f4d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabb8631cb8242b3573a2679da0b6a4f4d">jsocketpp::Socket::readIntoExact</a> (void *buffer, const std::size_t len) const</td></tr>
<tr class="memdesc:gabb8631cb8242b3573a2679da0b6a4f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads exactly <span class="tt">len</span> bytes into the given buffer (looped recv).  <br /></td></tr>
<tr class="memitem:ga3b61b5861d62f4e85be4a52aa9e0bcc9" id="r_ga3b61b5861d62f4e85be4a52aa9e0bcc9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b61b5861d62f4e85be4a52aa9e0bcc9">jsocketpp::Socket::readAtMostWithTimeout</a> (std::size_t n, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga3b61b5861d62f4e85be4a52aa9e0bcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a best-effort read of up to <span class="tt">n</span> bytes with a timeout constraint.  <br /></td></tr>
<tr class="memitem:gab1aaaa6572bcf756be7bcdb801e35812" id="r_gab1aaaa6572bcf756be7bcdb801e35812"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gab1aaaa6572bcf756be7bcdb801e35812 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1aaaa6572bcf756be7bcdb801e35812">jsocketpp::Socket::readPrefixed</a> ()</td></tr>
<tr class="memdesc:gab1aaaa6572bcf756be7bcdb801e35812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a length-prefixed payload using a fixed-size prefix type.  <br /></td></tr>
<tr class="memitem:gac504258fb38abd34abee4ea96868a9d2" id="r_gac504258fb38abd34abee4ea96868a9d2"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gac504258fb38abd34abee4ea96868a9d2 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac504258fb38abd34abee4ea96868a9d2">jsocketpp::Socket::readPrefixed</a> (const std::size_t maxPayloadLen)</td></tr>
<tr class="memdesc:gac504258fb38abd34abee4ea96868a9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a length-prefixed message with an upper bound check.  <br /></td></tr>
<tr class="memitem:ga7a2c489a21a8b2f17bda4e70a296ad52" id="r_ga7a2c489a21a8b2f17bda4e70a296ad52"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7a2c489a21a8b2f17bda4e70a296ad52">jsocketpp::Socket::readAvailable</a> () const</td></tr>
<tr class="memdesc:ga7a2c489a21a8b2f17bda4e70a296ad52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all bytes currently available on the socket without blocking.  <br /></td></tr>
<tr class="memitem:gac12a8c2c7d3f5e90f58a7f2584bf11aa" id="r_gac12a8c2c7d3f5e90f58a7f2584bf11aa"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac12a8c2c7d3f5e90f58a7f2584bf11aa">jsocketpp::Socket::readIntoAvailable</a> (void *buffer, std::size_t bufferSize) const</td></tr>
<tr class="memdesc:gac12a8c2c7d3f5e90f58a7f2584bf11aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all currently available bytes into the provided buffer without blocking.  <br /></td></tr>
<tr class="memitem:ga90e5544f6d058709cc342e07554a59d5" id="r_ga90e5544f6d058709cc342e07554a59d5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5">jsocketpp::Socket::readv</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers) const</td></tr>
<tr class="memdesc:ga90e5544f6d058709cc342e07554a59d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a vectorized read into multiple buffers using a single system call.  <br /></td></tr>
<tr class="memitem:gadc68c056253b4d1c23828c2df73e6642" id="r_gadc68c056253b4d1c23828c2df73e6642"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadc68c056253b4d1c23828c2df73e6642">jsocketpp::Socket::readvAll</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers) const</td></tr>
<tr class="memdesc:gadc68c056253b4d1c23828c2df73e6642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads exactly the full contents of all provided buffers.  <br /></td></tr>
<tr class="memitem:gaf4b83c97cc8ca1fd97b0b9dfaac533b0" id="r_gaf4b83c97cc8ca1fd97b0b9dfaac533b0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf4b83c97cc8ca1fd97b0b9dfaac533b0">jsocketpp::Socket::readvAllWithTotalTimeout</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, int timeoutMillis) const</td></tr>
<tr class="memdesc:gaf4b83c97cc8ca1fd97b0b9dfaac533b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads exactly the full contents of all buffers within a timeout.  <br /></td></tr>
<tr class="memitem:ga6a8b2fada7df0ddec9b6f2c491f4f92b" id="r_ga6a8b2fada7df0ddec9b6f2c491f4f92b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6a8b2fada7df0ddec9b6f2c491f4f92b">jsocketpp::Socket::readvAtMostWithTimeout</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga6a8b2fada7df0ddec9b6f2c491f4f92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a single vectorized read into multiple buffers with a timeout.  <br /></td></tr>
<tr class="memitem:ga5c413ef976df1e89528d9b3df6484c89" id="r_ga5c413ef976df1e89528d9b3df6484c89"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c413ef976df1e89528d9b3df6484c89">jsocketpp::Socket::peek</a> (std::size_t n) const</td></tr>
<tr class="memdesc:ga5c413ef976df1e89528d9b3df6484c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at incoming data without consuming it.  <br /></td></tr>
<tr class="memitem:ga7492730c56e0bf5a4c67227df7bc4033" id="r_ga7492730c56e0bf5a4c67227df7bc4033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7492730c56e0bf5a4c67227df7bc4033">jsocketpp::Socket::discard</a> (std::size_t n, std::size_t chunkSize=1024) const</td></tr>
<tr class="memdesc:ga7492730c56e0bf5a4c67227df7bc4033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards exactly <span class="tt">n</span> bytes from the socket by reading and discarding them.  <br /></td></tr>
<tr class="memitem:ga75ee749264ccbcfc4dfbf5442e55dcb8" id="r_ga75ee749264ccbcfc4dfbf5442e55dcb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8">jsocketpp::Socket::close</a> ()</td></tr>
<tr class="memdesc:ga75ee749264ccbcfc4dfbf5442e55dcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the socket connection and releases associated resources.  <br /></td></tr>
<tr class="memitem:gaacbacf59cf8239e66c80c66a09243ec3" id="r_gaacbacf59cf8239e66c80c66a09243ec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3">jsocketpp::Socket::shutdown</a> (<a class="el" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174">ShutdownMode</a> how) const</td></tr>
<tr class="memdesc:gaacbacf59cf8239e66c80c66a09243ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown specific communication aspects of the socket.  <br /></td></tr>
<tr class="memitem:ga8b952bd8912694754bb34ab763aa8daa" id="r_ga8b952bd8912694754bb34ab763aa8daa"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa">jsocketpp::Socket::write</a> (std::string_view message) const</td></tr>
<tr class="memdesc:ga8b952bd8912694754bb34ab763aa8daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data to the socket using a single, best-effort write operation.  <br /></td></tr>
<tr class="memitem:gad1803ae12c1562ec09c28d19c1067914" id="r_gad1803ae12c1562ec09c28d19c1067914"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914">jsocketpp::Socket::writeAll</a> (std::string_view message) const</td></tr>
<tr class="memdesc:gad1803ae12c1562ec09c28d19c1067914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the entire contents of a message to the socket, retrying as needed.  <br /></td></tr>
<tr class="memitem:ga81f896d90e08fbfb1d63f1aabb21c970" id="r_ga81f896d90e08fbfb1d63f1aabb21c970"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga81f896d90e08fbfb1d63f1aabb21c970 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga81f896d90e08fbfb1d63f1aabb21c970">jsocketpp::Socket::writePrefixed</a> (const std::string_view payload)</td></tr>
<tr class="memdesc:ga81f896d90e08fbfb1d63f1aabb21c970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a length-prefixed payload using a fixed-size integral prefix.  <br /></td></tr>
<tr class="memitem:gab0b48a69153c1ed31dd158ec7afb901c" id="r_gab0b48a69153c1ed31dd158ec7afb901c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gab0b48a69153c1ed31dd158ec7afb901c template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab0b48a69153c1ed31dd158ec7afb901c">jsocketpp::Socket::writePrefixed</a> (const void *data, std::size_t len) const</td></tr>
<tr class="memdesc:gab0b48a69153c1ed31dd158ec7afb901c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a binary payload prefixed with its length using a fixed-size integer type.  <br /></td></tr>
<tr class="memitem:gadf5094228dfdef090b0d49a3a9e9e78d" id="r_gadf5094228dfdef090b0d49a3a9e9e78d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d">jsocketpp::Socket::writev</a> (std::span&lt; const std::string_view &gt; buffers) const</td></tr>
<tr class="memdesc:gadf5094228dfdef090b0d49a3a9e9e78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes multiple buffers in a single system call using scatter/gather I/O.  <br /></td></tr>
<tr class="memitem:ga804a69fa791fc8adb91f32ab37244a0a" id="r_ga804a69fa791fc8adb91f32ab37244a0a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga804a69fa791fc8adb91f32ab37244a0a">jsocketpp::Socket::writevAll</a> (std::span&lt; const std::string_view &gt; buffers) const</td></tr>
<tr class="memdesc:ga804a69fa791fc8adb91f32ab37244a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all buffers fully using vectorized I/O with automatic retry on partial sends.  <br /></td></tr>
<tr class="memitem:ga16bb8c36a3fd9a3a97a0d4f5d5036550" id="r_ga16bb8c36a3fd9a3a97a0d4f5d5036550"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16bb8c36a3fd9a3a97a0d4f5d5036550">jsocketpp::Socket::writeAtMostWithTimeout</a> (std::string_view data, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga16bb8c36a3fd9a3a97a0d4f5d5036550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a best-effort write with a total timeout.  <br /></td></tr>
<tr class="memitem:gab4484254fc3c113a373718198c382dd9" id="r_gab4484254fc3c113a373718198c382dd9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab4484254fc3c113a373718198c382dd9">jsocketpp::Socket::writeFrom</a> (const void *data, std::size_t len) const</td></tr>
<tr class="memdesc:gab4484254fc3c113a373718198c382dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes up to <span class="tt">len</span> bytes from a raw memory buffer in a single send call.  <br /></td></tr>
<tr class="memitem:ga686c95af72f4193d1a7c6dd6e658e4ba" id="r_ga686c95af72f4193d1a7c6dd6e658e4ba"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga686c95af72f4193d1a7c6dd6e658e4ba">jsocketpp::Socket::writeFromAll</a> (const void *data, std::size_t len) const</td></tr>
<tr class="memdesc:ga686c95af72f4193d1a7c6dd6e658e4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all bytes from a raw memory buffer, retrying until complete.  <br /></td></tr>
<tr class="memitem:ga964bb0e901179bc5eac126d77b0590eb" id="r_ga964bb0e901179bc5eac126d77b0590eb"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga964bb0e901179bc5eac126d77b0590eb">jsocketpp::Socket::writeWithTotalTimeout</a> (std::string_view data, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga964bb0e901179bc5eac126d77b0590eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the full payload with a total timeout across all retries.  <br /></td></tr>
<tr class="memitem:ga8e539c866c9fcad3578f9be78cbfdaf4" id="r_ga8e539c866c9fcad3578f9be78cbfdaf4"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e539c866c9fcad3578f9be78cbfdaf4">jsocketpp::Socket::writevWithTotalTimeout</a> (std::span&lt; const std::string_view &gt; buffers, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga8e539c866c9fcad3578f9be78cbfdaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all buffers fully within a total timeout using vectorized I/O.  <br /></td></tr>
<tr class="memitem:ga650e041e62870ef5710b0e45401e679d" id="r_ga650e041e62870ef5710b0e45401e679d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga650e041e62870ef5710b0e45401e679d">jsocketpp::Socket::writevFrom</a> (std::span&lt; const <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers) const</td></tr>
<tr class="memdesc:ga650e041e62870ef5710b0e45401e679d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes multiple raw memory regions using vectorized I/O.  <br /></td></tr>
<tr class="memitem:ga7b3ab7a896b7fbfeba9b80672c41b236" id="r_ga7b3ab7a896b7fbfeba9b80672c41b236"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7b3ab7a896b7fbfeba9b80672c41b236">jsocketpp::Socket::writevFromAll</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers) const</td></tr>
<tr class="memdesc:ga7b3ab7a896b7fbfeba9b80672c41b236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all raw memory regions fully using scatter/gather I/O.  <br /></td></tr>
<tr class="memitem:ga3e2b5bd60122d459134cd5b0a3a27077" id="r_ga3e2b5bd60122d459134cd5b0a3a27077"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3e2b5bd60122d459134cd5b0a3a27077">jsocketpp::Socket::writevFromWithTotalTimeout</a> (std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt; buffers, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga3e2b5bd60122d459134cd5b0a3a27077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all raw memory buffers fully within a timeout using scatter I/O.  <br /></td></tr>
<tr class="memitem:ga3fb196157a1cde167c47a596c9235c91" id="r_ga3fb196157a1cde167c47a596c9235c91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3fb196157a1cde167c47a596c9235c91">jsocketpp::Socket::setInternalBufferSize</a> (std::size_t newLen)</td></tr>
<tr class="memdesc:ga3fb196157a1cde167c47a596c9235c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the internal read buffer used for string operations.  <br /></td></tr>
<tr class="memitem:gae2b10ef466023b380a34b062359c0f65" id="r_gae2b10ef466023b380a34b062359c0f65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae2b10ef466023b380a34b062359c0f65">jsocketpp::Socket::isValid</a> () const noexcept</td></tr>
<tr class="memdesc:gae2b10ef466023b380a34b062359c0f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the socket is valid and open for communication.  <br /></td></tr>
<tr class="memitem:ga6b39b1375048cc167409b5b513c3ad8c" id="r_ga6b39b1375048cc167409b5b513c3ad8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6b39b1375048cc167409b5b513c3ad8c">jsocketpp::Socket::waitReady</a> (bool forWrite, int timeoutMillis) const</td></tr>
<tr class="memdesc:ga6b39b1375048cc167409b5b513c3ad8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the socket to become ready for reading or writing.  <br /></td></tr>
<tr class="memitem:ga368ea24012b68fcf6db4f9a75d6d1940" id="r_ga368ea24012b68fcf6db4f9a75d6d1940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga368ea24012b68fcf6db4f9a75d6d1940">jsocketpp::Socket::isClosed</a> () const noexcept</td></tr>
<tr class="memdesc:ga368ea24012b68fcf6db4f9a75d6d1940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the socket has been closed or invalidated.  <br /></td></tr>
<tr class="memitem:ga402fc4a398e670854cbb4edf791c1916" id="r_ga402fc4a398e670854cbb4edf791c1916"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga402fc4a398e670854cbb4edf791c1916">jsocketpp::Socket::isInputShutdown</a> () const noexcept</td></tr>
<tr class="memdesc:ga402fc4a398e670854cbb4edf791c1916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the socket's input stream has been shutdown.  <br /></td></tr>
<tr class="memitem:gad2b2992b358d3656a2e0d3e854c897bc" id="r_gad2b2992b358d3656a2e0d3e854c897bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad2b2992b358d3656a2e0d3e854c897bc">jsocketpp::Socket::isOutputShutdown</a> () const noexcept</td></tr>
<tr class="memdesc:gad2b2992b358d3656a2e0d3e854c897bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the socket's output stream has been shutdown.  <br /></td></tr>
<tr class="memitem:ga756c4e2148cfe7974fe191099341fccf" id="r_ga756c4e2148cfe7974fe191099341fccf"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga756c4e2148cfe7974fe191099341fccf">jsocketpp::Socket::readIntoInternal</a> (void *buffer, std::size_t len, bool exact=false) const</td></tr>
<tr class="memdesc:ga756c4e2148cfe7974fe191099341fccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the socket into a user-supplied buffer.  <br /></td></tr>
<tr class="memitem:ga744a91706b9510d266b7c07e31f3e028" id="r_ga744a91706b9510d266b7c07e31f3e028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga744a91706b9510d266b7c07e31f3e028">jsocketpp::Socket::cleanup</a> ()</td></tr>
<tr class="memdesc:ga744a91706b9510d266b7c07e31f3e028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper that closes the socket and clears address resolution state.  <br /></td></tr>
<tr class="memitem:gaf80aa30f2806a17b930878841dfab7ad" id="r_gaf80aa30f2806a17b930878841dfab7ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf80aa30f2806a17b930878841dfab7ad">jsocketpp::Socket::cleanupAndThrow</a> (int errorCode)</td></tr>
<tr class="memdesc:gaf80aa30f2806a17b930878841dfab7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the socket, resets internal state, and throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>.  <br /></td></tr>
<tr class="memitem:ga8bc150c503e051c12165680e74b5ae48" id="r_ga8bc150c503e051c12165680e74b5ae48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8bc150c503e051c12165680e74b5ae48">jsocketpp::Socket::cleanupAndRethrow</a> ()</td></tr>
<tr class="memdesc:ga8bc150c503e051c12165680e74b5ae48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up socket resources and rethrows the currently active exception.  <br /></td></tr>
<tr class="memitem:ga41e5ecdf97be51a3a354429be87b12d0" id="r_ga41e5ecdf97be51a3a354429be87b12d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41e5ecdf97be51a3a354429be87b12d0">jsocketpp::Socket::resetShutdownFlags</a> () noexcept</td></tr>
<tr class="memdesc:ga41e5ecdf97be51a3a354429be87b12d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets internal shutdown state flags to <span class="tt">false</span>.  <br /></td></tr>
<tr class="memitem:ga634bfa30476b72bfa4cca63a93c558a9" id="r_ga634bfa30476b72bfa4cca63a93c558a9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ga634bfa30476b72bfa4cca63a93c558a9 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga634bfa30476b72bfa4cca63a93c558a9">jsocketpp::Socket::read</a> ()</td></tr>
<tr class="memdesc:ga634bfa30476b72bfa4cca63a93c558a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <span class="tt"><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a>&lt;T&gt;()</span> for reading a single buffer of string data.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friend-members" class="groupheader"><a id="friend-members" name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga11a8bb11feaafab939278a8285afa567" id="r_ga11a8bb11feaafab939278a8285afa567"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga11a8bb11feaafab939278a8285afa567">jsocketpp::Socket::ServerSocket</a></td></tr>
<tr class="memdesc:ga11a8bb11feaafab939278a8285afa567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grants <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> access to private members.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Classes and functions for TCP networking. </p>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga5a797cf5d657594189d4fc14fcb87788" name="ga5a797cf5d657594189d4fc14fcb87788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a797cf5d657594189d4fc14fcb87788">&#9670;&#160;</a></span>accept() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> ServerSocket::accept </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept an incoming client connection, waiting up to the specified timeout and applying socket tuning options. </p>
<p>This method waits for a client connection using the specified timeout (in milliseconds), then calls the underlying system <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> and returns a fully configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> object.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md757"></a>
⏱ Timeout Behavior</h3>
<ul>
<li>If <span class="tt">timeoutMillis</span> is <b>negative</b>, the method blocks indefinitely.</li>
<li>If <span class="tt">timeoutMillis</span> is <b>zero</b>, the method polls once and returns immediately if no client is waiting.</li>
<li>If <span class="tt">timeoutMillis</span> is <b>positive</b>, the method waits up to that many milliseconds before throwing a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> if no connection is made.</li>
</ul>
<p>Internally, this method uses <span class="tt">waitReady(timeoutMillis)</span> (based on <span class="tt">select()</span>) to wait for readiness and then calls <span class="tt"><a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a></span> with the resolved parameters.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md759"></a>
⚙️ Configuration of Accepted Socket</h3>
<p>The returned <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> will be configured with the following tuning options:</p><ul>
<li><span class="tt">recvBufferSize</span>, <span class="tt">sendBufferSize</span>: OS-level buffer sizes (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li><span class="tt">internalBufferSize</span>: Internal buffer for high-level <span class="tt">read()</span> operations</li>
<li><span class="tt">soRecvTimeoutMillis</span>: Socket-level receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds</li>
<li><span class="tt">soSendTimeoutMillis</span>: Socket-level send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds</li>
<li><span class="tt">tcpNoDelay</span>: Disables Nagle’s algorithm for latency-sensitive connections (default: <span class="tt">true</span>)</li>
<li><span class="tt">keepAlive</span>: Enables TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>)</li>
<li><span class="tt">nonBlocking</span>: Immediately sets the accepted socket to non-blocking mode</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md761"></a>
⚠️ Thread Safety</h3>
<p>This method is <b>not thread-safe</b>. Concurrent calls to <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span>, <span class="tt"><a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a></span>, or <span class="tt"><a class="el" href="#gaa825d267c5cba8febdd2824282869ac1" title="Attempts to accept a client connection in non-blocking mode and returns a fully configured Socket.">acceptNonBlocking()</a></span> from multiple threads or processes may lead to race conditions. Synchronize access to the <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> if needed.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md763"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> server(8080);</div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <a class="code hl_class" href="classjsocketpp_1_1Socket.html">Socket</a> client = server.accept(2000,              <span class="comment">// Wait up to 2 seconds</span></div>
<div class="line">                                   8192, 8192, 8192,  <span class="comment">// Buffer sizes</span></div>
<div class="line">                                   3000, 1000,        <span class="comment">// Timeouts</span></div>
<div class="line">                                   <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>  <span class="comment">// TCP_NODELAY, keepAlive, nonBlocking</span></div>
<div class="line">    );</div>
<div class="line">    handleClient(client);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketTimeoutException.html">SocketTimeoutException</a>&amp;) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;No client connected within timeout.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassjsocketpp_1_1SocketTimeoutException_html"><div class="ttname"><a href="classjsocketpp_1_1SocketTimeoutException.html">jsocketpp::SocketTimeoutException</a></div><div class="ttdoc">Exception class for socket operations that time out.</div><div class="ttdef"><b>Definition</b> SocketTimeoutException.hpp:39</div></div>
<div class="ttc" id="aclassjsocketpp_1_1Socket_html"><div class="ttname"><a href="classjsocketpp_1_1Socket.html">jsocketpp::Socket</a></div><div class="ttdoc">TCP client connection abstraction (Java-like interface).</div><div class="ttdef"><b>Definition</b> Socket.hpp:93</div></div>
<div class="ttc" id="agroup__tcp_html_ga58290010ec759550485b8eeede8d931a"><div class="ttname"><a href="#ga58290010ec759550485b8eeede8d931a">jsocketpp::ServerSocket::ServerSocket</a></div><div class="ttdeci">ServerSocket()=delete</div><div class="ttdoc">Default constructor (deleted) for ServerSocket class.</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Timeout in milliseconds to wait for a connection:<ul>
<li>Negative: block indefinitely</li>
<li>Zero: poll once and return immediately</li>
<li>Positive: wait up to this many milliseconds</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional socket receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional socket send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Internal buffer used by <span class="tt">read()</span> and <span class="tt">read&lt;T&gt;()</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Receive timeout in milliseconds (<span class="tt">SO_RCVTIMEO</span>); <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Send timeout in milliseconds (<span class="tt">SO_SNDTIMEO</span>); <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>Whether to disable Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>); default: <span class="tt">true</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>Whether to enable TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>Whether to set the accepted socket to non-blocking mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> representing the connected client</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The server socket is invalid or closed</li>
<li><span class="tt"><a class="el" href="#ga61c1904213b0971817ec917fd2a01ccf" title="Waits for the server socket to become ready to accept an incoming connection.">waitReady()</a></span> or <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> fails</li>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> configuration fails after acceptance</li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If no client connects before the timeout expires</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Server socket must be valid, bound, and listening </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Returns a connected <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> or throws an exception on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a>, <a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a>, <a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a>, <a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a>, <a class="el" href="#ga61c1904213b0971817ec917fd2a01ccf" title="Waits for the server socket to become ready to accept an incoming connection.">waitReady()</a> </dd></dl>

</div>
</div>
<a id="gac645e511797a5c5cffd1ee490ece0e96" name="gac645e511797a5c5cffd1ee490ece0e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac645e511797a5c5cffd1ee490ece0e96">&#9670;&#160;</a></span>accept() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> ServerSocket::accept </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept an incoming client connection, respecting the configured socket timeout and applying tuning options. </p>
<p>This method waits for an incoming connection using the timeout set via <span class="tt"><a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a></span> or <span class="tt"><a class="el" href="group__socketopts.html#ga7829c558cb7bf5e0a46d882df82acc19" title="Get the logical timeout (in milliseconds) for accept operations.">getSoTimeout()</a></span>. Once a connection is ready, it calls the underlying system <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> and returns a fully configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> object with the specified buffer sizes, timeouts, and TCP socket options.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md748"></a>
⏱ Timeout Behavior</h3>
<ul>
<li>If the timeout is <b>negative</b> (default), the method blocks indefinitely.</li>
<li>If the timeout is <b>zero</b>, it polls once and returns immediately if no client is waiting.</li>
<li>If the timeout is <b>positive</b>, it waits for the given number of milliseconds before throwing a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> if no connection occurs.</li>
</ul>
<p>Internally, this method uses <span class="tt">select()</span> via <span class="tt"><a class="el" href="#ga61c1904213b0971817ec917fd2a01ccf" title="Waits for the server socket to become ready to accept an incoming connection.">waitReady()</a></span> to wait for readiness, then invokes <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span>. The socket’s blocking mode (via <span class="tt"><a class="el" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a></span>) does <b>not</b> affect this method.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md750"></a>
⚙️ Configuration of Accepted Socket</h3>
<p>The returned <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> is configured immediately using the provided tuning parameters:</p><ul>
<li><span class="tt">recvBufferSize</span>, <span class="tt">sendBufferSize</span>: OS-level socket buffers (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li><span class="tt">internalBufferSize</span>: Internal buffer used by <span class="tt">read&lt;T&gt;()</span> and <span class="tt">read&lt;std::string&gt;()</span></li>
<li><span class="tt">soRecvTimeoutMillis</span>: Read timeout in milliseconds (<span class="tt">SO_RCVTIMEO</span>); <span class="tt">-1</span> disables</li>
<li><span class="tt">soSendTimeoutMillis</span>: Send timeout in milliseconds (<span class="tt">SO_SNDTIMEO</span>); <span class="tt">-1</span> disables</li>
<li><span class="tt">tcpNoDelay</span>: Disables Nagle’s algorithm for low-latency communication (default: <span class="tt">true</span>)</li>
<li><span class="tt">keepAlive</span>: Enables TCP keep-alive probes</li>
<li><span class="tt">nonBlocking</span>: If <span class="tt">true</span>, the accepted socket is set to non-blocking mode</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md752"></a>
⚠️ Thread Safety</h3>
<p>This method is <b>not thread-safe</b>. Concurrent calls to <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> or <span class="tt"><a class="el" href="#gaa825d267c5cba8febdd2824282869ac1" title="Attempts to accept a client connection in non-blocking mode and returns a fully configured Socket.">acceptNonBlocking()</a></span> from multiple threads or processes may cause race conditions or undefined behavior. Protect the <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> instance with a mutex if needed.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md754"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> server(8080);</div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line">server.setSoTimeout(5000); <span class="comment">// 5-second accept timeout</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <a class="code hl_class" href="classjsocketpp_1_1Socket.html">Socket</a> client = server.accept(</div>
<div class="line">        8192, 8192, 8192,</div>
<div class="line">        3000, 1000,</div>
<div class="line">        <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="line">    handleClient(client);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketTimeoutException.html">SocketTimeoutException</a>&amp;) {</div>
<div class="line">    <span class="comment">// No client connected within 5 seconds</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional socket receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional socket send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Optional internal buffer size for high-level reads </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Read timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>Whether to disable Nagle's algorithm (<span class="tt">TCP_NODELAY</span>); default: <span class="tt">true</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>Whether to enable TCP keep-alive probes (<span class="tt">SO_KEEPALIVE</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>Whether to set the accepted socket to non-blocking mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> representing the connected client</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The server socket is invalid, closed, or in an incorrect state</li>
<li><span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> fails due to a system error</li>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> configuration fails after acceptance</li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If the timeout expires with no connection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The server socket must be valid, bound, and listening </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A connected and configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> is returned on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a>, <a class="el" href="group__socketopts.html#ga7829c558cb7bf5e0a46d882df82acc19" title="Get the logical timeout (in milliseconds) for accept operations.">getSoTimeout()</a>, <a class="el" href="#ga61c1904213b0971817ec917fd2a01ccf" title="Waits for the server socket to become ready to accept an incoming connection.">waitReady()</a>, <a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a>, <a class="el" href="#gaa825d267c5cba8febdd2824282869ac1" title="Attempts to accept a client connection in non-blocking mode and returns a fully configured Socket.">acceptNonBlocking()</a> </dd></dl>

</div>
</div>
<a id="gafc1d1883c490172751065d491001e049" name="gafc1d1883c490172751065d491001e049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc1d1883c490172751065d491001e049">&#9670;&#160;</a></span>acceptAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ServerSocket::acceptAsync </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(std::optional&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt;, std::exception_ptr)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously accept a client connection and invoke a callback upon completion or error. </p>
<p>This method starts a detached background thread that performs a socket <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> and invokes a user-provided callback upon completion. It is designed for event-driven or callback-oriented architectures where blocking or polling is not desirable.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md817"></a>
⚙️ Behavior</h3>
<ul>
<li>Accepts one client connection in a background thread</li>
<li>Applies the same tuning options available to synchronous <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> methods</li>
<li>If a client connects, the callback receives a fully constructed <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> and <span class="tt">nullptr</span> exception</li>
<li>If an error occurs, the callback receives <span class="tt">std::nullopt</span> and a <span class="tt">std::exception_ptr</span></li>
<li>You may rethrow the exception in the callback using <span class="tt">std::rethrow_exception()</span></li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md819"></a>
🔁 Callback Signature</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> callback(std::optional&lt;Socket&gt;, std::exception_ptr);</div>
</div><!-- fragment --><ul>
<li>On success: the <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> contains a valid connection, and the <span class="tt">exception_ptr</span> is <span class="tt">nullptr</span></li>
<li>On error: the <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> is empty, and the <span class="tt">exception_ptr</span> holds a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span>, etc.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md821"></a>
⚠️ Thread Safety</h3>
<p>This method is <b>not thread-safe</b>. Do not call <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span>, <span class="tt"><a class="el" href="#gad31e3456825d69842685b8826a0ad346" title="Asynchronously accept an incoming client connection, returning a std::future that resolves to a confi...">acceptAsync()</a></span>, or related methods concurrently on the same <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> unless access is externally synchronized.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md823"></a>
⚠️ Lifetime Warning</h3>
<p>The <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> must outlive the background thread and callback execution. Destroying the <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> before the callback is invoked results in <b>undefined behavior</b>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md825"></a>
⚙️ Configuration of Accepted Socket</h3>
<p>The <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> passed to the callback (if any) will be configured using:</p><ul>
<li><span class="tt">recvBufferSize</span>, <span class="tt">sendBufferSize</span>: OS-level buffer sizes (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li><span class="tt">internalBufferSize</span>: Internal buffer used by <span class="tt">read&lt;T&gt;()</span> and <span class="tt">read&lt;std::string&gt;()</span></li>
<li><span class="tt">soRecvTimeoutMillis</span>: <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds</li>
<li><span class="tt">soSendTimeoutMillis</span>: <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds</li>
<li><span class="tt">tcpNoDelay</span>: Disables Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>) (default: <span class="tt">true</span>)</li>
<li><span class="tt">keepAlive</span>: Enables TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>)</li>
<li><span class="tt">nonBlocking</span>: Immediately sets the accepted socket to non-blocking mode</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md827"></a>
🧠 Example</h3>
<div class="fragment"><div class="line">server.acceptAsync(</div>
<div class="line">    [](std::optional&lt;Socket&gt; clientOpt, std::exception_ptr eptr) {</div>
<div class="line">        <span class="keywordflow">if</span> (eptr) {</div>
<div class="line">            <span class="keywordflow">try</span> { std::rethrow_exception(eptr); }</div>
<div class="line">            <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>&amp; ex) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Accept failed: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (clientOpt) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Accepted client from: &quot;</span></div>
<div class="line">                      &lt;&lt; clientOpt-&gt;getRemoteSocketAddress() &lt;&lt; std::endl;</div>
<div class="line">            <span class="comment">// Handle client...</span></div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line">    8192, 4096, 8192, 3000, 1000, <span class="keyword">true</span>, <span class="keyword">true</span>, false</div>
<div class="line">);</div>
<div class="ttc" id="aclassjsocketpp_1_1SocketException_html"><div class="ttname"><a href="classjsocketpp_1_1SocketException.html">jsocketpp::SocketException</a></div><div class="ttdoc">Represents socket-related errors in the jsocketpp library.</div><div class="ttdef"><b>Definition</b> SocketException.hpp:63</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Completion handler that receives the accepted socket or an exception </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Optional internal buffer for <span class="tt">read&lt;T&gt;()</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>Whether to disable Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>); default: <span class="tt">true</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>Whether to enable TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>Whether to immediately make the accepted socket non-blocking</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The server socket must be valid, bound, and listening </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The callback is invoked exactly once, either with a valid <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> or an error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a>, <a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a>, <a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a>, acceptAsync(std::future) </dd>
<dd>
std::optional, std::exception_ptr, std::rethrow_exception </dd></dl>

</div>
</div>
<a id="gad31e3456825d69842685b8826a0ad346" name="gad31e3456825d69842685b8826a0ad346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad31e3456825d69842685b8826a0ad346">&#9670;&#160;</a></span>acceptAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt; ServerSocket::acceptAsync </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously accept an incoming client connection, returning a <span class="tt">std::future</span> that resolves to a configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>. </p>
<p>This method initiates an asynchronous accept operation on the server socket using <span class="tt">std::async(std::launch::async, ...)</span>. It returns a <span class="tt">std::future&lt;<a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>&gt;</span> that will become ready once a client is accepted or an error/timeout occurs.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md806"></a>
⚙️ Behavior</h3>
<ul>
<li>The calling thread is <b>never blocked</b></li>
<li>A background thread calls <span class="tt">accept(...)</span> with the specified tuning options</li>
<li>When <span class="tt">.get()</span> is called on the future:<ul>
<li>If successful, a fully configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> is returned</li>
<li>If an error occurred, the exception is rethrown (<span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span>, etc.)</li>
</ul>
</li>
</ul>
<p>This function is ideal for use in thread-based architectures where the server must continue operating while waiting for new clients in parallel.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md808"></a>
⚠️ Thread Safety</h3>
<p>This method is <b>not thread-safe</b>. You must externally synchronize calls to <span class="tt"><a class="el" href="#gad31e3456825d69842685b8826a0ad346" title="Asynchronously accept an incoming client connection, returning a std::future that resolves to a confi...">acceptAsync()</a></span>, <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span>, <span class="tt"><a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a></span>, and related methods on the same <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> instance.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md810"></a>
⚠️ Lifetime Warning</h3>
<p>The <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> object must remain valid and alive <b>at least until</b> the returned <span class="tt">std::future</span> has resolved and <span class="tt">.get()</span> has been called. Using this method in contexts where the <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> may be destroyed early can lead to undefined behavior or dangling references.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md812"></a>
⚙️ Configuration of Accepted Socket</h3>
<p>The returned <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (from <span class="tt">.get()</span>) will be initialized with:</p><ul>
<li><span class="tt">recvBufferSize</span>, <span class="tt">sendBufferSize</span>: OS-level buffer sizes (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li><span class="tt">internalBufferSize</span>: High-level internal buffer used for <span class="tt">read()</span> / <span class="tt">read&lt;T&gt;()</span></li>
<li><span class="tt">soRecvTimeoutMillis</span>: <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> read timeout in milliseconds (<span class="tt">SO_RCVTIMEO</span>)</li>
<li><span class="tt">soSendTimeoutMillis</span>: <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> send timeout in milliseconds (<span class="tt">SO_SNDTIMEO</span>)</li>
<li><span class="tt">tcpNoDelay</span>: Disables Nagle’s algorithm for lower latency (default: <span class="tt">true</span>)</li>
<li><span class="tt">keepAlive</span>: Enables TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>)</li>
<li><span class="tt">nonBlocking</span>: If <span class="tt">true</span>, sets the accepted socket to non-blocking mode</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md814"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> server(8080);</div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line"> </div>
<div class="line">std::future&lt;Socket&gt; future = server.acceptAsync(</div>
<div class="line">    8192, 8192, 8192,     <span class="comment">// buffer sizes</span></div>
<div class="line">    3000, 1000,           <span class="comment">// socket timeouts</span></div>
<div class="line">    <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>     <span class="comment">// TCP_NODELAY, keep-alive, non-blocking</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do other work...</span></div>
<div class="line"><span class="keywordflow">if</span> (future.wait_for(std::chrono::seconds(5)) == std::future_status::ready) {</div>
<div class="line">    <a class="code hl_class" href="classjsocketpp_1_1Socket.html">Socket</a> client = future.get(); <span class="comment">// May throw</span></div>
<div class="line">    handleClient(client);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Still waiting or timed out.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional socket receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional socket send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Optional internal buffer size for <span class="tt">read&lt;T&gt;()</span> operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>Whether to disable Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>); default: <span class="tt">true</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>Whether to enable TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>Whether to immediately set the accepted socket to non-blocking mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt">std::future&lt;<a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>&gt;</span> that resolves to a connected and configured client socket, or throws on error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If a fatal socket error occurs during background accept </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If no client connects and the configured timeout expires</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Server socket must be valid, bound, and listening </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Future resolves to a connected <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>, or throws from <span class="tt">.get()</span></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a>, <a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a>, <a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a>, <a class="el" href="#gaa825d267c5cba8febdd2824282869ac1" title="Attempts to accept a client connection in non-blocking mode and returns a fully configured Socket.">acceptNonBlocking()</a>, acceptAsync(callback), std::future, std::async </dd></dl>

</div>
</div>
<a id="ga4cc6cc771e29a9d1964cb8b351262318" name="ga4cc6cc771e29a9d1964cb8b351262318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cc6cc771e29a9d1964cb8b351262318">&#9670;&#160;</a></span>acceptBlocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> ServerSocket::acceptBlocking </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts a TCP client connection, configures the socket, and returns a high-level <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> object. </p>
<p>This method calls the underlying system <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> on the listening server socket.</p><ul>
<li>If the socket is in <b>blocking mode</b> (default), this method blocks until a client connects.</li>
<li>If the socket is in <b>non-blocking mode</b>, it returns immediately:<ul>
<li>If a client is pending, it returns a configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>.</li>
<li>If no client is waiting, it throws <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with <span class="tt">EWOULDBLOCK</span> or <span class="tt">EAGAIN</span>.</li>
</ul>
</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md788"></a>
⚙️ Behavior</h3>
<ul>
<li>Applies OS-level buffer sizes (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>) to the accepted socket</li>
<li>Applies high-level <span class="tt">internalBufferSize</span> for <span class="tt">read&lt;T&gt;()</span></li>
<li>Configures optional timeouts for send and receive operations</li>
<li>Enables/disables TCP features like Nagle’s algorithm and keep-alive</li>
<li>Sets blocking mode immediately after accept if requested</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md790"></a>
🧪 Comparison with <span class="tt">acceptNonBlocking()</span></h3>
<ul>
<li>Both methods rely on the socket’s current blocking mode</li>
<li><span class="tt"><a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a></span> always throws on failure, including <span class="tt">EWOULDBLOCK</span></li>
<li><span class="tt"><a class="el" href="#gaa825d267c5cba8febdd2824282869ac1" title="Attempts to accept a client connection in non-blocking mode and returns a fully configured Socket.">acceptNonBlocking()</a></span> is used in polling loops where no connection is not an error</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md792"></a>
⚠️ Thread Safety</h3>
<p>This method is <b>not thread-safe</b>. Simultaneous <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> calls on the same <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> from multiple threads may result in race conditions or inconsistent results.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md794"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> server(8080);</div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Blocking pattern</span></div>
<div class="line"><a class="code hl_class" href="classjsocketpp_1_1Socket.html">Socket</a> client = server.acceptBlocking(8192, 8192, 8192,</div>
<div class="line">                                      3000, 1000, <span class="comment">// timeouts</span></div>
<div class="line">                                      <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Non-blocking pattern</span></div>
<div class="line">server.<a class="code hl_function" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b">setNonBlocking</a>(<span class="keyword">true</span>);</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <a class="code hl_class" href="classjsocketpp_1_1Socket.html">Socket</a> client = server.acceptBlocking(); <span class="comment">// may throw EWOULDBLOCK</span></div>
<div class="line">    <span class="comment">// handle client</span></div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>&amp; ex) {</div>
<div class="line">    <span class="keywordflow">if</span> (ex.code() == EWOULDBLOCK) {</div>
<div class="line">        <span class="comment">// no connection available yet</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">throw</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__socketopts_html_ga5f2dffc2949b06b1d945e590bce7f05b"><div class="ttname"><a href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b">jsocketpp::SocketOptions::setNonBlocking</a></div><div class="ttdeci">void setNonBlocking(bool nonBlocking)</div><div class="ttdoc">Enables or disables non-blocking mode on the socket.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:223</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional socket receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional socket send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Internal buffer used by <span class="tt">read&lt;T&gt;()</span> and <span class="tt">read&lt;std::string&gt;()</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>Whether to disable Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>Whether to enable TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>Whether to immediately make the accepted socket non-blocking</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> object representing the connected client</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The server socket is not bound or listening</li>
<li><span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> fails</li>
<li>No client is waiting in non-blocking mode (<span class="tt">EWOULDBLOCK</span>, <span class="tt">EAGAIN</span>)</li>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> configuration (timeouts, buffers, etc.) fails after <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Server socket must be open, bound, and in listening state. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A new <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> is returned on success, or an exception is thrown on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa825d267c5cba8febdd2824282869ac1" title="Attempts to accept a client connection in non-blocking mode and returns a fully configured Socket.">acceptNonBlocking()</a>, <a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a>, <a class="el" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a>, <a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a>, <a class="el" href="group__socketopts.html#ga7107a9da459b00bf39ec2fe4d3e83396" title="Sets the socket send timeout (SO_SNDTIMEO) in milliseconds.">setSoSendTimeout()</a> </dd></dl>

</div>
</div>
<a id="gaa825d267c5cba8febdd2824282869ac1" name="gaa825d267c5cba8febdd2824282869ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa825d267c5cba8febdd2824282869ac1">&#9670;&#160;</a></span>acceptNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt; ServerSocket::acceptNonBlocking </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to accept a client connection in non-blocking mode and returns a fully configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>. </p>
<p>This method calls the system <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> in non-blocking mode to check for pending client connections:</p>
<ul>
<li>If a client is ready, it wraps the accepted connection into a configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> object.</li>
<li>If no client is waiting, it returns <span class="tt">std::nullopt</span> without throwing.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md797"></a>
🔁 Blocking Behavior</h3>
<ul>
<li>If the server socket is in <b>blocking mode</b> (default), this call <b>blocks</b> until a client connects.</li>
<li>If the socket is in <b>non-blocking mode</b> (<span class="tt">setNonBlocking(true)</span>), it returns immediately:<ul>
<li>If a client is ready, returns a configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>.</li>
<li>If no client is pending, returns <span class="tt">std::nullopt</span>.</li>
</ul>
</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md799"></a>
⚙️ Configuration</h3>
<p>If a client is accepted, the returned <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> will be configured using the following options:</p>
<ul>
<li><span class="tt">recvBufferSize</span> / <span class="tt">sendBufferSize</span>: OS-level socket buffers (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li><span class="tt">internalBufferSize</span>: Internal buffer used by <span class="tt">read()</span> and <span class="tt">read&lt;T&gt;()</span></li>
<li><span class="tt">soRecvTimeoutMillis</span>: Read timeout in milliseconds (<span class="tt">SO_RCVTIMEO</span>)</li>
<li><span class="tt">soSendTimeoutMillis</span>: Send timeout in milliseconds (<span class="tt">SO_SNDTIMEO</span>)</li>
<li><span class="tt">tcpNoDelay</span>: Disables Nagle’s algorithm for lower latency (<span class="tt">TCP_NODELAY</span>)</li>
<li><span class="tt">keepAlive</span>: Enables TCP keep-alive probes (<span class="tt">SO_KEEPALIVE</span>)</li>
<li><span class="tt">nonBlocking</span>: If <span class="tt">true</span>, the accepted socket is made non-blocking immediately</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md801"></a>
⚠️ Notes</h3>
<ul>
<li>This method does <b>not</b> use <span class="tt">select()</span>, <span class="tt">poll()</span>, or <span class="tt">epoll()</span> internally.</li>
<li>It is ideal for event-loop and polling-based architectures where you explicitly check for readiness.</li>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> behavior is determined entirely by whether <span class="tt">setNonBlocking(true)</span> was called on the server socket.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md803"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> server(8080);</div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line">server.setNonBlocking(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <span class="keyword">auto</span> client = server.acceptNonBlocking(</div>
<div class="line">        8192, 8192, 8192,</div>
<div class="line">        5000, 1000,</div>
<div class="line">        <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (client) {</div>
<div class="line">        handleClient(*client);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// No connection yet; do other work</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional socket receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional socket send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Internal buffer size for <span class="tt">read&lt;T&gt;()</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Read timeout in milliseconds (<span class="tt">SO_RCVTIMEO</span>); <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Send timeout in milliseconds (<span class="tt">SO_SNDTIMEO</span>); <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>Disables Nagle's algorithm (<span class="tt">TCP_NODELAY</span>) if <span class="tt">true</span> (default: true) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>Enables TCP keep-alive probes (<span class="tt">SO_KEEPALIVE</span>) if <span class="tt">true</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>Sets the accepted socket to non-blocking mode if <span class="tt">true</span></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> if a client is pending, or <span class="tt">std::nullopt</span> if no connection is ready</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The server socket is invalid or closed</li>
<li><span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> fails due to a system error (excluding <span class="tt">EWOULDBLOCK</span> or <span class="tt">EAGAIN</span>)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The server socket must be bound and listening </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Returns a connected <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> or <span class="tt">std::nullopt</span> if no client is available</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a>, <a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a>, <a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a>, <a class="el" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a>, <a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a>, <a class="el" href="group__socketopts.html#ga9839dd8837c7519a627f28b3a4c7a513" title="Enables or disables Nagle’s algorithm (TCP_NODELAY) on TCP sockets.">setTcpNoDelay()</a> </dd></dl>

</div>
</div>
<a id="ga1ca989ba16d32862dd4fa9bbb2b165b5" name="ga1ca989ba16d32862dd4fa9bbb2b165b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ca989ba16d32862dd4fa9bbb2b165b5">&#9670;&#160;</a></span>bind() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ServerSocket::bind </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the server socket to the configured port and network interface. </p>
<p>This method assigns a local address and port number to the socket, making it ready to accept incoming TCP connections.</p>
<ul>
<li><b>Preconditions:</b> The socket must have been created successfully (via the constructor) but must not be already bound or listening.</li>
<li><b>Typical usage:</b> Call <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> after configuring any desired socket options (such as address reuse) and before calling <span class="tt"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a></span>.</li>
<li><b>Effect:</b> Once <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> succeeds, the server socket is associated with the local port specified during construction, and is ready to transition to listening mode with <span class="tt"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a></span>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>If you want to override the default address reuse behavior or other options, you must call the corresponding setter methods <em>before</em> calling <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span>. After <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> is called, changes to those options will have no effect.</li>
<li>On error, this function throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> containing the specific error code and message.</li>
<li>This function is cross-platform and works on both Windows and Unix-like systems.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the bind operation fails (for example, if the port is already in use or insufficient permissions).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a3d85400180a3ee56838c165e7b459e80" title="Selected address info for binding.">_selectedAddrInfo</a></span> must not be null. </dd>
<dd>
The socket must not be already bound. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The socket is bound to the specified address and port.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__socketopts.html#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a>, <a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a>, ServerSocket(Port)</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a> server(8080);</div>
<div class="line">server.setReuseAddress(<span class="keyword">true</span>); <span class="comment">// Optional: customize before binding</span></div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="ttc" id="aclassjsocketpp_1_1ServerSocket_html"><div class="ttname"><a href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a></div><div class="ttdoc">TCP server socket abstraction for cross-platform C++ networking.</div><div class="ttdef"><b>Definition</b> ServerSocket.hpp:100</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gace1da4f860ac0af46d702cb5fc875a51" name="gace1da4f860ac0af46d702cb5fc875a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace1da4f860ac0af46d702cb5fc875a51">&#9670;&#160;</a></span>bind() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::bind </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the client socket to all interfaces using an ephemeral port. </p>
<p>This overload delegates to the default configuration — bind to any interface, with any available port. Equivalent to calling <span class="tt"><a class="el" href="#gae9a523509c0b63f91a801613dec85b39" title="Binds the client socket to a specific local IP address and/or port.">bind</a>("", 0)</span>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if binding fails or the socket is already bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga477422f8e69c0114cc539926b7f6bc68" name="ga477422f8e69c0114cc539926b7f6bc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga477422f8e69c0114cc539926b7f6bc68">&#9670;&#160;</a></span>bind() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the client socket to all interfaces (INADDR_ANY) using the specified port. </p>
<p>This overload binds to all available network interfaces using a specific local port. Equivalent to calling <span class="tt"><a class="el" href="#gae9a523509c0b63f91a801613dec85b39" title="Binds the client socket to a specific local IP address and/or port.">bind</a>("", port)</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a> number to bind to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if binding fails or the socket is already bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9a523509c0b63f91a801613dec85b39" name="gae9a523509c0b63f91a801613dec85b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a523509c0b63f91a801613dec85b39">&#9670;&#160;</a></span>bind() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::bind </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>localHost</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the client socket to a specific local IP address and/or port. </p>
<p>This method provides fine-grained control over the local endpoint from which a client socket originates. It supports both IPv4 and IPv6 resolution, dual-stack addressing, and wildcard or specific local interfaces.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md862"></a>
Common Use Cases:</h3>
<ul>
<li>P2P or NAT traversal clients requiring fixed source ports</li>
<li>Multihomed systems selecting a specific local interface</li>
<li>Unit testing with known local port bindings</li>
<li>UDP clients that do not connect but still need a listening endpoint</li>
</ul>
<p>This method must be called after the socket is constructed and before <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span>. It can only be called once; repeated calls will throw. Internally uses <span class="tt">getaddrinfo()</span> for resolution and retries all returned addresses until binding succeeds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localHost</td><td>A local IP address or hostname to bind to (e.g., "127.0.0.1" or "::1"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a> number to bind to. Use <span class="tt">0</span> to allow the OS to auto-assign one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if resolution or binding fails, or if the socket is already bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a> </dd>
<dd>
<a class="el" href="group__socketopts.html#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a> </dd>
<dd>
<a class="el" href="group__socketopts.html#ga8e8783ada3142cd6c3b275e01b7b12f2" title="Queries whether the socket is currently configured to allow address reuse.">getReuseAddress()</a> </dd></dl>

</div>
</div>
<a id="ga2a630f28a613224176ff17f7ee0c6a4c" name="ga2a630f28a613224176ff17f7ee0c6a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a630f28a613224176ff17f7ee0c6a4c">&#9670;&#160;</a></span>cleanup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ServerSocket::cleanup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up internal resources and resets the server socket state. </p>
<p>This internal method ensures proper teardown of socket-related resources without throwing exceptions. It is used by destructors and error-handling code to guarantee that:</p>
<ul>
<li>The socket file descriptor is closed (if valid)</li>
<li>Address resolution memory is released (<span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a98d2690356bf0f8a20d0f4251d7f4b3b" title="Address info for binding (from getaddrinfo).">_srvAddrInfo</a></span>)</li>
<li>Internal state flags (<span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a7eab52c9455b134172f3b71ba0b2722a" title="True if the server socket is bound.">_isBound</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a1a1cb37f9d062197674a9129d51f1e44" title="True if the server socket is listening.">_isListening</a></span>) are reset</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md832"></a>
Behavior</h3>
<ul>
<li>If the socket is open, it is closed using <span class="tt"><a class="el" href="namespacejsocketpp.html#a12fd46ba498b19d6102220bc100ef931">CloseSocket()</a></span></li>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> descriptor is invalidated by setting it to <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></li>
<li>Address info pointers are reset to null</li>
<li>Internal state flags are cleared</li>
</ul>
<p>This method is <b>noexcept-safe</b> and must never throw. It is typically used in destructors, move operations, and failure paths to ensure consistent and exception-safe resource management.</p>
<dl class="section note"><dt>Note</dt><dd>Errors during socket closure are silently ignored. </dd>
<dd>
This method does <b>not</b> throw; use <span class="tt"><a class="el" href="#gab5572cb795d9b45ee50a0ddf9cb9c075" title="Cleans up internal resources and throws a SocketException.">cleanupAndThrow()</a></span> if you need exception propagation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0245d40096ca089255c67303eebf17e6" title="Closes the server socket and releases its associated system resources.">close()</a>, <a class="el" href="#gab5572cb795d9b45ee50a0ddf9cb9c075" title="Cleans up internal resources and throws a SocketException.">cleanupAndThrow()</a>, <a class="el" href="#ga33183210cdc2a1e281006e325cc2a173" title="Cleans up internal resources and rethrows the current exception.">cleanupAndRethrow()</a> </dd></dl>

</div>
</div>
<a id="ga744a91706b9510d266b7c07e31f3e028" name="ga744a91706b9510d266b7c07e31f3e028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga744a91706b9510d266b7c07e31f3e028">&#9670;&#160;</a></span>cleanup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::cleanup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal helper that closes the socket and clears address resolution state. </p>
<p>This method performs safe resource cleanup for the client socket. It is intended to be reused across error-handling paths to ensure that partially initialized socket state is properly discarded, avoiding leaks or undefined behavior.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md984"></a>
⚙️ Behavior</h3>
<ul>
<li>If the socket is valid (<span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>), it is closed via <span class="tt"><a class="el" href="namespacejsocketpp.html#a12fd46ba498b19d6102220bc100ef931">CloseSocket()</a></span></li>
<li>The socket handle is reset to <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></li>
<li>Address resolution state is cleared:<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html#a50a79dbf8d56379ae0bfbfa2a186a9f1" title="Address info for connection (from getaddrinfo).">_cliAddrInfo</a></span> (client-side addrinfo list) is released</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html#ac4ae016cffe61f7c8ba9572ed98922aa" title="Selected address info for connection.">_selectedAddrInfo</a></span> is reset to <span class="tt">nullptr</span></li>
</ul>
</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md986"></a>
🔒 Safety</h3>
<ul>
<li>It is safe to call this method multiple times; redundant socket closes are prevented</li>
<li>Designed to be noexcept and side-effect free beyond its resource cleanup</li>
<li>Intended for use within exception paths only (never throws)</li>
</ul>
<hr  />
<dl class="section note"><dt>Note</dt><dd>This method is used internally by <span class="tt"><a class="el" href="#gaf80aa30f2806a17b930878841dfab7ad" title="Closes the socket, resets internal state, and throws a SocketException.">cleanupAndThrow()</a></span> and <span class="tt"><a class="el" href="#ga8bc150c503e051c12165680e74b5ae48" title="Cleans up socket resources and rethrows the currently active exception.">cleanupAndRethrow()</a></span> to centralize socket cleanup logic during construction or reconfiguration failures.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method does not throw. Use <span class="tt"><a class="el" href="#gaf80aa30f2806a17b930878841dfab7ad" title="Closes the socket, resets internal state, and throws a SocketException.">cleanupAndThrow()</a></span> or <span class="tt"><a class="el" href="#ga8bc150c503e051c12165680e74b5ae48" title="Cleans up socket resources and rethrows the currently active exception.">cleanupAndRethrow()</a></span> when control flow needs to propagate an error after cleanup.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf80aa30f2806a17b930878841dfab7ad" title="Closes the socket, resets internal state, and throws a SocketException.">cleanupAndThrow()</a>, <a class="el" href="#ga8bc150c503e051c12165680e74b5ae48" title="Cleans up socket resources and rethrows the currently active exception.">cleanupAndRethrow()</a>, <a class="el" href="namespacejsocketpp.html#a12fd46ba498b19d6102220bc100ef931">CloseSocket()</a>, <a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a> </dd></dl>

</div>
</div>
<a id="ga33183210cdc2a1e281006e325cc2a173" name="ga33183210cdc2a1e281006e325cc2a173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33183210cdc2a1e281006e325cc2a173">&#9670;&#160;</a></span>cleanupAndRethrow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ServerSocket::cleanupAndRethrow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up internal resources and rethrows the current exception. </p>
<p>This method is used in exception-handling blocks to perform safe cleanup of the <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>'s internal state and then rethrow the original exception. It ensures that:</p><ul>
<li>The socket descriptor is closed if still open</li>
<li>Address resolution memory (<span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a98d2690356bf0f8a20d0f4251d7f4b3b" title="Address info for binding (from getaddrinfo).">_srvAddrInfo</a></span>) is freed</li>
<li>All internal state flags are reset</li>
</ul>
<p>This guarantees consistent resource teardown in exception paths, and supports strong exception safety.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md834"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// some operation that may throw</span></div>
<div class="line">} <span class="keywordflow">catch</span> (...) {</div>
<div class="line">    <a class="code hl_function" href="#ga33183210cdc2a1e281006e325cc2a173">cleanupAndRethrow</a>();</div>
<div class="line">}</div>
<div class="ttc" id="agroup__tcp_html_ga33183210cdc2a1e281006e325cc2a173"><div class="ttname"><a href="#ga33183210cdc2a1e281006e325cc2a173">jsocketpp::ServerSocket::cleanupAndRethrow</a></div><div class="ttdeci">void cleanupAndRethrow()</div><div class="ttdoc">Cleans up internal resources and rethrows the current exception.</div><div class="ttdef"><b>Definition</b> ServerSocket.cpp:135</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Rethrows</td><td>the currently active exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method must be called only from inside a <span class="tt">catch</span> block. </dd>
<dd>
It preserves the original exception type and message.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2a630f28a613224176ff17f7ee0c6a4c" title="Cleans up internal resources and resets the server socket state.">cleanup()</a>, <a class="el" href="#gab5572cb795d9b45ee50a0ddf9cb9c075" title="Cleans up internal resources and throws a SocketException.">cleanupAndThrow()</a> </dd></dl>

</div>
</div>
<a id="ga8bc150c503e051c12165680e74b5ae48" name="ga8bc150c503e051c12165680e74b5ae48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bc150c503e051c12165680e74b5ae48">&#9670;&#160;</a></span>cleanupAndRethrow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::cleanupAndRethrow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up socket resources and rethrows the currently active exception. </p>
<p>This method is intended for use within a <span class="tt">catch</span> block to safely clean up a partially initialized or failed <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> before rethrowing the active exception. It ensures that all client-side socket resources are properly released, including the socket descriptor and any resolved address info, before propagating the error.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md994"></a>
⚙️ Behavior</h3>
<p>Internally delegates to <span class="tt"><a class="el" href="#ga744a91706b9510d266b7c07e31f3e028" title="Internal helper that closes the socket and clears address resolution state.">cleanup()</a></span> to:</p><ul>
<li>Close the socket if valid (<span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> != <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>)</li>
<li>Reset the socket handle to <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></li>
<li>Release client address info (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html#a50a79dbf8d56379ae0bfbfa2a186a9f1" title="Address info for connection (from getaddrinfo).">_cliAddrInfo</a></span>)</li>
<li>Clear <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html#ac4ae016cffe61f7c8ba9572ed98922aa" title="Selected address info for connection.">_selectedAddrInfo</a></span></li>
</ul>
<p>Then immediately rethrows the current exception using <span class="tt">throw;</span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md996"></a>
⚠️ Usage Notes</h3>
<ul>
<li>This method <b>must</b> be called from within a <span class="tt">catch</span> block. If no active exception is present, calling <span class="tt">throw;</span> results in undefined behavior.</li>
<li>Do <b>not</b> pass an exception object manually. <span class="tt">throw;</span> preserves the full exception context, including type, stack trace, and nested information.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md998"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <a class="code hl_function" href="group__socketopts.html#ga69fdecc0aaaef4bbd2826c448a8bbe1d">setReceiveBufferSize</a>(...);</div>
<div class="line">    <a class="code hl_function" href="group__socketopts.html#ga9839dd8837c7519a627f28b3a4c7a513">setTcpNoDelay</a>(...);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>&amp;) {</div>
<div class="line">    <a class="code hl_function" href="#ga8bc150c503e051c12165680e74b5ae48">cleanupAndRethrow</a>(); <span class="comment">// Ensure resources are freed, then rethrow</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__socketopts_html_ga69fdecc0aaaef4bbd2826c448a8bbe1d"><div class="ttname"><a href="group__socketopts.html#ga69fdecc0aaaef4bbd2826c448a8bbe1d">jsocketpp::SocketOptions::setReceiveBufferSize</a></div><div class="ttdeci">void setReceiveBufferSize(std::size_t size)</div><div class="ttdoc">Sets the socket&#39;s receive buffer size (SO_RCVBUF).</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:107</div></div>
<div class="ttc" id="agroup__socketopts_html_ga9839dd8837c7519a627f28b3a4c7a513"><div class="ttname"><a href="group__socketopts.html#ga9839dd8837c7519a627f28b3a4c7a513">jsocketpp::SocketOptions::setTcpNoDelay</a></div><div class="ttdeci">void setTcpNoDelay(bool on)</div><div class="ttdoc">Enables or disables Nagle’s algorithm (TCP_NODELAY) on TCP sockets.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:264</div></div>
<div class="ttc" id="agroup__tcp_html_ga8bc150c503e051c12165680e74b5ae48"><div class="ttname"><a href="#ga8bc150c503e051c12165680e74b5ae48">jsocketpp::Socket::cleanupAndRethrow</a></div><div class="ttdeci">void cleanupAndRethrow()</div><div class="ttdoc">Cleans up socket resources and rethrows the currently active exception.</div><div class="ttdef"><b>Definition</b> Socket.cpp:115</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>Always rethrows the currently active exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga744a91706b9510d266b7c07e31f3e028" title="Internal helper that closes the socket and clears address resolution state.">cleanup()</a>, <a class="el" href="#gaf80aa30f2806a17b930878841dfab7ad" title="Closes the socket, resets internal state, and throws a SocketException.">cleanupAndThrow()</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a> </dd>
<dd>
<a class="el" href="namespacejsocketpp.html#a12fd46ba498b19d6102220bc100ef931">CloseSocket()</a> </dd></dl>

</div>
</div>
<a id="gab5572cb795d9b45ee50a0ddf9cb9c075" name="gab5572cb795d9b45ee50a0ddf9cb9c075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5572cb795d9b45ee50a0ddf9cb9c075">&#9670;&#160;</a></span>cleanupAndThrow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ServerSocket::cleanupAndThrow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>errorCode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up internal resources and throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>. </p>
<p>This method is used when a fatal socket error occurs during construction or setup. It ensures that:</p><ul>
<li>The socket descriptor is closed if still valid</li>
<li>All allocated resources (e.g., <span class="tt">addrinfo</span>) are released</li>
<li>Internal state is reset</li>
</ul>
<p>After cleanup, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown with the provided error code. This ensures RAII-compliant error handling and prevents resource leaks in failure paths.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md833"></a>
Behavior</h3>
<ul>
<li>Invokes <span class="tt"><a class="el" href="namespacejsocketpp.html#a12fd46ba498b19d6102220bc100ef931">CloseSocket()</a></span> on the socket descriptor if open</li>
<li>Resets <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a98d2690356bf0f8a20d0f4251d7f4b3b" title="Address info for binding (from getaddrinfo).">_srvAddrInfo</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a3d85400180a3ee56838c165e7b459e80" title="Selected address info for binding.">_selectedAddrInfo</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a7eab52c9455b134172f3b71ba0b2722a" title="True if the server socket is bound.">_isBound</a></span>, and <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a1a1cb37f9d062197674a9129d51f1e44" title="True if the server socket is listening.">_isListening</a></span></li>
<li>Throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with the specified <span class="tt">errorCode</span></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errorCode</td><td>The error code to propagate via <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>Always throws after cleaning up internal state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is typically used in constructors or setup functions like <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> when a system error occurs and recovery is not possible.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2a630f28a613224176ff17f7ee0c6a4c" title="Cleans up internal resources and resets the server socket state.">cleanup()</a>, <a class="el" href="#ga33183210cdc2a1e281006e325cc2a173" title="Cleans up internal resources and rethrows the current exception.">cleanupAndRethrow()</a>, <a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a> </dd></dl>

</div>
</div>
<a id="gaf80aa30f2806a17b930878841dfab7ad" name="gaf80aa30f2806a17b930878841dfab7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf80aa30f2806a17b930878841dfab7ad">&#9670;&#160;</a></span>cleanupAndThrow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::cleanupAndThrow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>errorCode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the socket, resets internal state, and throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>. </p>
<p>This method performs safe cleanup of all internal socket resources and throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with the specified error code and human-readable message. It is used to centralize error handling during socket creation or connection setup, ensuring that no resources are leaked if initialization fails.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md989"></a>
⚙️ Behavior</h3>
<p>Internally, this method delegates to <span class="tt"><a class="el" href="#ga744a91706b9510d266b7c07e31f3e028" title="Internal helper that closes the socket and clears address resolution state.">cleanup()</a></span> to:</p><ul>
<li>Close the socket if it's open (<span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a></span>)</li>
<li>Reset the socket handle to <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span></li>
<li>Release address resolution results (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html#a50a79dbf8d56379ae0bfbfa2a186a9f1" title="Address info for connection (from getaddrinfo).">_cliAddrInfo</a></span>)</li>
<li>Clear the active address pointer (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html#ac4ae016cffe61f7c8ba9572ed98922aa" title="Selected address info for connection.">_selectedAddrInfo</a></span>)</li>
</ul>
<p>It then throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> with:</p><ul>
<li>The provided <span class="tt">errorCode</span></li>
<li>The result of <span class="tt">SocketErrorMessage(errorCode)</span></li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md991"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga93cc325113abb7433288338ca3facde1">::connect</a>(<a class="code hl_function" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794">getSocketFd</a>(), ...) == <a class="code hl_variable" href="namespacejsocketpp.html#adc2dd9860dec2a3c3189e756288d5ba2">SOCKET_ERROR</a>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="#gaf80aa30f2806a17b930878841dfab7ad">cleanupAndThrow</a>(<a class="code hl_function" href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">GetSocketError</a>());</div>
<div class="line">}</div>
<div class="ttc" id="agroup__socketopts_html_gaced4c6dc799564ece9ce4e6766b1d794"><div class="ttname"><a href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794">jsocketpp::SocketOptions::getSocketFd</a></div><div class="ttdeci">SOCKET getSocketFd() const noexcept</div><div class="ttdoc">Retrieves the native socket handle (file descriptor or OS-level handle).</div><div class="ttdef"><b>Definition</b> SocketOptions.hpp:275</div></div>
<div class="ttc" id="agroup__tcp_html_ga93cc325113abb7433288338ca3facde1"><div class="ttname"><a href="#ga93cc325113abb7433288338ca3facde1">jsocketpp::Socket::connect</a></div><div class="ttdeci">void connect(int timeoutMillis=-1)</div><div class="ttdoc">Establishes a TCP connection to the remote host with optional timeout control.</div><div class="ttdef"><b>Definition</b> Socket.cpp:165</div></div>
<div class="ttc" id="agroup__tcp_html_gaf80aa30f2806a17b930878841dfab7ad"><div class="ttname"><a href="#gaf80aa30f2806a17b930878841dfab7ad">jsocketpp::Socket::cleanupAndThrow</a></div><div class="ttdeci">void cleanupAndThrow(int errorCode)</div><div class="ttdoc">Closes the socket, resets internal state, and throws a SocketException.</div><div class="ttdef"><b>Definition</b> Socket.cpp:109</div></div>
<div class="ttc" id="anamespacejsocketpp_html_aac009a479ad7c6c77530e5e270cb25ad"><div class="ttname"><a href="namespacejsocketpp.html#aac009a479ad7c6c77530e5e270cb25ad">jsocketpp::GetSocketError</a></div><div class="ttdeci">int GetSocketError()</div><div class="ttdef"><b>Definition</b> common.hpp:246</div></div>
<div class="ttc" id="anamespacejsocketpp_html_adc2dd9860dec2a3c3189e756288d5ba2"><div class="ttname"><a href="namespacejsocketpp.html#adc2dd9860dec2a3c3189e756288d5ba2">jsocketpp::SOCKET_ERROR</a></div><div class="ttdeci">constexpr SOCKET SOCKET_ERROR</div><div class="ttdef"><b>Definition</b> common.hpp:265</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errorCode</td><td>The error code to report in the thrown <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>Always throws after cleanup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga744a91706b9510d266b7c07e31f3e028" title="Internal helper that closes the socket and clears address resolution state.">cleanup()</a> </dd>
<dd>
<a class="el" href="#ga8bc150c503e051c12165680e74b5ae48" title="Cleans up socket resources and rethrows the currently active exception.">cleanupAndRethrow()</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a> </dd>
<dd>
<a class="el" href="namespacejsocketpp.html#a1d0357025eb782be52907801696556ca" title="Convert a socket-related error code to a human-readable message.">SocketErrorMessage()</a> </dd></dl>

</div>
</div>
<a id="ga0245d40096ca089255c67303eebf17e6" name="ga0245d40096ca089255c67303eebf17e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0245d40096ca089255c67303eebf17e6">&#9670;&#160;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ServerSocket::close </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the server socket and releases its associated system resources. </p>
<p>This method closes the underlying server socket, making it no longer able to accept new client connections. After calling <span class="tt"><a class="el" href="#ga0245d40096ca089255c67303eebf17e6" title="Closes the server socket and releases its associated system resources.">close()</a></span>, the server socket enters the <b>CLOSED</b> state, and any further operations such as <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span>, <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span>, or <span class="tt"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a></span> will fail with an exception.</p>
<p>Key details:</p><ul>
<li>All file descriptors or handles associated with the server socket are released.</li>
<li>This operation is <b>idempotent</b>: calling <span class="tt"><a class="el" href="#ga0245d40096ca089255c67303eebf17e6" title="Closes the server socket and releases its associated system resources.">close()</a></span> multiple times on the same socket is safe, but only the first call has effect.</li>
<li>Existing client sockets returned by <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> are unaffected; you must close them individually.</li>
<li>On many systems, closing a socket that is actively being used may result in a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> if a system error occurs.</li>
<li>After closing, you should not use this <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> object for further network operations.</li>
</ul>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a> server(8080);</div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line"><span class="comment">// ... handle clients ...</span></div>
<div class="line">server.close(); <span class="comment">// Clean up when done</span></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If an error occurs while closing the socket (for example, if the underlying system call fails).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On some systems, closing a socket with active client connections does not forcibly disconnect clients, but simply prevents new connections from being accepted. </dd>
<dd>
Always close your sockets when finished to prevent resource leaks! </dd></dl>

</div>
</div>
<a id="ga75ee749264ccbcfc4dfbf5442e55dcb8" name="ga75ee749264ccbcfc4dfbf5442e55dcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75ee749264ccbcfc4dfbf5442e55dcb8">&#9670;&#160;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::close </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the socket connection and releases associated resources. </p>
<p>Close the socket.</p>
<p>This method performs an orderly shutdown and closure of the socket connection:</p><ol type="1">
<li>Closes the underlying socket descriptor</li>
<li>Releases address information resources</li>
<li>Resets internal state</li>
</ol>
<p>The method ensures proper cleanup even if the socket is already closed. After calling <a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a>, the <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object remains valid but disconnected (<a class="el" href="#gae2b10ef466023b380a34b062359c0f65" title="Check if the socket is valid and open for communication.">isValid()</a> will return false).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md938"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line">sock.connect();</div>
<div class="line"><span class="comment">// ... use socket ...</span></div>
<div class="line">sock.close();  <span class="comment">// Explicitly close when done</span></div>
<div class="ttc" id="agroup__tcp_html_ga6da94c322a3ed5f85efd26a7fbadbe0a"><div class="ttname"><a href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">jsocketpp::Socket::Socket</a></div><div class="ttdeci">Socket(SOCKET client, const sockaddr_storage &amp;addr, socklen_t len, std::size_t recvBufferSize=DefaultBufferSize, std::size_t sendBufferSize=DefaultBufferSize, std::size_t internalBufferSize=DefaultBufferSize, int soRecvTimeoutMillis=-1, int soSendTimeoutMillis=-1, bool tcpNoDelay=true, bool keepAlive=false, bool nonBlocking=false)</div><div class="ttdoc">Wraps an accepted TCP client socket with optional tuning parameters.</div><div class="ttdef"><b>Definition</b> Socket.cpp:12</div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md939"></a>
Resource Management</h3>
<ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is automatically closed in destructor if not done explicitly</li>
<li>Safe to call multiple times (subsequent calls have no effect)</li>
<li>Frees system resources immediately rather than waiting for destruction</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the close operation fails due to:<ul>
<li>System resource errors</li>
<li>Invalid socket state</li>
<li>Platform-specific network errors</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is not thread-safe. Do not call <a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a> while other threads are performing operations on the same <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> instance.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a> For finer control over connection termination </dd>
<dd>
<a class="el" href="#gafa933f0914d99522c857b30f64c9ce32" title="Destructs the Socket object, closing connections and freeing resources.">~Socket()</a> Destructor that automatically closes the socket </dd>
<dd>
<a class="el" href="#gae2b10ef466023b380a34b062359c0f65" title="Check if the socket is valid and open for communication.">isValid()</a> Check if socket is still valid after closing</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93cc325113abb7433288338ca3facde1" name="ga93cc325113abb7433288338ca3facde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93cc325113abb7433288338ca3facde1">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::connect </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a TCP connection to the remote host with optional timeout control. </p>
<p>Attempts to connect to the remote host and port specified during <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> construction. This method supports both blocking and non-blocking connection attempts, depending on the <span class="tt">timeoutMillis</span> parameter.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md898"></a>
Connection Modes</h3>
<ul>
<li><b>Blocking Mode</b> (<span class="tt">timeoutMillis &lt; 0</span>):<ul>
<li>Performs a traditional blocking <a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a>.</li>
<li>The call blocks until the connection succeeds or fails.</li>
<li>Best suited for synchronous applications.</li>
</ul>
</li>
<li><b>Non-blocking Mode with Timeout</b> (<span class="tt">timeoutMillis &gt;= 0</span>):<ul>
<li>Temporarily switches the socket to non-blocking mode.</li>
<li>Initiates a connection and waits for readiness using <span class="tt">select()</span>.</li>
<li>Throws an exception if the connection does not complete within the timeout period.</li>
<li>Restores original blocking mode automatically (RAII).</li>
<li>Recommended for GUI, async, or responsive applications.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md899"></a>
Implementation Details</h3>
<ul>
<li>Uses <span class="tt">::connect()</span> followed by <span class="tt">::select()</span> to monitor write readiness.</li>
<li>Once writable, uses <span class="tt">getsockopt(SO_ERROR)</span> to determine if the connection succeeded.</li>
<li>On POSIX systems, if the socket descriptor exceeds <span class="tt">FD_SETSIZE</span>, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown.</li>
<li>The socket's original blocking mode is automatically restored using <span class="tt">ScopedBlockingMode</span>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md900"></a>
Platform Notes</h3>
<ul>
<li>On <b>POSIX</b>, <span class="tt">select()</span> monitors the socket using <span class="tt">fd_set</span>; the file descriptor must be <span class="tt">&lt; FD_SETSIZE</span> (typically 1024).</li>
<li>On <b>Windows</b>, <span class="tt">select()</span> ignores its first parameter and allows descriptors up to <span class="tt">~2030</span>, but limits still apply.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md901"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Blocking connect (waits indefinitely)</span></div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Connect with a 5-second timeout (non-blocking)</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    sock.connect(5000);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketTimeoutException.html">SocketTimeoutException</a>&amp; timeout) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Connection timed out\\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> SocketException&amp; ex) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Connect failed: &quot;</span> &lt;&lt; ex.what() &lt;&lt; <span class="stringliteral">&quot;\\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Connection timeout in milliseconds:<ul>
<li>Negative: use blocking mode (no timeout)</li>
<li>Zero or positive: maximum wait duration in milliseconds</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If the connection did not complete before the timeout. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>No address information was resolved</li>
<li>The socket is invalid or closed</li>
<li>The connection fails (e.g., refused, unreachable, or timed out)</li>
<li>The descriptor exceeds platform-specific <span class="tt">select()</span> limits</li>
<li><span class="tt">getsockopt()</span> reports an error after select returns success</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is <b>not thread-safe</b>. Do not call <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> on the same <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> instance concurrently from multiple threads.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2" title="Indicates whether the socket has been successfully connected to a remote host.">isConnected()</a> Check if the connection was established </dd>
<dd>
<a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a> Close the socket </dd>
<dd>
<a class="el" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a> Permanently change blocking mode </dd>
<dd>
<a class="el" href="#ga6b39b1375048cc167409b5b513c3ad8c" title="Waits for the socket to become ready for reading or writing.">waitReady()</a> Low-level readiness polling with timeout </dd></dl>

</div>
</div>
<a id="ga7492730c56e0bf5a4c67227df7bc4033" name="ga7492730c56e0bf5a4c67227df7bc4033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7492730c56e0bf5a4c67227df7bc4033">&#9670;&#160;</a></span>discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::discard </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>chunkSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1024</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discards exactly <span class="tt">n</span> bytes from the socket by reading and discarding them. </p>
<p>This method reads and discards <span class="tt">n</span> bytes from the socket without returning any data. It is useful in scenarios where part of the stream should be skipped (e.g., headers, fixed-length preambles, corrupted payloads).</p>
<p>The discard operation is performed using a temporary buffer of configurable size, which defaults to 1024 bytes. If the chunk size is 0, the method throws an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of bytes to discard. Must be greater than 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunkSize</td><td>Size (in bytes) of the temporary buffer used for reading/discarding. Default is 1024.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid</li>
<li>An error occurs during <span class="tt">recv()</span></li>
<li>The connection is closed before all <span class="tt">n</span> bytes are discarded</li>
<li><span class="tt">chunkSize</span> is 0</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For optimal performance on high-throughput streams or large discards, consider using a larger chunk size (e.g., 4096 or 8192). </dd></dl>

</div>
</div>
<a id="gac1f9d646223bb7c733216b484f517d46" name="gac1f9d646223bb7c733216b484f517d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1f9d646223bb7c733216b484f517d46">&#9670;&#160;</a></span>getDefaultInternalBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::ServerSocket::getDefaultInternalBufferSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the per-instance default internal buffer size used for buffered read operations. </p>
<p>Returns the current value of <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#aa799b52c795a1245b1a18945ceacce6b" title="Default internal buffer size for accepted client sockets, used by some read() methods.">_defaultInternalBufferSize</a></span>, which is used as the fallback size for internal buffering in stream-oriented socket reads when no explicit buffer size is provided.</p>
<p>This value is typically initialized to <span class="tt"><a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a></span> (4096 bytes), but can be modified using <span class="tt"><a class="el" href="#gab42832248058c119c99ef60c4d72d478" title="Set the per-instance default internal buffer size used for buffered read operations.">setDefaultInternalBufferSize()</a></span>.</p>
<dl class="section return"><dt>Returns</dt><dd>The current default internal buffer size in bytes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab42832248058c119c99ef60c4d72d478" title="Set the per-instance default internal buffer size used for buffered read operations.">setDefaultInternalBufferSize()</a> </dd>
<dd>
<a class="el" href="#ga474741cb104a36bab217ea478608439c" title="Get the effective internal buffer size to use for buffered socket read operations.">getEffectiveInternalBufferSize()</a> </dd>
<dd>
<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a> </dd></dl>

</div>
</div>
<a id="ga29de003fbad91f7302115d26b89ac888" name="ga29de003fbad91f7302115d26b89ac888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29de003fbad91f7302115d26b89ac888">&#9670;&#160;</a></span>getDefaultReceiveBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::ServerSocket::getDefaultReceiveBufferSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current default receive buffer size for accepted client sockets. </p>
<p>Returns the buffer size that will be used when accepting new client connections. This is the value previously set by <a class="el" href="#gaf644d3fccaebced95dd6bc2055bbed3e" title="Set the default receive buffer size for accepted client sockets.">setDefaultReceiveBufferSize()</a> or the default if not set.</p>
<dl class="section return"><dt>Returns</dt><dd>Current buffer size in bytes </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf644d3fccaebced95dd6bc2055bbed3e" title="Set the default receive buffer size for accepted client sockets.">setDefaultReceiveBufferSize()</a> </dd>
<dd>
<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a> </dd>
<dd>
<a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a> </dd></dl>

</div>
</div>
<a id="ga80d2d5fc59fa2b10e586287d6ffd84f7" name="ga80d2d5fc59fa2b10e586287d6ffd84f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80d2d5fc59fa2b10e586287d6ffd84f7">&#9670;&#160;</a></span>getDefaultSendBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::ServerSocket::getDefaultSendBufferSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current default send buffer size for accepted client sockets. </p>
<p>Returns the send buffer size that will be used when accepting new client connections. This is the value previously set by <a class="el" href="#gadbeecdd1d47fb8244dab210fa297fcf9" title="Set the default send buffer size for accepted client sockets.">setDefaultSendBufferSize()</a> or the default if not set.</p>
<dl class="section return"><dt>Returns</dt><dd>Current send buffer size in bytes </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gadbeecdd1d47fb8244dab210fa297fcf9" title="Set the default send buffer size for accepted client sockets.">setDefaultSendBufferSize()</a> </dd>
<dd>
<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a> </dd>
<dd>
<a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a> </dd></dl>

</div>
</div>
<a id="ga474741cb104a36bab217ea478608439c" name="ga474741cb104a36bab217ea478608439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga474741cb104a36bab217ea478608439c">&#9670;&#160;</a></span>getEffectiveInternalBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::ServerSocket::getEffectiveInternalBufferSize </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the effective internal buffer size to use for buffered socket read operations. </p>
<p>This helper determines the internal buffer size for read-related operations based on the provided optional value. If <span class="tt">internalBufferSize</span> is set, its value is returned directly. If not, the method returns the per-instance <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#aa799b52c795a1245b1a18945ceacce6b" title="Default internal buffer size for accepted client sockets, used by some read() methods.">_defaultInternalBufferSize</a></span>, which defaults to <span class="tt"><a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a></span> (4096 bytes) unless explicitly overridden via <span class="tt">setInternalBufferSize()</span>.</p>
<p>This internal buffer is used for stream-based operations (e.g. reading strings or protocol lines) and is distinct from the kernel-level socket buffers (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Optional buffer size override for a single operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The effective internal buffer size to use.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a> </dd>
<dd>
setInternalBufferSize() </dd>
<dd>
<a class="el" href="#ga21767c46469a8cee88a87f45405d36fd" title="Reads a line terminated by &#39; &#39; from the socket.">Socket::readLine()</a> </dd>
<dd>
Socket::getInternalBufferSize() </dd></dl>

</div>
</div>
<a id="gae01e7a531be7a5addb83ff6b9bb111e8" name="gae01e7a531be7a5addb83ff6b9bb111e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae01e7a531be7a5addb83ff6b9bb111e8">&#9670;&#160;</a></span>getEffectiveReceiveBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::ServerSocket::getEffectiveReceiveBufferSize </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the effective receive buffer size to use for socket read operations. </p>
<p>This helper determines the actual buffer size based on an optional user-provided value. If the parameter is <span class="tt">std::nullopt</span>, it returns the per-instance default receive buffer size; otherwise, it returns the explicitly provided value (even if it's 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional size. If unset, defaults to <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a379cd49443199046abc16d0761e1b03a" title="Default buffer size used for accepted client sockets when no specific size is provided.">_defaultReceiveBufferSize</a></span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The effective buffer size to use.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf644d3fccaebced95dd6bc2055bbed3e" title="Set the default receive buffer size for accepted client sockets.">setDefaultReceiveBufferSize()</a> </dd>
<dd>
<a class="el" href="#ga29de003fbad91f7302115d26b89ac888" title="Get the current default receive buffer size for accepted client sockets.">getDefaultReceiveBufferSize()</a> </dd>
<dd>
<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a> </dd></dl>

</div>
</div>
<a id="ga1308a8d172508999834853ccb35607e8" name="ga1308a8d172508999834853ccb35607e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1308a8d172508999834853ccb35607e8">&#9670;&#160;</a></span>getEffectiveSendBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::ServerSocket::getEffectiveSendBufferSize </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the effective send buffer size to use for socket write operations. </p>
<p>This helper determines the actual send buffer size based on an optional user-specified value. If the parameter is <span class="tt">std::nullopt</span>, it returns the per-instance default send buffer size. Otherwise, it returns the explicitly specified size (including zero if the caller intends it).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional size. If unset, defaults to <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a4c7bda2d03e2039dfa177a8a565e96ae" title="Default send buffer size for accepted client sockets.">_defaultSendBufferSize</a></span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The effective buffer size to use for send operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__socketopts.html#ga8279b0c70f6a0fddf73d84aac691422b" title="Sets the socket&#39;s send buffer size (SO_SNDBUF).">setSendBufferSize()</a> </dd>
<dd>
<a class="el" href="group__socketopts.html#gaeb5f9d1ae3f1b7b9fdb94335b10723f6" title="Retrieves the current send buffer size (SO_SNDBUF) of the socket.">getSendBufferSize()</a> </dd>
<dd>
<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a> </dd></dl>

</div>
</div>
<a id="ga6cd36845f959c2bf075c475e5fdc7620" name="ga6cd36845f959c2bf075c475e5fdc7620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cd36845f959c2bf075c475e5fdc7620">&#9670;&#160;</a></span>getLocalIp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::getLocalIp </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>convertIPv4Mapped</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the local IP address this socket is bound to. </p>
<p>This method returns the local interface IP address assigned to the socket, in numeric string format (e.g., <span class="tt">"127.0.0.1"</span>, <span class="tt">"192.168.1.5"</span>, or <span class="tt">"fe80::1"</span>). It reflects the interface to which the socket is bound — either explicitly via <span class="tt"><a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51" title="Binds the client socket to all interfaces using an ephemeral port.">bind()</a></span> or implicitly by the system during <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> or <span class="tt">accept()</span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md866"></a>
IPv4-Mapped IPv6 Behavior</h3>
<p>If the socket is using IPv6 and the local address is an IPv4-mapped IPv6 address (e.g., <span class="tt">::ffff:192.0.2.1</span>), and <span class="tt">convertIPv4Mapped == true</span>, this method will return the simplified IPv4 form (<span class="tt">"192.0.2.1"</span>).</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md868"></a>
Use Cases</h3>
<ul>
<li>Determine which local interface the socket is bound to</li>
<li>Diagnose behavior in multi-homed systems or NAT environments</li>
<li>Report or log client-side or server-side connection endpoints</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md870"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> client(<span class="stringliteral">&quot;example.com&quot;</span>, 443);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Local IP: &quot;</span> &lt;&lt; client.getLocalIp() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convertIPv4Mapped</td><td>Whether to normalize IPv4-mapped IPv6 addresses to plain IPv4 (default = true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local IP address as a string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the socket is not bound or the address cannot be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac10f731a7d1e90c18688266fe5db969e" title="Retrieves the local port number this socket is bound to.">getLocalPort()</a> </dd>
<dd>
<a class="el" href="#gab716648ffb451640b18f4f4363a22eb3" title="Retrieves the full local socket address in the form &quot;IP:port&quot;.">getLocalSocketAddress()</a> </dd>
<dd>
<a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51" title="Binds the client socket to all interfaces using an ephemeral port.">bind()</a>, <a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a>, accept() </dd></dl>

</div>
</div>
<a id="gad3b2807577129c652044f17626c6e01a" name="gad3b2807577129c652044f17626c6e01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3b2807577129c652044f17626c6e01a">&#9670;&#160;</a></span>getLocalPort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> ServerSocket::getLocalPort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the local port number to which the server socket is bound. </p>
<p>This method returns the port number that the server socket is currently bound to. This is particularly useful when the socket is bound to port <span class="tt">0</span>, which tells the operating system to automatically assign an available port. You can use this method after binding to discover the actual port being used.</p>
<dl class="section note"><dt>Note</dt><dd>This method is thread safe.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The local port number, or <span class="tt">0</span> if the socket is not bound. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if there is an error retrieving the port number.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> server(0); <span class="comment">// Bind to any available port</span></div>
<div class="line">server.bind();</div>
<div class="line"><a class="code hl_typedef" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> port = server.getLocalPort();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Server bound to port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</div>
<div class="ttc" id="agroup__core_html_ga1a7be273748ae3d91bc5ebe6499788a7"><div class="ttname"><a href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">jsocketpp::Port</a></div><div class="ttdeci">std::uint16_t Port</div><div class="ttdoc">Type alias representing a TCP or UDP port number (1–65535).</div><div class="ttdef"><b>Definition</b> common.hpp:392</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gac10f731a7d1e90c18688266fe5db969e" name="gac10f731a7d1e90c18688266fe5db969e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac10f731a7d1e90c18688266fe5db969e">&#9670;&#160;</a></span>getLocalPort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> Socket::getLocalPort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the local port number this socket is bound to. </p>
<p>This method returns the port number that the socket is currently bound to on the local system. It can be used after an explicit call to <span class="tt"><a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51" title="Binds the client socket to all interfaces using an ephemeral port.">bind()</a></span>, or implicitly after a successful <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> or <span class="tt">accept()</span> where the OS assigns an ephemeral port.</p>
<p>The value is returned in host byte order and reflects the actual bound state of the socket. If the socket is not yet bound, an exception will be thrown.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md872"></a>
Use Cases</h3>
<ul>
<li>Determine which port was assigned during <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> (for ephemeral clients)</li>
<li>Confirm fixed port bindings in server or P2P applications</li>
<li>Log local endpoints for diagnostics or auditing</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md874"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> client(<span class="stringliteral">&quot;example.com&quot;</span>, 443);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Local port: &quot;</span> &lt;&lt; client.getLocalPort() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The local port number in host byte order (as a 16-bit unsigned integer).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the socket is not bound or the port cannot be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6cd36845f959c2bf075c475e5fdc7620" title="Retrieves the local IP address this socket is bound to.">getLocalIp()</a> </dd>
<dd>
<a class="el" href="#ga2840142258bae9535c6421d6cd3dce1c" title="Retrieves the port number of the remote peer this TCP socket is connected to.">getRemotePort()</a> </dd>
<dd>
<a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51" title="Binds the client socket to all interfaces using an ephemeral port.">bind()</a> </dd>
<dd>
<a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a> </dd></dl>

</div>
</div>
<a id="ga5e035235b554db37df4492b5725e78cc" name="ga5e035235b554db37df4492b5725e78cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e035235b554db37df4492b5725e78cc">&#9670;&#160;</a></span>getLocalSocketAddress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ServerSocket::getLocalSocketAddress </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local socket address (IP and port) to which the server socket is bound. </p>
<p>Returns a string with the IP address and port in the format "ip:port" (e.g., "127.0.0.1:8080"). Useful for debugging, logging, and displaying server status.</p>
<dl class="section note"><dt>Note</dt><dd>This method is thread safe.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The local socket address as a string, or an empty string if the socket is not bound. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if there is an error retrieving the address.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> server(8080);</div>
<div class="line">server.bind();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Server bound to: &quot;</span> &lt;&lt; server.getLocalSocketAddress() &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gab716648ffb451640b18f4f4363a22eb3" name="gab716648ffb451640b18f4f4363a22eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab716648ffb451640b18f4f4363a22eb3">&#9670;&#160;</a></span>getLocalSocketAddress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::getLocalSocketAddress </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>convertIPv4Mapped</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the full local socket address in the form "IP:port". </p>
<p>This method returns a combined representation of the socket's local IP address and port number, formatted as a string. It is valid after the socket has been bound (explicitly via <span class="tt"><a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51" title="Binds the client socket to all interfaces using an ephemeral port.">bind()</a></span> or implicitly via <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> or <span class="tt">accept()</span>).</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md876"></a>
Format</h3>
<ul>
<li>For IPv4: <span class="tt">"127.0.0.1:8080"</span></li>
<li>For IPv6: <span class="tt">"[::1]:443"</span> (square brackets included for URI compatibility)</li>
<li>If <span class="tt">convertIPv4Mapped == true</span>, IPv4-mapped IPv6 addresses (<span class="tt">::ffff:192.0.2.1</span>) will be normalized to plain IPv4 (<span class="tt">192.0.2.1</span>)</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md878"></a>
Use Cases</h3>
<ul>
<li>Diagnostics: determine which interface/port the socket is bound to</li>
<li>Logging: record local endpoints for debugging or analytics</li>
<li>Multi-homed applications: distinguish binding behavior across interfaces</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md880"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> client(<span class="stringliteral">&quot;example.com&quot;</span>, 443);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Bound locally to: &quot;</span> &lt;&lt; client.getLocalSocketAddress() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convertIPv4Mapped</td><td>Whether to normalize IPv4-mapped IPv6 addresses to pure IPv4 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the local socket address in the form "IP:port" or "[IPv6]:port"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the local address or port cannot be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6cd36845f959c2bf075c475e5fdc7620" title="Retrieves the local IP address this socket is bound to.">getLocalIp()</a> </dd>
<dd>
<a class="el" href="#gac10f731a7d1e90c18688266fe5db969e" title="Retrieves the local port number this socket is bound to.">getLocalPort()</a> </dd>
<dd>
<a class="el" href="#ga92c62bf727779c6d7395809084f9e4dc" title="Get the connected peer&#39;s socket address as a formatted string.">getRemoteSocketAddress()</a> </dd></dl>

</div>
</div>
<a id="ga273e2d4847b5407bb8eef56d9e88996e" name="ga273e2d4847b5407bb8eef56d9e88996e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga273e2d4847b5407bb8eef56d9e88996e">&#9670;&#160;</a></span>getRemoteIp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::getRemoteIp </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>convertIPv4Mapped</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the IP address of the remote peer this TCP socket is connected to. </p>
<p>This method returns the remote IP address of the connected peer. It is only valid after a successful <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> or after a socket has been returned by <span class="tt">accept()</span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md882"></a>
🌍 Behavior</h3>
<ul>
<li>Returns an IPv4 or IPv6 address depending on the remote endpoint</li>
<li>For IPv6 sockets with IPv4-mapped addresses, set <span class="tt">convertIPv4Mapped</span> to <span class="tt">true</span> to return them in normalized IPv4 form</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md884"></a>
Use Cases</h3>
<ul>
<li>Logging connected clients (e.g. <span class="tt">"Accepted from 192.168.1.2"</span>)</li>
<li>Verifying peer identity or interface binding</li>
<li>Building connection summaries</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md886"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> client = serverSocket.accept();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Client IP: &quot;</span> &lt;&lt; client.<a class="code hl_function" href="#ga273e2d4847b5407bb8eef56d9e88996e">getRemoteIp</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="agroup__tcp_html_ga273e2d4847b5407bb8eef56d9e88996e"><div class="ttname"><a href="#ga273e2d4847b5407bb8eef56d9e88996e">jsocketpp::Socket::getRemoteIp</a></div><div class="ttdeci">std::string getRemoteIp(bool convertIPv4Mapped=true) const</div><div class="ttdoc">Retrieves the IP address of the remote peer this TCP socket is connected to.</div><div class="ttdef"><b>Definition</b> Socket.cpp:379</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convertIPv4Mapped</td><td>Whether to normalize IPv4-mapped IPv6 addresses (default = true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IP address string of the connected peer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the socket is not connected or the remote address cannot be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2840142258bae9535c6421d6cd3dce1c" title="Retrieves the port number of the remote peer this TCP socket is connected to.">getRemotePort()</a> </dd>
<dd>
<a class="el" href="#ga92c62bf727779c6d7395809084f9e4dc" title="Get the connected peer&#39;s socket address as a formatted string.">getRemoteSocketAddress()</a> </dd>
<dd>
<a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a>, accept() </dd></dl>

</div>
</div>
<a id="ga2840142258bae9535c6421d6cd3dce1c" name="ga2840142258bae9535c6421d6cd3dce1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2840142258bae9535c6421d6cd3dce1c">&#9670;&#160;</a></span>getRemotePort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a> Socket::getRemotePort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the port number of the remote peer this TCP socket is connected to. </p>
<p>This method returns the TCP port number of the peer to which this socket is currently connected. It is valid after a successful <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> or after a client socket has been accepted from a <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md888"></a>
Use Cases</h3>
<ul>
<li>Logging and monitoring TCP connections</li>
<li>Displaying peer socket addresses for user interfaces or diagnostic tools</li>
<li>Validating or filtering based on peer ports (e.g., ephemeral port detection)</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md890"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> client = serverSocket.accept();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Client is connected on port: &quot;</span> &lt;&lt; client.<a class="code hl_function" href="#ga2840142258bae9535c6421d6cd3dce1c">getRemotePort</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="agroup__tcp_html_ga2840142258bae9535c6421d6cd3dce1c"><div class="ttname"><a href="#ga2840142258bae9535c6421d6cd3dce1c">jsocketpp::Socket::getRemotePort</a></div><div class="ttdeci">Port getRemotePort() const</div><div class="ttdoc">Retrieves the port number of the remote peer this TCP socket is connected to.</div><div class="ttdef"><b>Definition</b> Socket.cpp:396</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The port number of the connected peer (host byte order).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the socket is not connected or the port cannot be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga273e2d4847b5407bb8eef56d9e88996e" title="Retrieves the IP address of the remote peer this TCP socket is connected to.">getRemoteIp()</a> </dd>
<dd>
<a class="el" href="#ga92c62bf727779c6d7395809084f9e4dc" title="Get the connected peer&#39;s socket address as a formatted string.">getRemoteSocketAddress()</a> </dd>
<dd>
<a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a>, accept() </dd></dl>

</div>
</div>
<a id="ga92c62bf727779c6d7395809084f9e4dc" name="ga92c62bf727779c6d7395809084f9e4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92c62bf727779c6d7395809084f9e4dc">&#9670;&#160;</a></span>getRemoteSocketAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::getRemoteSocketAddress </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>convertIPv4Mapped</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the connected peer's socket address as a formatted string. </p>
<p>Combines the IP address and port of the connected peer into a single human-readable string. This is valid after a successful <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> or after a connection is accepted from a <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md892"></a>
Format</h3>
<ul>
<li>For IPv4: <span class="tt">"192.168.0.42:443"</span></li>
<li>For IPv6: <span class="tt">"[fe80::1]:443"</span> (square brackets added for URI compatibility)</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md894"></a>
Use Cases</h3>
<ul>
<li>Connection logging (e.g., <span class="tt">"Accepted from: IP:port"</span>)</li>
<li>Debugging or monitoring active connections</li>
<li>UI and CLI-friendly representation of connected peers</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md896"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> client = serverSocket.accept();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Client connected from: &quot;</span> &lt;&lt; client.<a class="code hl_function" href="#ga92c62bf727779c6d7395809084f9e4dc">getRemoteSocketAddress</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="agroup__tcp_html_ga92c62bf727779c6d7395809084f9e4dc"><div class="ttname"><a href="#ga92c62bf727779c6d7395809084f9e4dc">jsocketpp::Socket::getRemoteSocketAddress</a></div><div class="ttdeci">std::string getRemoteSocketAddress(bool convertIPv4Mapped=true) const</div><div class="ttdoc">Get the connected peer&#39;s socket address as a formatted string.</div><div class="ttdef"><b>Definition</b> Socket.cpp:413</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">convertIPv4Mapped</td><td>Whether to normalize IPv4-mapped IPv6 addresses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the form <span class="tt">"IP:port"</span> or <span class="tt">"[IPv6]:port"</span>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the socket is not connected or the address cannot be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga273e2d4847b5407bb8eef56d9e88996e" title="Retrieves the IP address of the remote peer this TCP socket is connected to.">getRemoteIp()</a> </dd>
<dd>
<a class="el" href="#ga2840142258bae9535c6421d6cd3dce1c" title="Retrieves the port number of the remote peer this TCP socket is connected to.">getRemotePort()</a> </dd>
<dd>
<a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a>, accept() </dd></dl>

</div>
</div>
<a id="ga0b3a5cb732c669b678e03549e5af2427" name="ga0b3a5cb732c669b678e03549e5af2427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b3a5cb732c669b678e03549e5af2427">&#9670;&#160;</a></span>isBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::ServerSocket::isBound </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the server socket is bound to a local address. </p>
<p>Returns <span class="tt">true</span> if the socket has been successfully bound to a local address and port using the <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> method, or <span class="tt">false</span> otherwise. This means the socket has reserved a port but is not necessarily accepting connections yet.</p>
<p>Follows the naming and semantics of Java's <span class="tt"><a class="el" href="#ga0b3a5cb732c669b678e03549e5af2427" title="Check if the server socket is bound to a local address.">ServerSocket::isBound()</a></span>.</p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket is bound, <span class="tt">false</span> otherwise. </dd></dl>

</div>
</div>
<a id="gac5d9708cad057d6d608fb732eb1bb117" name="gac5d9708cad057d6d608fb732eb1bb117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d9708cad057d6d608fb732eb1bb117">&#9670;&#160;</a></span>isBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::Socket::isBound </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the socket has been explicitly bound to a local address and/or port. </p>
<p>Returns <span class="tt">true</span> if the socket has successfully completed a call to one of the <span class="tt"><a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51" title="Binds the client socket to all interfaces using an ephemeral port.">bind()</a></span> overloads. Binding is optional for client sockets, but is often required in advanced scenarios such as:</p><ul>
<li>Assigning a fixed local port for NAT traversal or predictable communication</li>
<li>Selecting a specific local interface in multihomed environments</li>
<li>Participating in multicast, broadcast, or P2P communication setups</li>
</ul>
<p>Binding must occur before the socket is connected. Attempting to bind after <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> will throw.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md863"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> socket(<span class="stringliteral">&quot;example.com&quot;</span>, 443);</div>
<div class="line">socket.bind(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 12345); <span class="comment">// Use fixed source port</span></div>
<div class="line">socket.connect();</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket has been bound to a local address/port, <span class="tt">false</span> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51" title="Binds the client socket to all interfaces using an ephemeral port.">bind()</a> </dd></dl>

</div>
</div>
<a id="gaeb5adb24bd7f50eaf8b52aa4441ffe71" name="gaeb5adb24bd7f50eaf8b52aa4441ffe71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5adb24bd7f50eaf8b52aa4441ffe71">&#9670;&#160;</a></span>isClosed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::ServerSocket::isClosed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the server socket has been closed. </p>
<p>This method returns <span class="tt">true</span> if the socket has been closed (and is no longer usable), or <span class="tt">false</span> if it is still open. The logic and naming follow the Java networking API for familiarity.</p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket has been closed, <span class="tt">false</span> if it is still open.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga4e3ff54722a55e7500fdd76f26c53dac" title="Check whether the server socket is currently open and valid.">isValid()</a>, <a class="el" href="#ga0245d40096ca089255c67303eebf17e6" title="Closes the server socket and releases its associated system resources.">close()</a> </dd></dl>

</div>
</div>
<a id="ga368ea24012b68fcf6db4f9a75d6d1940" name="ga368ea24012b68fcf6db4f9a75d6d1940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga368ea24012b68fcf6db4f9a75d6d1940">&#9670;&#160;</a></span>isClosed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::Socket::isClosed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports whether the socket has been closed or invalidated. </p>
<p>Returns <span class="tt">true</span> if the socket is no longer usable—either because it was explicitly closed, or because the underlying file descriptor has been released or never initialized.</p>
<p>This method does not perform any system-level check or probing. It simply inspects the internal socket descriptor (<span class="tt"><a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a></span>) and considers the socket closed if it is equal to <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>. This reflects the same mechanism used internally for error detection and safety throughout the library.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md977"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 443);</div>
<div class="line">assert(!sock.isClosed());</div>
<div class="line">sock.connect();</div>
<div class="line">sock.close(); <span class="comment">// assume you define a close() method</span></div>
<div class="line">assert(sock.isClosed()); <span class="comment">// true</span></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket is closed or uninitialized, <span class="tt">false</span> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Once closed, the socket cannot be reused or reopened. Create a new <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> instance instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2" title="Indicates whether the socket has been successfully connected to a remote host.">isConnected()</a> </dd>
<dd>
<a class="el" href="#gac5d9708cad057d6d608fb732eb1bb117" title="Indicates whether the socket has been explicitly bound to a local address and/or port.">isBound()</a> </dd></dl>

</div>
</div>
<a id="gab1e4f32614be9a3609820f75dbcb4fc2" name="gab1e4f32614be9a3609820f75dbcb4fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1e4f32614be9a3609820f75dbcb4fc2">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::Socket::isConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the socket has been successfully connected to a remote host. </p>
<p>Returns <span class="tt">true</span> if the socket has completed a successful connection attempt using <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span>. This reflects the internal connection state as tracked by the library—it does not actively probe the socket or verify that the connection is still alive at the network layer.</p>
<p>Use this method to check whether it is valid to perform send/receive operations. A socket transitions to the "connected" state only after a successful call to <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> with no subsequent errors or closures.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md864"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> socket(<span class="stringliteral">&quot;example.com&quot;</span>, 443);</div>
<div class="line">socket.connect();</div>
<div class="line"><span class="keywordflow">if</span> (socket.isConnected()) {</div>
<div class="line">    socket.send(...);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket is in the connected state, <span class="tt">false</span> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a> </dd></dl>

</div>
</div>
<a id="ga402fc4a398e670854cbb4edf791c1916" name="ga402fc4a398e670854cbb4edf791c1916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga402fc4a398e670854cbb4edf791c1916">&#9670;&#160;</a></span>isInputShutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::Socket::isInputShutdown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the socket's input stream has been shutdown. </p>
<p>Returns <span class="tt">true</span> if the socket has been explicitly shutdown for reading via <span class="tt">shutdown(ShutdownMode::Read)</span> or <span class="tt">shutdown(ShutdownMode::Both)</span>. After input shutdown:</p><ul>
<li>Any further read operations will return EOF or throw exceptions.</li>
<li>The socket cannot receive new data from the peer.</li>
</ul>
<p>This method tracks shutdown state internally—it does <b>not</b> query the operating system (as no portable API exists for that). It reflects the local state at the time of the last <span class="tt"><a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a></span> call on this socket.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md978"></a>
Use Cases</h3>
<ul>
<li>Preventing redundant or invalid read calls after a graceful shutdown.</li>
<li>Verifying application-level protocol state transitions.</li>
<li>Detecting half-closed connections during teardown.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the input (receive) side of the socket has been shutdown; <span class="tt">false</span> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a> </dd>
<dd>
<a class="el" href="#gad2b2992b358d3656a2e0d3e854c897bc" title="Checks whether the socket&#39;s output stream has been shutdown.">isOutputShutdown()</a> </dd>
<dd>
<a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2" title="Indicates whether the socket has been successfully connected to a remote host.">isConnected()</a> </dd>
<dd>
<a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a>, <a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a>, <a class="el" href="#ga46777f128a2a23cba8972aefd4b86828" title="Reads data from the socket until a specified delimiter character is encountered.">readUntil()</a> </dd></dl>

</div>
</div>
<a id="ga1717f9859e5aeeba77c3d463ec53e735" name="ga1717f9859e5aeeba77c3d463ec53e735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1717f9859e5aeeba77c3d463ec53e735">&#9670;&#160;</a></span>isListening()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::ServerSocket::isListening </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the server socket is currently listening for incoming connections. </p>
<p>Returns <span class="tt">true</span> if the socket has successfully entered the listening state by calling the <span class="tt"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a></span> method, and is ready to accept new client connections. Returns <span class="tt">false</span> otherwise.</p>
<p>This complements <span class="tt"><a class="el" href="#ga0b3a5cb732c669b678e03549e5af2427" title="Check if the server socket is bound to a local address.">isBound()</a></span>, which only tells you if the socket has been bound to a local address.</p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket is listening for connections, <span class="tt">false</span> otherwise. </dd></dl>

</div>
</div>
<a id="gad2b2992b358d3656a2e0d3e854c897bc" name="gad2b2992b358d3656a2e0d3e854c897bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2b2992b358d3656a2e0d3e854c897bc">&#9670;&#160;</a></span>isOutputShutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::Socket::isOutputShutdown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the socket's output stream has been shutdown. </p>
<p>Returns <span class="tt">true</span> if the socket has been explicitly shutdown for writing via <span class="tt">shutdown(ShutdownMode::Write)</span> or <span class="tt">shutdown(ShutdownMode::Both)</span>. After output shutdown:</p><ul>
<li>All subsequent write operations will fail with a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span>.</li>
<li>The system sends a FIN packet to the peer, indicating no more data will be sent.</li>
</ul>
<p>This method tracks shutdown state internally—it does <b>not</b> query the operating system, as no portable <span class="tt">getsockopt()</span> mechanism exists to detect output shutdown externally.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md979"></a>
Use Cases</h3>
<ul>
<li>Enforcing proper protocol shutdown (e.g. sending EOF before receiving response).</li>
<li>Avoiding invalid writes after intentionally shutting down output.</li>
<li>Debugging and verifying application-level connection state.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the output (send) side of the socket has been shutdown; <span class="tt">false</span> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a> </dd>
<dd>
<a class="el" href="#ga402fc4a398e670854cbb4edf791c1916" title="Checks whether the socket&#39;s input stream has been shutdown.">isInputShutdown()</a> </dd>
<dd>
<a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2" title="Indicates whether the socket has been successfully connected to a remote host.">isConnected()</a> </dd>
<dd>
<a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a>, <a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a>, <a class="el" href="#ga81f896d90e08fbfb1d63f1aabb21c970" title="Writes a length-prefixed payload using a fixed-size integral prefix.">writePrefixed()</a> </dd></dl>

</div>
</div>
<a id="ga4e3ff54722a55e7500fdd76f26c53dac" name="ga4e3ff54722a55e7500fdd76f26c53dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e3ff54722a55e7500fdd76f26c53dac">&#9670;&#160;</a></span>isValid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::ServerSocket::isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the server socket is currently open and valid. </p>
<p>This method determines if the server socket has been successfully created and is ready for binding, listening, or accepting connections. It checks whether the underlying socket handle is valid on the current platform.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Returns <span class="tt">true</span> if the server socket has been created and not yet closed.</li>
<li>Returns <span class="tt">false</span> if the socket has not been created, or has already been closed (and resources released).</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the server socket is open and valid; <span class="tt">false</span> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0245d40096ca089255c67303eebf17e6" title="Closes the server socket and releases its associated system resources.">close()</a>, <a class="el" href="#gaeb5adb24bd7f50eaf8b52aa4441ffe71" title="Check if the server socket has been closed.">isClosed()</a> </dd></dl>

</div>
</div>
<a id="gae2b10ef466023b380a34b062359c0f65" name="gae2b10ef466023b380a34b062359c0f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2b10ef466023b380a34b062359c0f65">&#9670;&#160;</a></span>isValid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::Socket::isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the socket is valid and open for communication. </p>
<p>This method checks if the socket has a valid file descriptor and is ready for communication. A socket is considered valid if it has been successfully created and has not been closed. However, a valid socket is not necessarily connected; use <a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2" title="Indicates whether the socket has been successfully connected to a remote host.">isConnected()</a> to check the connection status.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md972"></a>
Implementation Details</h3>
<ul>
<li>Checks if internal socket descriptor (<a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a>) is not INVALID_SOCKET</li>
<li>Fast, constant-time operation (O(1))</li>
<li>Thread-safe (const noexcept)</li>
<li>Does not perform any system calls</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md973"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line"><span class="keywordflow">if</span> (sock.isValid()) {</div>
<div class="line">    <span class="comment">// Socket is ready for connect()</span></div>
<div class="line">    sock.connect();</div>
<div class="line">}</div>
<div class="line">sock.close();</div>
<div class="line">assert(!sock.isValid()); <span class="comment">// Socket is now invalid</span></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>true if the socket is valid and ready for use, false if the socket has been closed or failed to initialize.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method only checks the socket's validity, not its connection state. A valid socket may or may not be connected to a remote host.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2" title="Indicates whether the socket has been successfully connected to a remote host.">isConnected()</a> Check if socket is actually connected </dd>
<dd>
<a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a> Invalidates the socket </dd></dl>

</div>
</div>
<a id="ga4780ea0cf2fb98d0081ed91d8dbecfa3" name="ga4780ea0cf2fb98d0081ed91d8dbecfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3">&#9670;&#160;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ServerSocket::listen </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>backlog</em></span><span class="paramdefsep"> = </span><span class="paramdefval">128</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests. </p>
<p>This method puts the server socket into listening mode, so it can accept incoming client connections using <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span>.</p>
<ul>
<li><b>How it works:</b> After binding the socket to a local address and port (via <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span>), call <span class="tt"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a></span> to have the operating system start queueing incoming connection requests. Only after calling <span class="tt"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a></span> can the server accept connections.</li>
<li><b>Backlog parameter:</b> The <span class="tt">backlog</span> argument specifies the maximum number of pending client connections that can be queued before connections are refused. If not specified, the system default (<span class="tt">SOMAXCONN</span>) is used.</li>
<li><b>Usage sequence:</b> Typical usage is: <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> sock(port); sock.bind(); sock.listen();</span></li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>You must call <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> before calling <span class="tt"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a></span>. If the socket is not bound, this call will fail.</li>
<li>The backlog parameter is a hint to the operating system. The actual queue length may be capped by system configuration (e.g., <span class="tt">/proc/sys/net/core/somaxconn</span> on Linux). On Windows, <span class="tt">SOMAXCONN</span> may be very large, so a smaller value (e.g., 128) is recommended for most applications.</li>
<li>On success, the socket is ready for calls to <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span>.</li>
<li>On error (e.g., socket not bound, invalid arguments, system resource exhaustion), a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown with details.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the listen operation fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> must be called successfully before this. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The server socket is now listening for incoming connections.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a>, <a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a>, ServerSocket(Port)</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a> server(8080);</div>
<div class="line">server.setReuseAddress(<span class="keyword">true</span>); <span class="comment">// Optional: set before bind</span></div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <a class="code hl_class" href="classjsocketpp_1_1Socket.html">jsocketpp::Socket</a> client = server.accept();</div>
<div class="line">    <span class="comment">// Handle client connection</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga82ef44f032a357bd470b4b756bdba37c" name="ga82ef44f032a357bd470b4b756bdba37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82ef44f032a357bd470b4b756bdba37c">&#9670;&#160;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> &amp; jsocketpp::ServerSocket::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator (deleted). </p>
<p><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> objects cannot be copied because they represent unique system resources. Each server socket needs exclusive ownership of its underlying file descriptor and associated resources. Use move semantics (<a class="el" href="#ga9fb02efd71b7800a17f7dc64214a8e4a" title="Move assignment operator for ServerSocket.">operator=(ServerSocket&amp;&amp;)</a>) instead to transfer ownership between <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> to copy from (unused since deleted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> (never returns since deleted)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This deletion enforces RAII principles and prevents resource leaks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga9fb02efd71b7800a17f7dc64214a8e4a" title="Move assignment operator for ServerSocket.">operator=(ServerSocket&amp;&amp;)</a> </dd>
<dd>
<a class="el" href="#gace3560ea1b99e15c1564e430e8848500" title="Move constructor that transfers ownership of server socket resources.">ServerSocket(ServerSocket&amp;&amp;)</a> </dd></dl>

</div>
</div>
<a id="ga9fb02efd71b7800a17f7dc64214a8e4a" name="ga9fb02efd71b7800a17f7dc64214a8e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fb02efd71b7800a17f7dc64214a8e4a">&#9670;&#160;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> &amp; jsocketpp::ServerSocket::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator for <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a>. </p>
<p>Transfers ownership of socket resources from another <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> object to this one. If this socket already owns resources, they are properly cleaned up before the transfer.</p>
<p>The operation is <b>noexcept</b> and provides the strong exception guarantee:</p><ul>
<li>If this socket already owns resources, they are closed before the transfer.</li>
<li>The moved-from socket is left in a valid but empty state (closed socket, null pointers).</li>
<li>No system resources are leaked during the transfer.</li>
</ul>
<p>After the move:</p><ul>
<li>This socket takes ownership of all resources from <span class="tt">rhs</span>.</li>
<li>The moved-from socket (<span class="tt">rhs</span>) becomes closed and can be safely destroyed.</li>
<li>All socket options, state flags, and configurations are transferred.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> to move resources from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> (containing the moved resources).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation is thread-safe with respect to the moved-from socket, but concurrent operations on either socket during the move may cause undefined behavior.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gace3560ea1b99e15c1564e430e8848500" title="Move constructor that transfers ownership of server socket resources.">ServerSocket(ServerSocket&amp;&amp;)</a> </dd>
<dd>
<a class="el" href="#ga0245d40096ca089255c67303eebf17e6" title="Closes the server socket and releases its associated system resources.">close()</a> </dd></dl>

</div>
</div>
<a id="ga4d2721350ef6a3cad7edf7b778d436c4" name="ga4d2721350ef6a3cad7edf7b778d436c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2721350ef6a3cad7edf7b778d436c4">&#9670;&#160;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> &amp; jsocketpp::Socket::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator (deleted) for <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> class. </p>
<p>This operator is explicitly deleted because <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> objects manage unique system resources (socket file descriptors) that cannot be safely duplicated. Each socket must have exclusive ownership of its underlying resources to prevent issues like:</p><ul>
<li>Double-closing of socket descriptors</li>
<li>Race conditions in multi-threaded code</li>
<li>Ambiguous ownership of system resources</li>
<li>Potential resource leaks</li>
</ul>
<p>Instead of copying, use move semantics (<a class="el" href="#ga05b1ae2ec76833370c809c53fe550a95" title="Move assignment operator that transfers socket ownership safely.">operator=(Socket&amp;&amp;)</a>) to transfer ownership of a <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> from one object to another. For example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> s1(<span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> s2(<span class="stringliteral">&quot;other.com&quot;</span>, 8080);</div>
<div class="line">s2 = std::move(s1); <span class="comment">// OK: moves ownership from s1 to s2</span></div>
<div class="line">s2 = s1;           <span class="comment">// Error: copying is disabled</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object to copy from (unused since deleted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> (never returns since deleted)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad0612bda82c378dbaf99e0839f5aa815" title="Move constructor that transfers ownership of socket resources.">Socket(Socket&amp;&amp;)</a> Move constructor for transferring socket ownership </dd>
<dd>
<a class="el" href="#ga05b1ae2ec76833370c809c53fe550a95" title="Move assignment operator that transfers socket ownership safely.">operator=(Socket&amp;&amp;)</a> Move assignment operator for transferring socket ownership </dd></dl>

</div>
</div>
<a id="ga05b1ae2ec76833370c809c53fe550a95" name="ga05b1ae2ec76833370c809c53fe550a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05b1ae2ec76833370c809c53fe550a95">&#9670;&#160;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> &amp; jsocketpp::Socket::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator that transfers socket ownership safely. </p>
<p>This operator safely transfers ownership of socket resources from another <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object while properly managing the current socket's resources. It ensures proper cleanup of existing resources before taking ownership of the new ones.</p>
<p>The operator performs these steps in order:</p><ol type="1">
<li>Checks for self-assignment to prevent resource corruption</li>
<li>Closes any existing socket connection</li>
<li>Frees existing address information resources</li>
<li>Takes ownership of all resources from the source socket</li>
<li>Resets the source socket to a valid but empty state</li>
</ol>
<p>After the move operation:</p><ul>
<li>This socket will own and manage all resources from the source</li>
<li>The source socket (rhs) will be left in a valid but disconnected state</li>
<li>All previous resources of this socket will be properly cleaned up</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The source <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> whose resources will be moved. After the move, rhs will be left in a valid but disconnected state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation is noexcept as it handles all cleanup internally and cannot throw exceptions. At worst, socket closure errors will be logged.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad0612bda82c378dbaf99e0839f5aa815" title="Move constructor that transfers ownership of socket resources.">Socket(Socket&amp;&amp;)</a> Move constructor </dd>
<dd>
<a class="el" href="#gaf5a4ddebfbca7bfe6c9a88462cc9ada8" title="Copy constructor (deleted) for Socket class.">Socket(const Socket&amp;)</a> Copy constructor (deleted) </dd>
<dd>
<a class="el" href="#ga4d2721350ef6a3cad7edf7b778d436c4" title="Copy assignment operator (deleted) for Socket class.">operator=(const Socket&amp;)</a> Copy assignment operator (deleted) </dd></dl>

</div>
</div>
<a id="ga5c413ef976df1e89528d9b3df6484c89" name="ga5c413ef976df1e89528d9b3df6484c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c413ef976df1e89528d9b3df6484c89">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::peek </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peeks at incoming data without consuming it. </p>
<p>This method performs a non-destructive read of up to <span class="tt">n</span> bytes using the <span class="tt">MSG_PEEK</span> flag. It allows inspecting the contents of the socket's receive buffer without removing the data from the queue. This is useful for implementing lookahead parsing, protocol sniffing, or waiting for specific patterns before consuming data.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md936"></a>
Implementation Details</h3>
<ul>
<li>Performs a single <span class="tt">recv()</span> call with <span class="tt">MSG_PEEK</span></li>
<li>Does not remove any bytes from the socket buffer</li>
<li>May return fewer bytes than requested if less data is available</li>
<li>Does not block indefinitely if the socket is non-blocking or has a timeout</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md937"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::string preview = sock.peek(4);</div>
<div class="line"><span class="keywordflow">if</span> (preview == <span class="stringliteral">&quot;PING&quot;</span>) {</div>
<div class="line">    std::string full = sock.readExact(4);</div>
<div class="line">    handlePing(full);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Maximum number of bytes to peek at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing up to <span class="tt">n</span> bytes from the receive buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid</li>
<li>recv() fails</li>
<li>Connection is closed unexpectedly</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you want to discard data after peeking, use <span class="tt"><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a></span> or <span class="tt"><a class="el" href="#ga7492730c56e0bf5a4c67227df7bc4033" title="Discards exactly n bytes from the socket by reading and discarding them.">discard()</a></span> afterward.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a> To consume data after <a class="el" href="#ga5c413ef976df1e89528d9b3df6484c89" title="Peeks at incoming data without consuming it.">peek</a> </dd>
<dd>
<a class="el" href="#ga7a2c489a21a8b2f17bda4e70a296ad52" title="Reads all bytes currently available on the socket without blocking.">readAvailable()</a> For full-buffer inspection and consumption </dd>
<dd>
<a class="el" href="#ga7492730c56e0bf5a4c67227df7bc4033" title="Discards exactly n bytes from the socket by reading and discarding them.">discard()</a> To remove bytes without copying them (future) </dd></dl>

</div>
</div>
<a id="ga634bfa30476b72bfa4cca63a93c558a9" name="ga634bfa30476b72bfa4cca63a93c558a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga634bfa30476b72bfa4cca63a93c558a9">&#9670;&#160;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string jsocketpp::Socket::read </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <span class="tt"><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a>&lt;T&gt;()</span> for reading a single buffer of string data. </p>
<p>Reads a variable-length block of data from the socket into the internal receive buffer and returns it as a <span class="tt">std::string</span>. This specialization provides optimized handling for raw or text-based data streams where the amount of available data is not known in advance.</p>
<p>Unlike <span class="tt"><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a>&lt;T&gt;()</span>, which reads a fixed number of bytes based on the type, this method reads up to the size of the internal buffer and returns whatever data is available, making it ideal for use cases where the protocol layer or application logic defines variable-sized records or streams.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md844"></a>
Key Features</h3>
<ul>
<li>Uses <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html#a05964f49b3ce4b2d9f2413fd40d4d174" title="Internal buffer for read operations, not thread-safe.">_internalBuffer</a></span> for efficient chunked <span class="tt">recv()</span> operations</li>
<li>Preserves binary data (e.g. embedded null bytes)</li>
<li>Returns actual number of bytes received (may be less than buffer size)</li>
<li>Non-blocking if data is already available (subject to socket timeout)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md845"></a>
Implementation Details</h3>
<ol type="1">
<li>Uses <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html#a05964f49b3ce4b2d9f2413fd40d4d174" title="Internal buffer for read operations, not thread-safe.">_internalBuffer</a></span> sized via <span class="tt"><a class="el" href="#ga3fb196157a1cde167c47a596c9235c91" title="Sets the size of the internal read buffer used for string operations.">setInternalBufferSize()</a></span></li>
<li>Performs a single <span class="tt">recv()</span> call up to the buffer size</li>
<li>Returns a <span class="tt">std::string</span> containing only the received portion</li>
<li>Internal buffer is reused across calls and not resized dynamically</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md846"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Default buffer size (see @ref DefaultBufferSize)</span></div>
<div class="line">std::string data = sock.read&lt;std::string&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Increase buffer size for larger payloads</span></div>
<div class="line">sock.setInternalBufferSize(4096);</div>
<div class="line">std::string chunk = sock.read&lt;std::string&gt;();</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A <span class="tt">std::string</span> containing up to <span class="tt">internalBufferSize</span> bytes of received data. The length reflects the actual bytes read from the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is closed (<span class="tt">recv() == 0</span>)</li>
<li>A network error occurs (<span class="tt">recv() == <a class="el" href="namespacejsocketpp.html#adc2dd9860dec2a3c3189e756288d5ba2">SOCKET_ERROR</a></span>)</li>
<li>The socket is in an invalid state or not connected</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This specialization differs from the generic <span class="tt"><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a>&lt;T&gt;()</span>:<ul>
<li>It supports reading variable-length data</li>
<li>It does not attempt to construct a specific object type</li>
<li>It is suitable for stream-based protocols, logging, or framed text</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> Generic fixed-size reader for POD types </dd>
<dd>
<a class="el" href="#ga3fb196157a1cde167c47a596c9235c91" title="Sets the size of the internal read buffer used for string operations.">setInternalBufferSize()</a> To control the <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a> buffer size </dd>
<dd>
<a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a> For sending text or binary data </dd>
<dd>
<a class="el" href="#ga46777f128a2a23cba8972aefd4b86828" title="Reads data from the socket until a specified delimiter character is encountered.">readUntil()</a> For delimiter-based stream parsing </dd></dl>

</div>
</div>
<a id="gaa7498d51b547b52699055bdb16b9d68b" name="gaa7498d51b547b52699055bdb16b9d68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7498d51b547b52699055bdb16b9d68b">&#9670;&#160;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T jsocketpp::Socket::read </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a fixed-size, trivially copyable object of type <span class="tt">T</span> from the socket. </p>
<p>Performs a binary-safe read of exactly <span class="tt">sizeof(T)</span> bytes from the socket and constructs an instance of <span class="tt">T</span> from the received data. This method is optimized for reading primitive types and Plain Old Data (POD) structures directly from a binary stream, without any decoding or parsing overhead.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md902"></a>
Implementation Details</h3>
<ul>
<li>Allocates a temporary buffer of <span class="tt">sizeof(T)</span> bytes</li>
<li>Loops on <span class="tt">recv()</span> until all bytes are received (handles partial reads)</li>
<li>Copies the buffer into a <span class="tt">std::array&lt;std::byte, sizeof(T)&gt;</span> and performs a <span class="tt">std::bit_cast</span></li>
<li>Enforces type constraint: <span class="tt">std::is_trivially_copyable_v&lt;T&gt;</span> and <span class="tt">std::is_standard_layout_v&lt;T&gt;</span></li>
<li>Performs <b>no</b> byte order conversion, alignment, or field normalization</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md903"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 9000);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> count = sock.read&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line"><span class="keywordtype">double</span> ratio = sock.read&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Header {</div>
<div class="line">    uint32_t id;</div>
<div class="line">    uint16_t flags;</div>
<div class="line">    <span class="keywordtype">char</span> tag[16];</div>
<div class="line">};</div>
<div class="line">Header h = sock.read&lt;Header&gt;();</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md904"></a>
Supported Types</h3>
<ul>
<li>Scalar types: <span class="tt">int</span>, <span class="tt">float</span>, <span class="tt">double</span>, etc.</li>
<li>POD structs and unions</li>
<li>Raw byte arrays or <span class="tt">std::array&lt;T, N&gt;</span></li>
<li>Any type that satisfies <span class="tt">std::is_trivially_copyable</span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md905"></a>
Limitations</h3>
<ul>
<li>❌ No pointer-based fields</li>
<li>❌ No virtual methods or dynamic memory</li>
<li>❌ No platform-dependent padding or ABI assumptions</li>
<li>❌ No endianness conversion (use utility functions to normalize fields)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md906"></a>
Thread Safety</h3>
<ul>
<li>❌ Not thread-safe: do not call concurrently on the same <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> instance</li>
<li>✅ Use separate <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> objects per thread, or synchronize externally</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A trivially copyable type to read from the socket. This is enforced at compile time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully initialized instance of type <span class="tt">T</span> with raw data populated from the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is closed before the full <span class="tt">sizeof(T)</span> bytes are read</li>
<li>A network error occurs (e.g., <span class="tt">ECONNRESET</span>, <span class="tt">EPIPE</span>, <span class="tt">ETIMEDOUT</span>)</li>
<li>The socket is invalid, unconnected, or interrupted</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Byte Order: No endianness normalization is applied. You must manually convert fields using utilities like <span class="tt">fromNetwork()</span> or <span class="tt">ntohl()</span> if reading cross-platform data.</dd>
<dd>
Memory Safety: Do not use this method with types containing pointers, virtual tables, custom allocators, or layout-dependent structures. Misuse may result in undefined behavior, security vulnerabilities, or memory corruption.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method allocates a temporary buffer for each call. It does not use or affect the internal string buffer used by methods like <span class="tt"><a class="el" href="#ga46777f128a2a23cba8972aefd4b86828" title="Reads data from the socket until a specified delimiter character is encountered.">readUntil()</a></span>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a> For writing fixed-size objects to the socket </dd>
<dd>
<a class="el" href="#gab1aaaa6572bcf756be7bcdb801e35812" title="Reads a length-prefixed payload using a fixed-size prefix type.">readPrefixed()</a> For reading length-prefixed dynamic types </dd>
<dd>
<a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a> To configure <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a> timeout behavior </dd>
<dd>
<a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2" title="Indicates whether the socket has been successfully connected to a remote host.">isConnected()</a> To check whether the socket is currently usable </dd></dl>

</div>
</div>
<a id="ga7c3a39505b6c65a9c4db03c081cd4de7" name="ga7c3a39505b6c65a9c4db03c081cd4de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c3a39505b6c65a9c4db03c081cd4de7">&#9670;&#160;</a></span>readAtMost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::readAtMost </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a single best-effort read of up to <span class="tt">n</span> bytes from the socket. </p>
<p>This method attempts to read up to <span class="tt">n</span> bytes from the socket using a single <span class="tt">recv()</span> call. It is designed for responsiveness: it returns as soon as any data is available—whether that's the full <span class="tt">n</span> bytes, fewer bytes, or even zero if the connection was closed.</p>
<p>This is a low-overhead, non-looping read ideal for event-driven designs, polling, or non-blocking sockets. It differs from <span class="tt"><a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a></span> in that it does not retry or wait for the full amount of data.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md912"></a>
Implementation Details</h3>
<ul>
<li>Calls <span class="tt">recv()</span> exactly once with a preallocated buffer</li>
<li>Returns available data immediately (up to <span class="tt">n</span> bytes)</li>
<li>Resizes the result to the actual number of bytes read</li>
<li>Throws on socket errors or if the connection is closed</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md913"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Try to read up to 512 bytes</span></div>
<div class="line">std::string chunk = sock.readAtMost(512);</div>
<div class="line"><span class="keywordflow">if</span> (!chunk.empty()) {</div>
<div class="line">    process(chunk);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Maximum number of bytes to read in one call. Must be greater than 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt">std::string</span> containing 0 to <span class="tt">n</span> bytes of data. An empty string means the connection was closed or nothing was available (e.g., non-blocking mode).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid, disconnected, or closed (<span class="tt">EBADF</span>, <span class="tt">ENOTCONN</span>, etc.)</li>
<li>A network error occurs during the <span class="tt">recv()</span> operation</li>
<li>The connection was closed by the peer (<span class="tt">recv()</span> returned 0)</li>
<li>Memory allocation fails during buffer allocation</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlike <span class="tt"><a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a></span>, this method does not retry or loop. Use with care in protocols that depend on strict byte counts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a> For guaranteed-length blocking reads </dd>
<dd>
<a class="el" href="#ga46777f128a2a23cba8972aefd4b86828" title="Reads data from the socket until a specified delimiter character is encountered.">readUntil()</a> For delimiter-based parsing </dd>
<dd>
<a class="el" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a> To configure socket non-blocking behavior </dd>
<dd>
<a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a> To configure <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a> timeout </dd></dl>

</div>
</div>
<a id="ga3b61b5861d62f4e85be4a52aa9e0bcc9" name="ga3b61b5861d62f4e85be4a52aa9e0bcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b61b5861d62f4e85be4a52aa9e0bcc9">&#9670;&#160;</a></span>readAtMostWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::readAtMostWithTimeout </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts a best-effort read of up to <span class="tt">n</span> bytes with a timeout constraint. </p>
<p>Waits for the socket to become readable for up to <span class="tt">timeoutMillis</span> milliseconds, then performs a single <span class="tt">recv()</span> call to read up to <span class="tt">n</span> bytes of available data. This method is useful for polling-style or time-sensitive I/O operations where immediate responsiveness is more important than full data delivery.</p>
<p>Unlike <span class="tt"><a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a></span>, this method does not loop or retry to satisfy the full size. It returns as soon as data is available, or throws a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> if no data arrives within the specified timeout window.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md918"></a>
Implementation Details</h3>
<ul>
<li>Calls <span class="tt">waitReady(false)</span> to wait for data readiness</li>
<li>Performs a single <span class="tt">recv()</span> once readable</li>
<li>Returns the available data immediately (may be fewer than <span class="tt">n</span> bytes)</li>
<li>Throws on timeout, disconnection, or error</li>
<li>Returned string is resized to match actual data length</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md919"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// Try to read up to 1024 bytes with a 5-second timeout</span></div>
<div class="line">    std::string data = sock.readAtMostWithTimeout(1024, 5000);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Read &quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot; bytes\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketTimeoutException.html">SocketTimeoutException</a>&amp; timeoutEx) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Timeout: &quot;</span> &lt;&lt; timeoutEx.what() &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> SocketException&amp; ex) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Socket error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Maximum number of bytes to read in one operation. Must be &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Maximum duration to wait for readability, in milliseconds:<ul>
<li><span class="tt">&gt; 0</span>: Wait up to this time</li>
<li><span class="tt">0</span>: Poll without blocking</li>
<li><span class="tt">&lt; 0</span>: Invalid; throws <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt">std::string</span> containing between 1 and <span class="tt">n</span> bytes of data received.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If the socket remains unreadable beyond <span class="tt">timeoutMillis</span>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid or closed</li>
<li>The peer disconnects (<span class="tt">recv() == 0</span>)</li>
<li>A network/system error occurs during <span class="tt">recv()</span></li>
<li>Memory allocation fails</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is ideal for polling and timeout-aware reads where partial delivery is acceptable. For guaranteed reads, use <span class="tt"><a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a></span>. For immediate best-effort reads without timeout, use <span class="tt"><a class="el" href="#ga7c3a39505b6c65a9c4db03c081cd4de7" title="Performs a single best-effort read of up to n bytes from the socket.">readAtMost()</a></span>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a> For guaranteed full-length reads </dd>
<dd>
<a class="el" href="#ga7c3a39505b6c65a9c4db03c081cd4de7" title="Performs a single best-effort read of up to n bytes from the socket.">readAtMost()</a> For best-effort reads without blocking </dd>
<dd>
<a class="el" href="#ga6b39b1375048cc167409b5b513c3ad8c" title="Waits for the socket to become ready for reading or writing.">waitReady()</a> To wait for readiness explicitly </dd>
<dd>
<a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a> To set socket-level timeout defaults </dd></dl>

</div>
</div>
<a id="ga7a2c489a21a8b2f17bda4e70a296ad52" name="ga7a2c489a21a8b2f17bda4e70a296ad52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a2c489a21a8b2f17bda4e70a296ad52">&#9670;&#160;</a></span>readAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::readAvailable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all bytes currently available on the socket without blocking. </p>
<p>Performs a best-effort, non-blocking read of all data that is already available in the socket's input buffer. This method uses platform-specific mechanisms (e.g., FIONREAD or ioctl) to query how many bytes can be read without blocking, then performs a single <span class="tt">recv()</span> call to consume and return that data.</p>
<p>This method is useful in event-driven or polling-based systems where you want to quickly drain the socket buffer without waiting for more data to arrive.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md926"></a>
Implementation Details</h3>
<ul>
<li>Uses ioctl (or ioctlsocket on Windows) with FIONREAD to determine readable bytes</li>
<li>If no data is available, returns an empty string immediately</li>
<li>Performs one recv() call up to the number of available bytes</li>
<li>Avoids dynamic memory allocation if no data is available</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md927"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 1234);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (sock.isConnected()) {</div>
<div class="line">    std::string data = sock.readAvailable();</div>
<div class="line">    <span class="keywordflow">if</span> (!data.empty()) {</div>
<div class="line">        handleChunk(data);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A string containing 0 or more bytes, depending on what was available at the time.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>ioctl/FIONREAD fails</li>
<li>recv() fails due to network error</li>
<li>Connection is closed unexpectedly</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method does not wait or retry. If you want timeout-based behavior, use <a class="el" href="#ga3b61b5861d62f4e85be4a52aa9e0bcc9" title="Attempts a best-effort read of up to n bytes with a timeout constraint.">readAtMostWithTimeout()</a> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3b61b5861d62f4e85be4a52aa9e0bcc9" title="Attempts a best-effort read of up to n bytes with a timeout constraint.">readAtMostWithTimeout()</a> For time-bounded partial reads </dd>
<dd>
<a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> For fixed-size reads </dd>
<dd>
<a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a> For guaranteed-length reads </dd>
<dd>
<a class="el" href="#ga6b39b1375048cc167409b5b513c3ad8c" title="Waits for the socket to become ready for reading or writing.">waitReady()</a> To wait for socket readiness before calling this </dd></dl>

</div>
</div>
<a id="ga3d194596258a3b1117b3437d969019b6" name="ga3d194596258a3b1117b3437d969019b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d194596258a3b1117b3437d969019b6">&#9670;&#160;</a></span>readExact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::readExact </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads exactly <span class="tt">n</span> bytes from the socket into a <span class="tt">std::string</span>. </p>
<p>Performs a fully blocking read that continues reading from the socket until the specified number of bytes (<span class="tt">n</span>) has been received, or an error or disconnection occurs. This method guarantees exact-length delivery and is suitable for fixed-length binary protocols or framed data.</p>
<p>Internally, it repeatedly calls <span class="tt">recv()</span> as needed to handle partial reads. It allocates a string of size <span class="tt">n</span> and fills it directly with received data in order, preserving byte order and content integrity.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md907"></a>
Implementation Details</h3>
<ul>
<li>Uses a loop around <span class="tt">recv()</span> to read remaining bytes</li>
<li>Handles short reads and interruptions transparently</li>
<li>Allocates result string up front (no resizing or reallocation)</li>
<li>Does <b>not</b> interpret content — binary-safe and endian-agnostic</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md908"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// Read an exact-length header</span></div>
<div class="line">    std::string header = sock.readExact(16);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read an entire frame of known size</span></div>
<div class="line">    std::string frame = sock.readExact(1024);</div>
<div class="line">    assert(frame.size() == 1024);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>&amp; ex) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Read failed: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of bytes to read. Must be greater than zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt">std::string</span> containing exactly <span class="tt">n</span> bytes of data received from the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The peer closes the connection before <span class="tt">n</span> bytes are received</li>
<li>A read timeout occurs (e.g. <span class="tt">ETIMEDOUT</span>)</li>
<li>A network error or signal interruption occurs</li>
<li>The socket is invalid or unconnected (e.g. <span class="tt">EBADF</span>)</li>
<li>Memory allocation fails (<span class="tt">std::bad_alloc</span>)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method blocks until all <span class="tt">n</span> bytes are read or an error occurs. It is not suitable for variable-length or streaming reads. </dd>
<dd>
This method returns an empty string if n == 0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read&lt;std::string&gt;()</a> For best-effort, buffered reads </dd>
<dd>
<a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read&lt;T&gt;()</a> For fixed-size reads of trivially copyable types </dd>
<dd>
<a class="el" href="#ga46777f128a2a23cba8972aefd4b86828" title="Reads data from the socket until a specified delimiter character is encountered.">readUntil()</a> For delimiter-based reads (e.g. lines or tokens) </dd>
<dd>
<a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a> To configure blocking behavior </dd></dl>

</div>
</div>
<a id="gac2bfca99305ede78697fc0b39fbbeed8" name="gac2bfca99305ede78697fc0b39fbbeed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2bfca99305ede78697fc0b39fbbeed8">&#9670;&#160;</a></span>readInto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::Socket::readInto </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads available data from the socket into the provided buffer. </p>
<p>Performs a "best-effort" read operation by attempting to read up to len bytes from the socket into the provided buffer. This method makes a single recv() call and returns immediately with whatever data is available, which may be less than the requested length.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md914"></a>
Implementation Details</h3>
<ul>
<li>Uses recv() internally with a single call</li>
<li>Returns immediately with available data</li>
<li>Does not guarantee full buffer will be filled</li>
<li>Non-blocking mode affects behavior</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md915"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> buffer[1024];</div>
<div class="line"><span class="keywordtype">size_t</span> bytesRead = sock.readInto(buffer, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"><span class="keywordflow">if</span> (bytesRead &gt; 0) {</div>
<div class="line">    <span class="comment">// Process bytesRead bytes from buffer</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to pre-allocated memory buffer to store read data. Must be valid and large enough for len bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes to read (buffer size)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually read (may be less than len)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is invalid (EBADF)</li>
<li>Connection closed by peer</li>
<li>Memory access error (EFAULT)</li>
<li>Network errors occur</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gabb8631cb8242b3573a2679da0b6a4f4d" title="Reads exactly len bytes into the given buffer (looped recv).">readIntoExact()</a> For guaranteed full-length reads </dd>
<dd>
<a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> Template method for type-safe reads </dd>
<dd>
<a class="el" href="#ga46777f128a2a23cba8972aefd4b86828" title="Reads data from the socket until a specified delimiter character is encountered.">readUntil()</a> For delimiter-based reading </dd></dl>

</div>
</div>
<a id="gac12a8c2c7d3f5e90f58a7f2584bf11aa" name="gac12a8c2c7d3f5e90f58a7f2584bf11aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac12a8c2c7d3f5e90f58a7f2584bf11aa">&#9670;&#160;</a></span>readIntoAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::readIntoAvailable </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all currently available bytes into the provided buffer without blocking. </p>
<p>This method checks how many bytes are available for reading on the socket using platform-specific ioctl/FIONREAD mechanisms, and reads as many bytes as possible (up to the specified buffer size) into the provided memory buffer. It does not block or wait for additional data to arrive.</p>
<p>This is the low-level, zero-copy variant of <a class="el" href="#ga7a2c489a21a8b2f17bda4e70a296ad52" title="Reads all bytes currently available on the socket without blocking.">readAvailable()</a>, ideal for high-performance applications and protocol parsers that manage their own memory buffers.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md928"></a>
Implementation Details</h3>
<ul>
<li>Uses FIONREAD (Windows or POSIX) to determine available bytes</li>
<li>Performs one recv() call into <span class="tt">buffer</span> for min(bufferSize, available)</li>
<li>Returns number of bytes read</li>
<li>Does nothing if no data is available</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md929"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> buf[2048];</div>
<div class="line">std::size_t received = sock.readIntoAvailable(buf, <span class="keyword">sizeof</span>(buf));</div>
<div class="line"><span class="keywordflow">if</span> (received &gt; 0) {</div>
<div class="line">    parse(buf, received);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to the memory where received data will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Maximum number of bytes to store in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read (may be 0 if no data is available).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is invalid</li>
<li>ioctl/FIONREAD fails</li>
<li>recv() fails</li>
<li>Connection is closed during read</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method does not allocate memory and is safe to call frequently. For a string-returning variant, use <a class="el" href="#ga7a2c489a21a8b2f17bda4e70a296ad52" title="Reads all bytes currently available on the socket without blocking.">readAvailable()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7a2c489a21a8b2f17bda4e70a296ad52" title="Reads all bytes currently available on the socket without blocking.">readAvailable()</a> For dynamic buffer version </dd>
<dd>
<a class="el" href="#ga3b61b5861d62f4e85be4a52aa9e0bcc9" title="Attempts a best-effort read of up to n bytes with a timeout constraint.">readAtMostWithTimeout()</a> For time-limited reads </dd>
<dd>
<a class="el" href="#gac2bfca99305ede78697fc0b39fbbeed8" title="Reads available data from the socket into the provided buffer.">readInto()</a> For controlled-length reading (blocking) </dd></dl>

</div>
</div>
<a id="gabb8631cb8242b3573a2679da0b6a4f4d" name="gabb8631cb8242b3573a2679da0b6a4f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb8631cb8242b3573a2679da0b6a4f4d">&#9670;&#160;</a></span>readIntoExact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::Socket::readIntoExact </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads exactly <span class="tt">len</span> bytes into the given buffer (looped recv). </p>
<p>This method guarantees to read exactly the specified number of bytes from the socket into the provided buffer. It will continue reading until either all requested bytes are received or an error occurs. This is useful when reading fixed-length protocol messages or binary data structures where partial reads are not acceptable.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md916"></a>
Implementation Details</h3>
<ul>
<li>Uses <a class="el" href="#ga756c4e2148cfe7974fe191099341fccf" title="Reads data from the socket into a user-supplied buffer.">readIntoInternal()</a> with exact=true</li>
<li>Loops until all requested bytes are read</li>
<li>Handles partial reads internally</li>
<li>Throws if connection closes before all bytes received</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md917"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read a fixed-size header</span></div>
<div class="line"><span class="keyword">struct </span>Header {</div>
<div class="line">    uint32_t messageType;</div>
<div class="line">    uint32_t payloadLength;</div>
<div class="line">};</div>
<div class="line">Header header;</div>
<div class="line">sock.readIntoExact(&amp;header, <span class="keyword">sizeof</span>(header));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read exact payload length</span></div>
<div class="line">std::vector&lt;char&gt; payload(header.payloadLength);</div>
<div class="line">sock.readIntoExact(payload.data(), payload.size());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to pre-allocated memory where data should be written. Must be valid and large enough for len bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to read. Method won't return until exactly this many bytes are read or an error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually read (always equal to len on success)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>Connection closes before len bytes received</li>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> error occurs during read</li>
<li>Memory access error (EFAULT)</li>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is invalid or not connected</li>
<li>Timeout occurs (if configured)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac2bfca99305ede78697fc0b39fbbeed8" title="Reads available data from the socket into the provided buffer.">readInto()</a> For "best-effort" reads that may return partial data </dd>
<dd>
<a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> Template method for type-safe reads </dd>
<dd>
<a class="el" href="#ga756c4e2148cfe7974fe191099341fccf" title="Reads data from the socket into a user-supplied buffer.">readIntoInternal()</a> Internal implementation </dd></dl>

</div>
</div>
<a id="ga756c4e2148cfe7974fe191099341fccf" name="ga756c4e2148cfe7974fe191099341fccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756c4e2148cfe7974fe191099341fccf">&#9670;&#160;</a></span>readIntoInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::readIntoInternal </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>exact</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from the socket into a user-supplied buffer. </p>
<p>This method provides direct access to the socket's receive functionality by reading data into a caller-provided buffer. It supports both "best-effort" single reads and exact-length reads that ensure all requested bytes are received.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md980"></a>
Modes of Operation</h3>
<ul>
<li><b>Best-effort mode</b> (exact=false):<ul>
<li>Performs single recv() call</li>
<li>Returns immediately with available data</li>
<li>May return fewer bytes than requested</li>
<li>Suitable for stream processing</li>
</ul>
</li>
<li><b>Exact mode</b> (exact=true):<ul>
<li>Guarantees all requested bytes are read</li>
<li>Loops until full length received</li>
<li>Throws if connection closes early</li>
<li>Good for protocol messages</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md981"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Best-effort read</span></div>
<div class="line"><span class="keywordtype">char</span> buf[1024];</div>
<div class="line"><span class="keywordtype">size_t</span> got = sock.readInto(buf, <span class="keyword">sizeof</span>(buf), <span class="keyword">false</span>);</div>
<div class="line"><span class="comment">// got may be less than 1024</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Exact read</span></div>
<div class="line">uint32_t length;</div>
<div class="line">sock.readInto(&amp;length, <span class="keyword">sizeof</span>(length), <span class="keyword">true</span>);</div>
<div class="line"><span class="comment">// Always reads exactly 4 bytes or throws</span></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md982"></a>
Implementation Details</h3>
<ul>
<li>Uses recv() internally for actual reads</li>
<li>Handles partial reads in exact mode</li>
<li>Buffer bounds checking</li>
<li>Platform-independent behavior</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to caller-allocated memory buffer Must be valid and large enough for len bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes to read (buffer size) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exact</td><td>If true, method won't return until len bytes are read or an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes actually read:<ul>
<li>exact=false: 0 to len bytes</li>
<li>exact=true: Always len bytes or throws</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is invalid (EBADF)</li>
<li>Connection closed by peer</li>
<li>Memory access error (EFAULT)</li>
<li>Timeout occurs (EAGAIN)</li>
<li>Other network errors</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> Template method for type-safe reads </dd>
<dd>
<a class="el" href="#ga46777f128a2a23cba8972aefd4b86828" title="Reads data from the socket until a specified delimiter character is encountered.">readUntil()</a> For delimiter-based reading </dd>
<dd>
<a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a> For string-based exact reads </dd></dl>

</div>
</div>
<a id="ga21767c46469a8cee88a87f45405d36fd" name="ga21767c46469a8cee88a87f45405d36fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21767c46469a8cee88a87f45405d36fd">&#9670;&#160;</a></span>readLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string jsocketpp::Socket::readLine </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>maxLen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">8192</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>includeDelimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a line terminated by '<br  />
' from the socket. </p>
<p>This is a convenience method that calls readUntil('<br  />
', maxLen, includeDelimiter). It provides backward compatibility and a more intuitive interface for reading newline-terminated data.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md911"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read a line terminated by newline</span></div>
<div class="line">std::string line = sock.readLine();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read without including the newline</span></div>
<div class="line">std::string data = sock.readLine(8192, <span class="keyword">false</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxLen</td><td>Maximum number of bytes to read (default: 8192) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeDelimiter</td><td>Whether to include the newline in the returned string (default: true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string containing the line read </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>on error or if line exceeds maxLen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga46777f128a2a23cba8972aefd4b86828" title="Reads data from the socket until a specified delimiter character is encountered.">readUntil()</a> The underlying implementation </dd>
<dd>
<a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> For general-purpose reading </dd>
<dd>
<a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a> For fixed-length reads </dd></dl>

</div>
</div>
<a id="gab1aaaa6572bcf756be7bcdb801e35812" name="gab1aaaa6572bcf756be7bcdb801e35812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1aaaa6572bcf756be7bcdb801e35812">&#9670;&#160;</a></span>readPrefixed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string jsocketpp::Socket::readPrefixed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a length-prefixed payload using a fixed-size prefix type. </p>
<p>Reads a message that consists of a length prefix followed by a variable-length payload. The prefix type <span class="tt">T</span> determines the format and size of the length field. This method is useful for protocols that encode message length as a fixed-size integer header.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md920"></a>
Implementation Details</h3>
<ul>
<li>First reads <span class="tt">sizeof(T)</span> bytes as the length prefix</li>
<li>Converts the prefix from <b>network byte order</b> to <b>host byte order</b> using <span class="tt"><a class="el" href="namespacejsocketpp_1_1net.html#adbc3d8ebcf4347173f61e55e236c8b37" title="Converts a 16-bit unsigned integer from network to host byte order.">net::fromNetwork()</a></span></li>
<li>Then reads exactly that many bytes as the payload</li>
<li>Length prefix must be a trivially copyable unsigned integral type (e.g., <span class="tt">uint16_t</span>, <span class="tt">uint32_t</span>)</li>
<li>Payload is returned as a <span class="tt">std::string</span> (binary-safe)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md921"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// Read message with 32-bit length prefix</span></div>
<div class="line">    std::string msg = sock.readPrefixed&lt;uint32_t&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read message with 16-bit length prefix</span></div>
<div class="line">    std::string shortMsg = sock.readPrefixed&lt;uint16_t&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read multiple length-prefixed messages</span></div>
<div class="line">    <span class="keywordflow">while</span> (sock.isConnected()) {</div>
<div class="line">        std::string data = sock.readPrefixed&lt;uint32_t&gt;();</div>
<div class="line">        process(data);</div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> SocketException&amp; ex) {</div>
<div class="line">    <span class="comment">// Handle read errors</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md922"></a>
Protocol Format</h3>
<pre>
+----------------+----------------------+
| Length (T)     | Payload (n bytes)   |
+----------------+----------------------+
|&lt;- sizeof(T) -&gt;|&lt;---- length -------&gt;|
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unsigned integral type used for the length prefix (e.g., <span class="tt">uint32_t</span>). Must be a trivially copyable type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The payload as a <span class="tt">std::string</span>, excluding the length prefix.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>Connection is closed while reading</li>
<li>Length prefix is invalid/corrupt</li>
<li>Not enough data is available to complete the read</li>
<li>Memory allocation fails</li>
<li>Any network error occurs</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The prefix is assumed to be encoded in <b>network byte order</b> and is converted automatically to host byte order using <span class="tt"><a class="el" href="namespacejsocketpp_1_1net.html#adbc3d8ebcf4347173f61e55e236c8b37" title="Converts a 16-bit unsigned integer from network to host byte order.">jsocketpp::net::fromNetwork()</a></span>. You must ensure that the sender uses the same byte ordering.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> For reading raw fixed-size values </dd>
<dd>
<a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a> For reading an exact number of bytes </dd>
<dd>
<a class="el" href="#ga81f896d90e08fbfb1d63f1aabb21c970" title="Writes a length-prefixed payload using a fixed-size integral prefix.">writePrefixed()</a> To send matching length-prefixed data </dd>
<dd>
<a class="el" href="namespacejsocketpp_1_1net.html#adbc3d8ebcf4347173f61e55e236c8b37" title="Converts a 16-bit unsigned integer from network to host byte order.">net::fromNetwork()</a> For details on byte order conversion </dd></dl>

</div>
</div>
<a id="gac504258fb38abd34abee4ea96868a9d2" name="gac504258fb38abd34abee4ea96868a9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac504258fb38abd34abee4ea96868a9d2">&#9670;&#160;</a></span>readPrefixed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string jsocketpp::Socket::readPrefixed </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>maxPayloadLen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a length-prefixed message with an upper bound check. </p>
<p>Reads a message that consists of a length prefix followed by a variable-length payload. This overload adds protection by validating that the decoded length does not exceed a specified maximum (<span class="tt">maxPayloadLen</span>), helping prevent corrupted or maliciously large payloads.</p>
<p>The prefix type <span class="tt">T</span> determines the format and size of the length field and is decoded in <b>network byte order</b> using <span class="tt"><a class="el" href="namespacejsocketpp_1_1net.html#adbc3d8ebcf4347173f61e55e236c8b37" title="Converts a 16-bit unsigned integer from network to host byte order.">net::fromNetwork()</a></span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md923"></a>
Implementation Details</h3>
<ul>
<li>Reads <span class="tt">sizeof(T)</span> bytes as the length prefix</li>
<li>Converts the prefix from <b>network byte order</b> to host byte order</li>
<li>Throws an exception if the length exceeds <span class="tt">maxPayloadLen</span></li>
<li>Reads exactly <span class="tt">length</span> bytes as the payload</li>
<li>Returns the payload as a binary-safe <span class="tt">std::string</span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md924"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    std::string msg = sock.readPrefixed&lt;uint32_t&gt;(1024); <span class="comment">// Rejects messages &gt; 1024 bytes</span></div>
<div class="line">    process(msg);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>&amp; ex) {</div>
<div class="line">    <span class="comment">// Handle read errors</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md925"></a>
Protocol Format</h3>
<pre>
+----------------+----------------------+
| Length (T)     | Payload (n bytes)   |
+----------------+----------------------+
|&lt;- sizeof(T) -&gt;|&lt;---- length -------&gt;|
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unsigned integral type used for the length prefix (e.g., <span class="tt">uint32_t</span>). Must be a trivially copyable type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPayloadLen</td><td>Maximum allowed length of the decoded payload in bytes. If the decoded prefix exceeds this, an exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The payload as a <span class="tt">std::string</span>, excluding the length prefix.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The connection is closed while reading</li>
<li>The length prefix is corrupt or invalid</li>
<li>The decoded length exceeds <span class="tt">maxPayloadLen</span></li>
<li>Not enough data is available to fulfill the read</li>
<li>Memory allocation fails</li>
<li>Any network error occurs</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The prefix is automatically converted from <b>network byte order</b> to host byte order using <span class="tt"><a class="el" href="namespacejsocketpp_1_1net.html#adbc3d8ebcf4347173f61e55e236c8b37" title="Converts a 16-bit unsigned integer from network to host byte order.">jsocketpp::net::fromNetwork()</a></span>. The sender must use the corresponding network encoding.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> For reading fixed-size types </dd>
<dd>
<a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a> For reading a known number of bytes </dd>
<dd>
<a class="el" href="#ga81f896d90e08fbfb1d63f1aabb21c970" title="Writes a length-prefixed payload using a fixed-size integral prefix.">writePrefixed()</a> For sending length-prefixed messages </dd>
<dd>
<a class="el" href="namespacejsocketpp_1_1net.html#adbc3d8ebcf4347173f61e55e236c8b37" title="Converts a 16-bit unsigned integer from network to host byte order.">net::fromNetwork()</a> For byte order decoding </dd></dl>

</div>
</div>
<a id="ga46777f128a2a23cba8972aefd4b86828" name="ga46777f128a2a23cba8972aefd4b86828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46777f128a2a23cba8972aefd4b86828">&#9670;&#160;</a></span>readUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Socket::readUntil </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>maxLen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">8192</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeDelimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from the socket until a specified delimiter character is encountered. </p>
<p>Reads and accumulates data from the socket until the given delimiter character is found, using the internal buffer for efficient, chunked <span class="tt">recv()</span> calls. Unlike byte-at-a-time reads, this method minimizes syscall overhead and improves performance by reading in larger blocks and scanning for the delimiter in memory.</p>
<p>If the delimiter is found, the method returns a string containing all bytes up to (and optionally including) the delimiter. If the delimiter is not found within <span class="tt">maxLen</span> bytes, an exception is thrown to prevent unbounded growth or protocol desynchronization.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md909"></a>
Implementation Details</h3>
<ul>
<li>Uses <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html#a05964f49b3ce4b2d9f2413fd40d4d174" title="Internal buffer for read operations, not thread-safe.">_internalBuffer</a></span> for buffered reads (size configurable via <span class="tt"><a class="el" href="#ga3fb196157a1cde167c47a596c9235c91" title="Sets the size of the internal read buffer used for string operations.">setInternalBufferSize()</a></span>)</li>
<li>Performs repeated <span class="tt">recv()</span> calls to fill the buffer and search for the delimiter</li>
<li>Tracks and accumulates received data until the delimiter is located</li>
<li>Supports truncation or inclusion of the delimiter via <span class="tt">includeDelimiter</span></li>
<li>Throws on early connection close or delimiter absence beyond <span class="tt">maxLen</span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md910"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read a line terminated by newline</span></div>
<div class="line">std::string line = sock.readUntil(<span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read CSV field terminated by comma</span></div>
<div class="line">std::string field = sock.readUntil(<span class="charliteral">&#39;,&#39;</span>, 1024);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Exclude the delimiter from the result</span></div>
<div class="line">std::string text = sock.readUntil(<span class="charliteral">&#39;;&#39;</span>, 8192, <span class="keyword">false</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>The character to search for in the incoming data stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxLen</td><td>The maximum number of bytes to read before giving up (default: 8192). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeDelimiter</td><td>Whether to include the delimiter in the returned string (default: true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt">std::string</span> containing the data read up to the delimiter. The result includes the delimiter if <span class="tt">includeDelimiter</span> is set to <span class="tt">true</span>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The connection is closed before the delimiter is received</li>
<li><span class="tt">maxLen</span> bytes are read without finding the delimiter</li>
<li>A network or system error occurs during reading</li>
<li>A configured timeout is exceeded (e.g., <span class="tt">SO_RCVTIMEO</span>)</li>
<li>The socket is invalid or in an error state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is fully blocking unless a timeout is configured. Use <span class="tt"><a class="el" href="#ga21767c46469a8cee88a87f45405d36fd" title="Reads a line terminated by &#39; &#39; from the socket.">readLine()</a></span> as a newline-specific shorthand.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga21767c46469a8cee88a87f45405d36fd" title="Reads a line terminated by &#39; &#39; from the socket.">readLine()</a> For newline-terminated text input </dd>
<dd>
<a class="el" href="#ga3d194596258a3b1117b3437d969019b6" title="Reads exactly n bytes from the socket into a std::string.">readExact()</a> For reading fixed-length binary data </dd>
<dd>
<a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> For fixed-size or generic reads </dd>
<dd>
<a class="el" href="#ga3fb196157a1cde167c47a596c9235c91" title="Sets the size of the internal read buffer used for string operations.">setInternalBufferSize()</a> To configure buffer size for bulk <span class="tt">recv()</span> </dd>
<dd>
<a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a> To control <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a> timeout duration </dd></dl>

</div>
</div>
<a id="ga90e5544f6d058709cc342e07554a59d5" name="ga90e5544f6d058709cc342e07554a59d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90e5544f6d058709cc342e07554a59d5">&#9670;&#160;</a></span>readv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::readv </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a vectorized read into multiple buffers using a single system call. </p>
<p>Reads data into the specified sequence of buffers using scatter/gather I/O. This method fills each buffer in order and returns the total number of bytes read. It is the counterpart to <span class="tt"><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a></span> and uses <span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> or <span class="tt">WSARecv()</span> internally.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md930"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::array&lt;std::byte, 4&gt; header;</div>
<div class="line">std::array&lt;std::byte, 128&gt; payload;</div>
<div class="line">std::array&lt;BufferView, 2&gt; views = {</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{header.data(), header.size()},</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{payload.data(), payload.size()}</div>
<div class="line">};</div>
<div class="line">std::size_t received = sock.readv(views);</div>
<div class="ttc" id="astructjsocketpp_1_1BufferView_html"><div class="ttname"><a href="structjsocketpp_1_1BufferView.html">jsocketpp::BufferView</a></div><div class="ttdoc">Represents a raw writable memory region for scatter/gather I/O.</div><div class="ttdef"><b>Definition</b> BufferView.hpp:46</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>A span of <a class="el" href="structjsocketpp_1_1BufferView.html" title="Represents a raw writable memory region for scatter/gather I/O.">BufferView</a> objects describing writable regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes read into the buffer sequence.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid</li>
<li>recv() or <a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a> fails</li>
<li>Connection is closed prematurely</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method performs a single recv()-style call. It does not retry. For full delivery into multiple buffers, use <span class="tt"><a class="el" href="#gadc68c056253b4d1c23828c2df73e6642" title="Reads exactly the full contents of all provided buffers.">readvAll()</a></span> (future).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a> For the write-side equivalent </dd>
<dd>
<a class="el" href="#gac2bfca99305ede78697fc0b39fbbeed8" title="Reads available data from the socket into the provided buffer.">readInto()</a> For single-buffer reading </dd></dl>

</div>
</div>
<a id="gadc68c056253b4d1c23828c2df73e6642" name="gadc68c056253b4d1c23828c2df73e6642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc68c056253b4d1c23828c2df73e6642">&#9670;&#160;</a></span>readvAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::readvAll </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads exactly the full contents of all provided buffers. </p>
<p>This method performs a reliable scatter read operation. It guarantees that all bytes described by the buffer span are filled by repeatedly calling <span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> until the entire memory region is received or an error occurs.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md931"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::array&lt;std::byte, 4&gt; header;</div>
<div class="line">std::vector&lt;std::byte&gt; payload(1024);</div>
<div class="line"> </div>
<div class="line">std::array&lt;BufferView, 2&gt; views = {</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{header.data(), header.size()},</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{payload.data(), payload.size()}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">sock.readvAll(views);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>A span of writable buffer views to fill completely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes read (equal to sum of buffer sizes).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The connection is closed before all data is read</li>
<li>A system or network error occurs</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a high-level, blocking call. For partial reads, use <span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a> For non-retrying variant </dd></dl>

</div>
</div>
<a id="gaf4b83c97cc8ca1fd97b0b9dfaac533b0" name="gaf4b83c97cc8ca1fd97b0b9dfaac533b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4b83c97cc8ca1fd97b0b9dfaac533b0">&#9670;&#160;</a></span>readvAllWithTotalTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::readvAllWithTotalTimeout </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads exactly the full contents of all buffers within a timeout. </p>
<p>This method performs a series of vectorized <span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> calls to fill the provided <span class="tt"><a class="el" href="structjsocketpp_1_1BufferView.html" title="Represents a raw writable memory region for scatter/gather I/O.">BufferView</a></span> span until all bytes are read or the total timeout expires. A steady clock is used to measure elapsed time across multiple system calls, ensuring the full operation adheres to the timeout limit.</p>
<p>If not all data is read before the timeout elapses, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> is thrown.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md932"></a>
Implementation Details</h3>
<ul>
<li>Performs repeated <span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> calls into pending buffers.</li>
<li>Tracks time remaining using <span class="tt">std::chrono::steady_clock</span>.</li>
<li>Waits for readability before each attempt using <span class="tt"><a class="el" href="#ga6b39b1375048cc167409b5b513c3ad8c" title="Waits for the socket to become ready for reading or writing.">waitReady()</a></span>.</li>
<li>Automatically handles partially filled buffers.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md933"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::array&lt;std::byte, 4&gt; header;</div>
<div class="line">std::vector&lt;std::byte&gt; payload(1024);</div>
<div class="line">std::array&lt;BufferView, 2&gt; views = {</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{header.data(), header.size()},</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{payload.data(), payload.size()}</div>
<div class="line">};</div>
<div class="line">sock.readvAllWithTotalTimeout(views, 2000); <span class="comment">// Must finish in 2 seconds</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Span of <a class="el" href="structjsocketpp_1_1BufferView.html" title="Represents a raw writable memory region for scatter/gather I/O.">BufferView</a> objects describing writable memory regions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Maximum allowed duration for the entire read operation, in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes read (must equal the sum of all buffer sizes on success).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If:<ul>
<li>Not all data is read before the timeout expires.</li>
<li>The socket does not become readable in time.</li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> or <span class="tt">recv()</span> fails due to network error.</li>
<li>The socket is invalid or disconnected.</li>
<li>The connection is closed before all bytes are received.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is fully blocking (until timeout or completion). Use <span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> for a single read attempt, or <span class="tt"><a class="el" href="#gadc68c056253b4d1c23828c2df73e6642" title="Reads exactly the full contents of all provided buffers.">readvAll()</a></span> for a non-timed retry loop.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gadc68c056253b4d1c23828c2df73e6642" title="Reads exactly the full contents of all provided buffers.">readvAll()</a> For retrying without a timeout </dd>
<dd>
<a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a> For single-attempt best-effort vectorized reads </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a> For timeout-specific error handling </dd></dl>

</div>
</div>
<a id="ga6a8b2fada7df0ddec9b6f2c491f4f92b" name="ga6a8b2fada7df0ddec9b6f2c491f4f92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8b2fada7df0ddec9b6f2c491f4f92b">&#9670;&#160;</a></span>readvAtMostWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::readvAtMostWithTimeout </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts a single vectorized read into multiple buffers with a timeout. </p>
<p>Waits up to <span class="tt">timeoutMillis</span> milliseconds for the socket to become readable, then performs a single <span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> operation into the provided buffer views. This method does not retry on partial reads and is suitable for polling-style I/O where responsiveness is more important than completeness.</p>
<p>May read fewer bytes than the total available buffer capacity, depending on what the socket delivers in a single system call. This is a timeout-aware variant of <span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> and should be used when non-blocking responsiveness is desired.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md934"></a>
Implementation Details</h3>
<ul>
<li>Calls <span class="tt"><a class="el" href="#ga6b39b1375048cc167409b5b513c3ad8c" title="Waits for the socket to become ready for reading or writing.">waitReady()</a></span> to wait for the socket to become readable.</li>
<li>Performs one <span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> attempt only.</li>
<li>Reads whatever data is immediately available.</li>
<li>Returns early on connection closure or any received data.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md935"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::array&lt;std::byte, 8&gt; header;</div>
<div class="line">std::array&lt;std::byte, 256&gt; body;</div>
<div class="line"> </div>
<div class="line">std::array&lt;BufferView, 2&gt; bufs = {</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{header.data(), header.size()},</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{body.data(), body.size()}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::size_t n = sock.readvAtMostWithTimeout(bufs, 300); <span class="comment">// Wait up to 300 ms</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; bytes.\n&quot;</span>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Span of writable <span class="tt"><a class="el" href="structjsocketpp_1_1BufferView.html" title="Represents a raw writable memory region for scatter/gather I/O.">BufferView</a></span>s to receive incoming data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Time in milliseconds to wait for readability:<ul>
<li>&gt; 0: Wait up to this duration</li>
<li>0: Non-blocking (poll)</li>
<li>&lt; 0: Invalid; throws exception</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read (may be 0 if timeout is 0 or nothing available).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If the socket does not become readable before timeout. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><span class="tt"><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a></span> fails with a system/network error</li>
<li>The socket is invalid</li>
<li>The connection is closed</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method performs a single system call. It does not retry or block for more data.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga90e5544f6d058709cc342e07554a59d5" title="Performs a vectorized read into multiple buffers using a single system call.">readv()</a> For non-timed scatter <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a> </dd>
<dd>
<a class="el" href="#gaf4b83c97cc8ca1fd97b0b9dfaac533b0" title="Reads exactly the full contents of all buffers within a timeout.">readvAllWithTotalTimeout()</a> For complete delivery within a time budget </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a> For timeout-related error details </dd></dl>

</div>
</div>
<a id="ga41e5ecdf97be51a3a354429be87b12d0" name="ga41e5ecdf97be51a3a354429be87b12d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e5ecdf97be51a3a354429be87b12d0">&#9670;&#160;</a></span>resetShutdownFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::Socket::resetShutdownFlags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets internal shutdown state flags to <span class="tt">false</span>. </p>
<p>This method clears the internal flags that track whether the socket's input or output streams have been shutdown via <span class="tt">shutdown(ShutdownMode)</span>. It does <b>not</b> reopen or re-enable socket directions at the system level—it only resets the internal state used by <span class="tt"><a class="el" href="#ga402fc4a398e670854cbb4edf791c1916" title="Checks whether the socket&#39;s input stream has been shutdown.">isInputShutdown()</a></span> and <span class="tt"><a class="el" href="#gad2b2992b358d3656a2e0d3e854c897bc" title="Checks whether the socket&#39;s output stream has been shutdown.">isOutputShutdown()</a></span>.</p>
<p>This method is useful when reinitializing or repurposing a <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> object after calling <span class="tt"><a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a></span>, or when transferring ownership during a move assignment where shutdown state is no longer valid.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method does <b>not</b> call any OS-level functions like <span class="tt"><a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a></span> or <span class="tt">setsockopt()</span>. It only resets internal bookkeeping flags.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is intended for internal use or advanced scenarios. Most users should not need to call this directly.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a> </dd>
<dd>
<a class="el" href="#ga402fc4a398e670854cbb4edf791c1916" title="Checks whether the socket&#39;s input stream has been shutdown.">isInputShutdown()</a> </dd>
<dd>
<a class="el" href="#gad2b2992b358d3656a2e0d3e854c897bc" title="Checks whether the socket&#39;s output stream has been shutdown.">isOutputShutdown()</a> </dd></dl>

</div>
</div>
<a id="ga069d29c3ff8b80ee9a7cb9e1e39f930a" name="ga069d29c3ff8b80ee9a7cb9e1e39f930a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga069d29c3ff8b80ee9a7cb9e1e39f930a">&#9670;&#160;</a></span>resolveBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::size_t, std::size_t, std::size_t &gt; jsocketpp::ServerSocket::resolveBuffers </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>send</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internal</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolves effective receive and send buffer sizes from optional user inputs. </p>
<p>If either buffer size is not provided, this method falls back to the per-instance <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a379cd49443199046abc16d0761e1b03a" title="Default buffer size used for accepted client sockets when no specific size is provided.">_defaultReceiveBufferSize</a></span> or <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a4c7bda2d03e2039dfa177a8a565e96ae" title="Default send buffer size for accepted client sockets.">_defaultSendBufferSize</a></span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv</td><td>Optional receive buffer size. </td></tr>
    <tr><td class="paramname">send</td><td>Optional send buffer size. </td></tr>
    <tr><td class="paramname">internal</td><td>Optional internal buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple: {resolvedRecvBufferSize, resolvedSendBufferSize, resolvedInternalBufferSize}</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae01e7a531be7a5addb83ff6b9bb111e8" title="Get the effective receive buffer size to use for socket read operations.">getEffectiveReceiveBufferSize()</a> </dd>
<dd>
<a class="el" href="#ga1308a8d172508999834853ccb35607e8" title="Get the effective send buffer size to use for socket write operations.">getEffectiveSendBufferSize()</a> </dd></dl>

</div>
</div>
<a id="ga58290010ec759550485b8eeede8d931a" name="ga58290010ec759550485b8eeede8d931a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58290010ec759550485b8eeede8d931a">&#9670;&#160;</a></span>ServerSocket() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::ServerSocket::ServerSocket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor (deleted) for <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> class. </p>
<p>The default constructor is explicitly deleted to prevent the creation of uninitialized <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> objects. Each server socket must be explicitly constructed with a valid port and configuration parameters to ensure correct binding and listening behavior.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md744"></a>
Rationale</h3>
<ul>
<li>Prevents creation of non-functional server sockets</li>
<li>Enforces proper initialization with port, backlog, and reuse options</li>
<li>Ensures RAII ownership over system-level resources</li>
</ul>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> s;          <span class="comment">// ❌ Compilation error (deleted constructor)</span></div>
<div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> s(8080);    <span class="comment">// ✅ Valid usage: bind to port 8080</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad389848c3e0fcadcfe5f581ab8c8fbb8" title="Constructs a ServerSocket for listening to incoming TCP connections with full configuration control.">ServerSocket(Port, std::string_view, bool, bool, int, bool)</a> Primary constructor </dd></dl>

</div>
</div>
<a id="gac6eeb69e3b15334e7c224edf30248fe3" name="gac6eeb69e3b15334e7c224edf30248fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6eeb69e3b15334e7c224edf30248fe3">&#9670;&#160;</a></span>ServerSocket() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::ServerSocket::ServerSocket </td>
          <td>(</td>
          <td class="paramtype">const ServerSocket &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (deleted). </p>
<p>This constructor is explicitly deleted because <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> instances manage unique system resources (socket descriptors) that cannot be safely shared or duplicated. Each socket must have exclusive ownership of its underlying system resources to ensure proper cleanup and avoid resource leaks.</p>
<p>Instead of copying, use move semantics (<a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a>&amp;&amp;) to transfer ownership of a socket between objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> to copy from (unused since deleted).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This deletion helps prevent accidental copying of socket resources and enforces RAII principles.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gace3560ea1b99e15c1564e430e8848500" title="Move constructor that transfers ownership of server socket resources.">ServerSocket(ServerSocket&amp;&amp;)</a> </dd>
<dd>
<a class="el" href="#ga9fb02efd71b7800a17f7dc64214a8e4a" title="Move assignment operator for ServerSocket.">operator=(ServerSocket&amp;&amp;)</a> </dd></dl>

</div>
</div>
<a id="gad389848c3e0fcadcfe5f581ab8c8fbb8" name="gad389848c3e0fcadcfe5f581ab8c8fbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad389848c3e0fcadcfe5f581ab8c8fbb8">&#9670;&#160;</a></span>ServerSocket() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ServerSocket::ServerSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>autoBindListen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reuseAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dualStack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> for listening to incoming TCP connections with full configuration control. </p>
<p>This constructor creates a TCP server socket that supports both IPv4 and IPv6, with flexible options for binding, listening, address selection, address reuse, accept timeouts, and dual-stack (IPv4+IPv6) control.</p>
<p>The constructor performs the following steps:</p><ul>
<li>Prepares address resolution hints for dual-stack TCP sockets (IPv4 and IPv6).</li>
<li>Uses <span class="tt">getaddrinfo()</span> to resolve the provided <span class="tt">localAddress</span> (IP address or hostname) and the given <span class="tt">port</span>.<ul>
<li>If <span class="tt">localAddress</span> is empty (<span class="tt">{}</span>), the socket will accept connections on <b>ALL local interfaces</b>.</li>
<li>If non-empty, binds only to the specified address/interface (e.g., "127.0.0.1", "::1", "192.168.1.10").</li>
</ul>
</li>
<li>Iterates through the address results, attempting to create a socket for each until one succeeds.</li>
<li>For IPv6 sockets, configures dual-stack or IPv6-only mode according to the <span class="tt">dualStack</span> parameter:<ul>
<li>If <span class="tt">dualStack</span> is true (default), disables <span class="tt">IPV6_V6ONLY</span> for dual-stack support (accepts both IPv4 and IPv6).</li>
<li>If <span class="tt">dualStack</span> is false, enables <span class="tt">IPV6_V6ONLY</span> for IPv6-only operation (no IPv4-mapped addresses).</li>
</ul>
</li>
<li>Sets the address reuse option (<span class="tt">reuseAddress</span>) <b>before</b> binding:<ul>
<li>On Windows, uses <span class="tt">SO_EXCLUSIVEADDRUSE</span> (for exclusive binding).</li>
<li>On Unix-like systems, uses <span class="tt">SO_REUSEADDR</span> (for fast port reuse).</li>
</ul>
</li>
<li>If <span class="tt">autoBindListen</span> is true, automatically calls <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> and <span class="tt"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a></span> (with default backlog). Otherwise, you must call them manually after construction.</li>
<li>Sets the accept timeout (<span class="tt">soTimeoutMillis</span>) for all subsequent <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> operations.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>If you want to fine-tune socket options (e.g., reuse, timeouts) or bind on demand, use <span class="tt">autoBindListen =
    false</span> and set options before calling <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> and <span class="tt"><a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a></span>.</li>
<li>The final reuse address setting is determined by the last value set before <span class="tt"><a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a></span> (either by parameter or <span class="tt"><a class="el" href="group__socketopts.html#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a></span>).</li>
<li>Once bound, further changes to address reuse have no effect.</li>
<li>The timeout applies to all <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> and <span class="tt"><a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a></span> calls unless a per-call timeout is provided.</li>
<li>For maximum compatibility with both IPv4 and IPv6 clients, use an empty <span class="tt">localAddress</span> and default settings.</li>
<li>Dual-stack mode is only relevant for IPv6 sockets. On platforms or addresses that do not support dual-stack, the <span class="tt">dualStack</span> parameter may be ignored.</li>
</ul>
</dd>
<dd>
This constructor is not thread safe. Do not share a <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> instance between threads during construction.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The port number to prepare the server socket for (binding will occur according to <span class="tt">autoBindListen</span>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localAddress</td><td>The local address/interface to bind to (empty for all interfaces). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoBindListen</td><td>If true (default), automatically binds and listens. If false, user must call them manually. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reuseAddress</td><td>If true (default), enables address reuse (see above) before binding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soTimeoutMillis</td><td>Accept timeout in milliseconds for <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span>; -1 (default) means block indefinitely. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dualStack</td><td>If true (default), enables dual-stack (IPv4+IPv6) for IPv6 sockets. If false, enables IPv6-only mode (no IPv4-mapped addresses). Has no effect for IPv4 sockets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If address resolution, socket creation, binding, or socket option configuration fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__socketopts.html#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a>, <a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a>, <a class="el" href="#ga1ca989ba16d32862dd4fa9bbb2b165b5" title="Binds the server socket to the configured port and network interface.">bind()</a>, <a class="el" href="#ga4780ea0cf2fb98d0081ed91d8dbecfa3" title="Marks the socket as a passive (listening) socket, ready to accept incoming TCP connection requests.">listen()</a>, <a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: Minimal usage—listen on all interfaces, default options</span></div>
<div class="line"><a class="code hl_class" href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a> server(8080);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example: Listen on all interfaces, enable address reuse, block up to 5 seconds for accept()</span></div>
<div class="line"><a class="code hl_class" href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a> server(8080, {}, <span class="keyword">true</span>, <span class="keyword">true</span>, 5000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example: Manual control—bind and listen later</span></div>
<div class="line"><a class="code hl_class" href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a> server(8080, <span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div>
<div class="line">server.setReuseAddress(<span class="keyword">true</span>); <span class="comment">// Change before bind</span></div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example: IPv6-only server (no IPv4-mapped addresses)</span></div>
<div class="line"><a class="code hl_class" href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a> server(8080, <span class="stringliteral">&quot;::1&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, -1, <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gace3560ea1b99e15c1564e430e8848500" name="gace3560ea1b99e15c1564e430e8848500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace3560ea1b99e15c1564e430e8848500">&#9670;&#160;</a></span>ServerSocket() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::ServerSocket::ServerSocket </td>
          <td>(</td>
          <td class="paramtype">ServerSocket &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor that transfers ownership of server socket resources. </p>
<p>This constructor implements move semantics to efficiently transfer ownership of socket resources from one <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> object to another. It's particularly useful when you need to transfer socket ownership (e.g., returning from functions or storing in containers) without copying the underlying system resources.</p>
<p>The operation provides the strong exception guarantee and is marked noexcept:</p><ul>
<li>All resources are transferred from <span class="tt">rhs</span> to the new object.</li>
<li>The moved-from object (<span class="tt">rhs</span>) is left in a valid but empty state.</li>
<li>No system resources are duplicated or leaked during the transfer.</li>
</ul>
<p>After the move:</p><ul>
<li>The new object takes full ownership of the socket and its state.</li>
<li>The moved-from object becomes closed (invalid socket, null pointers).</li>
<li>All socket options and state flags are transferred.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> to move resources from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation is thread-safe with respect to the moved-from socket, but concurrent operations on either socket during the move may cause undefined behavior.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga9fb02efd71b7800a17f7dc64214a8e4a" title="Move assignment operator for ServerSocket.">operator=(ServerSocket&amp;&amp;)</a> </dd>
<dd>
<a class="el" href="#ga0245d40096ca089255c67303eebf17e6" title="Closes the server socket and releases its associated system resources.">close()</a> </dd></dl>

</div>
</div>
<a id="gab42832248058c119c99ef60c4d72d478" name="gab42832248058c119c99ef60c4d72d478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab42832248058c119c99ef60c4d72d478">&#9670;&#160;</a></span>setDefaultInternalBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::ServerSocket::setDefaultInternalBufferSize </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the per-instance default internal buffer size used for buffered read operations. </p>
<p>This method updates the <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#aa799b52c795a1245b1a18945ceacce6b" title="Default internal buffer size for accepted client sockets, used by some read() methods.">_defaultInternalBufferSize</a></span> value, which determines the fallback buffer size used by methods like <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> or <span class="tt">readLine()</span> when no explicit <span class="tt">internalBufferSize</span> is provided.</p>
<p>This does <b>not</b> affect the kernel-level <span class="tt">SO_RCVBUF</span>. It applies only to the internal buffering layer used in higher-level stream-oriented reads (e.g., reading lines or strings).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>New default buffer size in bytes for this socket/server instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac1f9d646223bb7c733216b484f517d46" title="Get the per-instance default internal buffer size used for buffered read operations.">getDefaultInternalBufferSize()</a> </dd>
<dd>
<a class="el" href="#ga474741cb104a36bab217ea478608439c" title="Get the effective internal buffer size to use for buffered socket read operations.">getEffectiveInternalBufferSize()</a> </dd>
<dd>
<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a> </dd></dl>

</div>
</div>
<a id="gaf644d3fccaebced95dd6bc2055bbed3e" name="gaf644d3fccaebced95dd6bc2055bbed3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf644d3fccaebced95dd6bc2055bbed3e">&#9670;&#160;</a></span>setDefaultReceiveBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::ServerSocket::setDefaultReceiveBufferSize </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the default receive buffer size for accepted client sockets. </p>
<p>This sets the initial buffer size used when accepting new client connections. The buffer size determines how much data can be buffered for reading from the socket before the underlying receive buffer overflows.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe if called before concurrent <a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a> calls.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>New buffer size in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga29de003fbad91f7302115d26b89ac888" title="Get the current default receive buffer size for accepted client sockets.">getDefaultReceiveBufferSize()</a> </dd>
<dd>
<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a> </dd>
<dd>
<a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a>, <a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a>, <a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a> </dd></dl>

</div>
</div>
<a id="gadbeecdd1d47fb8244dab210fa297fcf9" name="gadbeecdd1d47fb8244dab210fa297fcf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbeecdd1d47fb8244dab210fa297fcf9">&#9670;&#160;</a></span>setDefaultSendBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::ServerSocket::setDefaultSendBufferSize </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the default send buffer size for accepted client sockets. </p>
<p>This sets the initial send buffer size used when accepting new client connections. The buffer size determines how much data can be buffered for writing to the socket before the underlying send buffer overflows.</p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe if called before concurrent <a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a> calls.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>New send buffer size in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga80d2d5fc59fa2b10e586287d6ffd84f7" title="Get the current default send buffer size for accepted client sockets.">getDefaultSendBufferSize()</a> </dd>
<dd>
<a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7" title="Default internal buffer size (in bytes) for socket read operations.">DefaultBufferSize</a> </dd>
<dd>
<a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a> </dd></dl>

</div>
</div>
<a id="ga3fb196157a1cde167c47a596c9235c91" name="ga3fb196157a1cde167c47a596c9235c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fb196157a1cde167c47a596c9235c91">&#9670;&#160;</a></span>setInternalBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::setInternalBufferSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>newLen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the internal read buffer used for string operations. </p>
<p>This method controls the size of the internal buffer used by <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read&lt;std::string&gt;()</a> operations. This is distinct from <a class="el" href="group__socketopts.html#ga69fdecc0aaaef4bbd2826c448a8bbe1d" title="Sets the socket&#39;s receive buffer size (SO_RCVBUF).">setReceiveBufferSize()</a>, which controls the operating system's socket buffer (SO_RCVBUF).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md969"></a>
Purpose</h3>
<ul>
<li>Controls maximum size of data readable in one <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read&lt;std::string&gt;()</a> call</li>
<li>Affects memory usage of the <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object</li>
<li>Does not affect system socket buffers or network behavior</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md970"></a>
Implementation Details</h3>
<ul>
<li>Resizes internal std::vector&lt;char&gt; buffer</li>
<li>Used only for string-based reads</li>
<li>Not used for fixed-size <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read&lt;T&gt;()</a> operations</li>
<li>Thread-safe with respect to other <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> instances</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md971"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set 8KB internal buffer for string reads</span></div>
<div class="line">sock.setInternalBufferSize(8192);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read will now use 8KB buffer</span></div>
<div class="line">std::string data = sock.read&lt;std::string&gt;();</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newLen</td><td>New size for the internal buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If memory allocation fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__socketopts.html#ga69fdecc0aaaef4bbd2826c448a8bbe1d" title="Sets the socket&#39;s receive buffer size (SO_RCVBUF).">setReceiveBufferSize()</a> For setting the OS socket receive buffer </dd>
<dd>
<a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read&lt;std::string&gt;()</a> Uses this buffer for string operations </dd>
<dd>
<a class="el" href="group__socketopts.html#ga8279b0c70f6a0fddf73d84aac691422b" title="Sets the socket&#39;s send buffer size (SO_SNDBUF).">setSendBufferSize()</a> For setting the OS socket send buffer </dd></dl>

</div>
</div>
<a id="gaacbacf59cf8239e66c80c66a09243ec3" name="gaacbacf59cf8239e66c80c66a09243ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacbacf59cf8239e66c80c66a09243ec3">&#9670;&#160;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174">ShutdownMode</a></td>          <td class="paramname"><span class="paramname"><em>how</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown specific communication aspects of the socket. </p>
<p>This method allows for a controlled shutdown of socket communications in one or both directions without closing the socket itself. Unlike <a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a>, which immediately terminates all communications, <a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a> provides finer control over how the connection is terminated.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md940"></a>
Shutdown Modes</h3>
<ul>
<li><b><a class="el" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a7a1a5f3e79fdc91edf2f5ead9d66abb4" title="Shutdown read operations (SHUT_RD or SD_RECEIVE).">ShutdownMode::Read</a></b>: Disables further receive operations<ul>
<li>Subsequent <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> calls will return EOF</li>
<li>Already received data can still be read</li>
<li>Send operations remain unaffected</li>
</ul>
</li>
<li><b><a class="el" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a1129c0e4d43f2d121652a7302712cff6" title="Shutdown write operations (SHUT_WR or SD_SEND).">ShutdownMode::Write</a></b>: Disables further send operations<ul>
<li>Sends pending data before shutting down</li>
<li>Sends FIN packet to peer</li>
<li>Receive operations remain unaffected</li>
</ul>
</li>
<li><b><a class="el" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a130c5b3473c57faa76e2a1c54e26f88e" title="Shutdown both read and write operations (SHUT_RDWR or SD_BOTH).">ShutdownMode::Both</a></b>: Disables both send and receive operations (full-duplex shutdown)<ul>
<li>Equivalent to calling <a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a> with Read and Write modes</li>
<li>Unlike <span class="tt"><a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a></span>, this does <b>not</b> release the socket descriptor or system resources.</li>
<li>The socket remains open and can still be queried, reused, or closed later.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md941"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send final message</span></div>
<div class="line">sock.write(<span class="stringliteral">&quot;Goodbye!&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Shutdown sending but continue receiving</span></div>
<div class="line">sock.shutdown(<a class="code hl_enumvalue" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a1129c0e4d43f2d121652a7302712cff6">ShutdownMode::Write</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read any remaining responses</span></div>
<div class="line">std::string response = sock.read&lt;std::string&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Complete shutdown</span></div>
<div class="line">sock.shutdown(<a class="code hl_enumvalue" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a130c5b3473c57faa76e2a1c54e26f88e">ShutdownMode::Both</a>);</div>
<div class="ttc" id="anamespacejsocketpp_html_a0d2868e06cd95730d5088336f8c3c174a1129c0e4d43f2d121652a7302712cff6"><div class="ttname"><a href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a1129c0e4d43f2d121652a7302712cff6">jsocketpp::ShutdownMode::Write</a></div><div class="ttdeci">@ Write</div><div class="ttdoc">Shutdown write operations (SHUT_WR or SD_SEND).</div><div class="ttdef"><b>Definition</b> common.hpp:371</div></div>
<div class="ttc" id="anamespacejsocketpp_html_a0d2868e06cd95730d5088336f8c3c174a130c5b3473c57faa76e2a1c54e26f88e"><div class="ttname"><a href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a130c5b3473c57faa76e2a1c54e26f88e">jsocketpp::ShutdownMode::Both</a></div><div class="ttdeci">@ Both</div><div class="ttdoc">Shutdown both read and write operations (SHUT_RDWR or SD_BOTH).</div><div class="ttdef"><b>Definition</b> common.hpp:372</div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md942"></a>
Implementation Details</h3>
<ul>
<li>Uses platform-specific <a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a> system call</li>
<li>Handles partial shutdowns gracefully</li>
<li>Does not release socket resources (use <a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a> for that)</li>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> remains valid after shutdown</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">how</td><td>Specifies which operations to shut down:<ul>
<li><a class="el" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a7a1a5f3e79fdc91edf2f5ead9d66abb4" title="Shutdown read operations (SHUT_RD or SD_RECEIVE).">ShutdownMode::Read</a>: Disable receiving</li>
<li><a class="el" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a1129c0e4d43f2d121652a7302712cff6" title="Shutdown write operations (SHUT_WR or SD_SEND).">ShutdownMode::Write</a>: Disable sending</li>
<li><a class="el" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174a130c5b3473c57faa76e2a1c54e26f88e" title="Shutdown both read and write operations (SHUT_RDWR or SD_BOTH).">ShutdownMode::Both</a>: Disable both (default)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is invalid (EBADF)</li>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not connected (ENOTCONN)</li>
<li>Permission denied (EACCES)</li>
<li>Memory/resource allocation fails</li>
<li>Other system-specific errors</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is not thread-safe. Do not call <a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a> while other threads are performing operations on the same <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> instance.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a> For completely closing the socket </dd>
<dd>
<a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2" title="Indicates whether the socket has been successfully connected to a remote host.">isConnected()</a> Check connection status </dd>
<dd>
<a class="el" href="namespacejsocketpp.html#a0d2868e06cd95730d5088336f8c3c174" title="Enum for socket shutdown modes.">ShutdownMode</a> Enumeration of available <a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown</a> modes </dd></dl>

</div>
</div>
<a id="gabc4e14475484e596ac62509e627a9baf" name="gabc4e14475484e596ac62509e627a9baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc4e14475484e596ac62509e627a9baf">&#9670;&#160;</a></span>Socket() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::Socket::Socket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor (deleted) for <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> class. </p>
<p>The default constructor is explicitly deleted to prevent the creation of uninitialized <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> objects. Each socket must be explicitly constructed with a valid host/port combination or from an accepted client connection.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md854"></a>
Rationale</h3>
<ul>
<li>Prevents accidental creation of an invalid socket</li>
<li>Enforces explicit resource ownership and initialization</li>
<li>Avoids ambiguity around object state (e.g., <a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> = INVALID_SOCKET)</li>
</ul>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> s;               <span class="comment">// ❌ Compilation error (deleted constructor)</span></div>
<div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> s(<span class="stringliteral">&quot;host&quot;</span>, 1234); <span class="comment">// ✅ Correct usage</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>Socket(std::string_view, Port, std::size_t) Primary constructor </dd>
<dd>
Socket(SOCKET, const sockaddr_storage&amp;, socklen_t, std::size_t, std::size_t) Server-side accept constructor </dd></dl>

</div>
</div>
<a id="gaf5a4ddebfbca7bfe6c9a88462cc9ada8" name="gaf5a4ddebfbca7bfe6c9a88462cc9ada8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5a4ddebfbca7bfe6c9a88462cc9ada8">&#9670;&#160;</a></span>Socket() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype">const Socket &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (deleted) for <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> class. </p>
<p>This constructor is explicitly deleted because <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> objects manage unique system resources (socket file descriptors) that cannot be safely duplicated. Each socket must have exclusive ownership of its underlying resources to prevent issues like:</p><ul>
<li>Double-closing of socket descriptors</li>
<li>Race conditions in multi-threaded code</li>
<li>Ambiguous ownership of system resources</li>
<li>Potential resource leaks</li>
</ul>
<p>Instead of copying, use move semantics (<a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>&amp;&amp;) to transfer ownership of a <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> from one object to another. For example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> s1(<span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> s2(std::move(s1)); <span class="comment">// OK: moves ownership from s1 to s2</span></div>
<div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> s3(s2);            <span class="comment">// Error: copying is disabled</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object to copy from (unused since deleted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad0612bda82c378dbaf99e0839f5aa815" title="Move constructor that transfers ownership of socket resources.">Socket(Socket&amp;&amp;)</a> Move constructor for transferring socket ownership </dd>
<dd>
<a class="el" href="#ga05b1ae2ec76833370c809c53fe550a95" title="Move assignment operator that transfers socket ownership safely.">operator=(Socket&amp;&amp;)</a> Move assignment operator for transferring socket ownership </dd></dl>

</div>
</div>
<a id="gad0612bda82c378dbaf99e0839f5aa815" name="gad0612bda82c378dbaf99e0839f5aa815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0612bda82c378dbaf99e0839f5aa815">&#9670;&#160;</a></span>Socket() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype">Socket &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor that transfers ownership of socket resources. </p>
<p>Creates a new <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> by taking ownership of another <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>'s resources. This constructor is essential for scenarios where <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> objects need to be transferred (e.g., returning from functions, storing in containers) since copying is disabled.</p>
<p>The constructor performs the following:</p><ol type="1">
<li>Takes ownership of the socket descriptor</li>
<li>Transfers remote address information</li>
<li>Moves address resolution data</li>
<li>Transfers the receive buffer</li>
<li>Resets the source object to a valid but empty state</li>
</ol>
<p>The moved-from socket (rhs) remains valid but will be in a default-constructed state with no active connection (<a class="el" href="group__socketopts.html#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> = INVALID_SOCKET).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object to move from. After the move, rhs will be left in a valid but disconnected state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation is noexcept as it cannot fail - at worst, we'd have a <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> in an empty state, which is valid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf5a4ddebfbca7bfe6c9a88462cc9ada8" title="Copy constructor (deleted) for Socket class.">Socket(const Socket&amp;)</a> Copy constructor (deleted) </dd>
<dd>
<a class="el" href="#ga05b1ae2ec76833370c809c53fe550a95" title="Move assignment operator that transfers socket ownership safely.">operator=(Socket&amp;&amp;)</a> Move assignment operator </dd></dl>

</div>
</div>
<a id="ga6da94c322a3ed5f85efd26a7fbadbe0a" name="ga6da94c322a3ed5f85efd26a7fbadbe0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">&#9670;&#160;</a></span>Socket() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a></td>          <td class="paramname"><span class="paramname"><em>client</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr_storage &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">DefaultBufferSize</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">DefaultBufferSize</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">DefaultBufferSize</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps an accepted TCP client socket with optional tuning parameters. </p>
<p>This constructor creates a <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> object by taking ownership of a socket descriptor returned by <span class="tt">accept()</span>, applying the given address, and configuring buffer sizes, timeouts, and TCP-specific options.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md848"></a>
🛠 Use Cases</h3>
<ul>
<li>Inside <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">ServerSocket::accept()</a></span> to wrap the raw socket handle into a high-level object</li>
<li>For servers that need to apply consistent socket-level behavior (timeouts, no-delay, etc.)</li>
<li>For applications using RAII and exception-safe socket wrappers</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md850"></a>
Configuration Parameters</h3>
<ul>
<li><span class="tt">recvBufferSize</span>, <span class="tt">sendBufferSize</span>: OS-level socket buffers (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li><span class="tt">internalBufferSize</span>: Buffer used by <span class="tt"><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a>&lt;T&gt;()</span> and <span class="tt"><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a>&lt;std::string&gt;()</span></li>
<li><span class="tt">soRecvTimeoutMillis</span>: Read timeout in milliseconds (<span class="tt">SO_RCVTIMEO</span>)</li>
<li><span class="tt">soSendTimeoutMillis</span>: Send timeout in milliseconds (<span class="tt">SO_SNDTIMEO</span>)</li>
<li><span class="tt">tcpNoDelay</span>: Disables Nagle's algorithm (<span class="tt">TCP_NODELAY</span>) for low-latency use cases</li>
<li><span class="tt">keepAlive</span>: Enables TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>)</li>
<li><span class="tt">nonBlocking</span>: Places the socket in non-blocking mode immediately after construction</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md852"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_friend" href="#ga11a8bb11feaafab939278a8285afa567">ServerSocket</a> server(8080);</div>
<div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> client = server.accept(<a class="code hl_variable" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">DefaultBufferSize</a>, <a class="code hl_variable" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">DefaultBufferSize</a>, <a class="code hl_variable" href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">DefaultBufferSize</a>,</div>
<div class="line">                              3000, 1000, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="ttc" id="agroup__core_html_gafa19c7cbeb622b106835021215b8d6b7"><div class="ttname"><a href="group__core.html#gafa19c7cbeb622b106835021215b8d6b7">jsocketpp::DefaultBufferSize</a></div><div class="ttdeci">constexpr std::size_t DefaultBufferSize</div><div class="ttdoc">Default internal buffer size (in bytes) for socket read operations.</div><div class="ttdef"><b>Definition</b> common.hpp:434</div></div>
<div class="ttc" id="agroup__tcp_html_ga11a8bb11feaafab939278a8285afa567"><div class="ttname"><a href="#ga11a8bb11feaafab939278a8285afa567">jsocketpp::Socket::ServerSocket</a></div><div class="ttdeci">friend class ServerSocket</div><div class="ttdoc">Grants ServerSocket access to private members.</div><div class="ttdef"><b>Definition</b> Socket.hpp:107</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client</td><td>A connected socket descriptor returned by <span class="tt">accept()</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The client's address information (from <span class="tt">accept()</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the address structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>OS-level receive buffer size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>OS-level send buffer size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Internal read buffer size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Timeout for <span class="tt">recv()</span>/<span class="tt"><a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a></span> in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Timeout for <span class="tt">send()</span> in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>Whether to disable Nagle's algorithm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>Whether to enable TCP keep-alive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>Whether to set the socket to non-blocking mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If any tuning operation fails after the socket is accepted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">ServerSocket::accept()</a>, <a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a>, <a class="el" href="group__socketopts.html#ga7107a9da459b00bf39ec2fe4d3e83396" title="Sets the socket send timeout (SO_SNDTIMEO) in milliseconds.">setSoSendTimeout()</a>, <a class="el" href="group__socketopts.html#ga9839dd8837c7519a627f28b3a4c7a513" title="Enables or disables Nagle’s algorithm (TCP_NODELAY) on TCP sockets.">setTcpNoDelay()</a>, <a class="el" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a> </dd></dl>

</div>
</div>
<a id="ga201308e71110af1410e39920f02adf89" name="ga201308e71110af1410e39920f02adf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga201308e71110af1410e39920f02adf89">&#9670;&#160;</a></span>Socket() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Socket::Socket </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>host</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reuseAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dualStack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>autoConnect</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>autoBind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7">Port</a></td>          <td class="paramname"><span class="paramname"><em>localPort</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a TCP client socket, resolves the remote host and port, and optionally binds or connects. </p>
<p>This constructor creates a TCP socket intended for client-side connections. It resolves the specified remote <span class="tt">host</span> and <span class="tt">port</span>, applies socket-level configuration, and optionally:</p><ul>
<li>Binds the socket to a specified local address and/or port (<span class="tt">autoBind</span>)</li>
<li>Connects to the resolved peer (<span class="tt">autoConnect</span>)</li>
</ul>
<p>The socket supports both IPv4 and IPv6, dual-stack operation, and high-level configuration of timeouts, buffer sizes, and TCP flags like <span class="tt">TCP_NODELAY</span> and <span class="tt">SO_KEEPALIVE</span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md856"></a>
🔧 Configuration Parameters</h3>
<ul>
<li><span class="tt">recvBufferSize</span>, <span class="tt">sendBufferSize</span>: Set OS-level buffer sizes (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li><span class="tt">internalBufferSize</span>: Controls the internal buffer used by high-level read methods</li>
<li><span class="tt">reuseAddress</span>: Enables <span class="tt">SO_REUSEADDR</span>, useful for NAT traversal and reconnect loops</li>
<li><span class="tt">soRecvTimeoutMillis</span>: Sets read timeout in milliseconds (<span class="tt">SO_RCVTIMEO</span>); <span class="tt">-1</span> disables</li>
<li><span class="tt">soSendTimeoutMillis</span>: Sets send timeout in milliseconds (<span class="tt">SO_SNDTIMEO</span>); <span class="tt">-1</span> disables</li>
<li><span class="tt">dualStack</span>: Enables dual-stack fallback via <span class="tt">AF_UNSPEC</span> (IPv6 socket accepts IPv4-mapped traffic)</li>
<li><span class="tt">tcpNoDelay</span>: Disables Nagle's algorithm (<span class="tt">TCP_NODELAY</span>) for low-latency protocols</li>
<li><span class="tt">keepAlive</span>: Enables TCP keep-alive probes (<span class="tt">SO_KEEPALIVE</span>)</li>
<li><span class="tt">nonBlocking</span>: Sets the socket to non-blocking mode immediately after creation</li>
<li><span class="tt">autoBind</span>: If <span class="tt">true</span>, binds to the specified local address and/or port before connecting</li>
<li><span class="tt">autoConnect</span>: If <span class="tt">true</span>, performs a blocking <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> immediately after creation</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md858"></a>
🌐 Local Binding Parameters (used only if <span class="tt">autoBind == true</span>)</h3>
<ul>
<li><span class="tt">localAddress</span>: IP address to bind from (e.g., <span class="tt">"192.168.0.100"</span> or <span class="tt">"::1"</span>). Use empty string to bind to all local interfaces.</li>
<li><span class="tt">localPort</span>: <a class="el" href="group__core.html#ga1a7be273748ae3d91bc5ebe6499788a7" title="Type alias representing a TCP or UDP port number (1–65535).">Port</a> to bind from. Use <span class="tt">0</span> to let the OS assign an ephemeral port.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md860"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;api.example.com&quot;</span>, 443,</div>
<div class="line">            8192, 8192, 8192,</div>
<div class="line">            <span class="keyword">true</span>,           <span class="comment">// reuseAddress</span></div>
<div class="line">            5000,           <span class="comment">// soRecvTimeoutMillis</span></div>
<div class="line">            2000,           <span class="comment">// soSendTimeoutMillis</span></div>
<div class="line">            <span class="keyword">true</span>,           <span class="comment">// dualStack</span></div>
<div class="line">            <span class="keyword">true</span>,           <span class="comment">// tcpNoDelay</span></div>
<div class="line">            <span class="keyword">true</span>,           <span class="comment">// keepAlive</span></div>
<div class="line">            <span class="keyword">false</span>,          <span class="comment">// nonBlocking</span></div>
<div class="line">            <span class="keyword">true</span>,           <span class="comment">// autoConnect</span></div>
<div class="line">            <span class="keyword">true</span>,           <span class="comment">// autoBind</span></div>
<div class="line">            <span class="stringliteral">&quot;192.168.1.10&quot;</span>, <span class="comment">// localAddress</span></div>
<div class="line">            0);             <span class="comment">// localPort</span></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Remote hostname or IP address to connect to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Remote TCP port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional socket receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional socket send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Optional internal read buffer size for high-level operations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reuseAddress</td><td>Enables <span class="tt">SO_REUSEADDR</span> to allow rebinding to the same port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Timeout for receive operations in milliseconds (<span class="tt">SO_RCVTIMEO</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Timeout for send operations in milliseconds (<span class="tt">SO_SNDTIMEO</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dualStack</td><td>If <span class="tt">true</span>, uses <span class="tt">AF_UNSPEC</span> to allow IPv6+IPv4 fallback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>If <span class="tt">true</span>, disables Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>If <span class="tt">true</span>, enables TCP keep-alive probes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>If <span class="tt">true</span>, sets the socket to non-blocking mode after creation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoConnect</td><td>If <span class="tt">true</span>, immediately performs a blocking <span class="tt"><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a></span> to the peer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoBind</td><td>If <span class="tt">true</span>, performs a <span class="tt"><a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51" title="Binds the client socket to all interfaces using an ephemeral port.">bind()</a></span> before connecting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localAddress</td><td>Local IP to bind to (if <span class="tt">autoBind == true</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localPort</td><td>Local port to bind to (if <span class="tt">autoBind == true</span>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If resolution, socket creation, binding, configuration, or connection fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga93cc325113abb7433288338ca3facde1" title="Establishes a TCP connection to the remote host with optional timeout control.">connect()</a>, <a class="el" href="#gace1da4f860ac0af46d702cb5fc875a51" title="Binds the client socket to all interfaces using an ephemeral port.">bind()</a>, <a class="el" href="group__socketopts.html#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a>, <a class="el" href="group__socketopts.html#ga7107a9da459b00bf39ec2fe4d3e83396" title="Sets the socket send timeout (SO_SNDTIMEO) in milliseconds.">setSoSendTimeout()</a>, <a class="el" href="group__socketopts.html#ga9839dd8837c7519a627f28b3a4c7a513" title="Enables or disables Nagle’s algorithm (TCP_NODELAY) on TCP sockets.">setTcpNoDelay()</a>, <a class="el" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a> </dd></dl>

</div>
</div>
<a id="ga93a186b3fcb925c3a6c30f1c5d5bf8a8" name="ga93a186b3fcb925c3a6c30f1c5d5bf8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93a186b3fcb925c3a6c30f1c5d5bf8a8">&#9670;&#160;</a></span>tryAccept() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt; ServerSocket::tryAccept </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to accept an incoming client connection, waiting up to a specified timeout and returning <span class="tt">std::nullopt</span> on timeout. </p>
<p>This method waits for an incoming client connection using the explicitly provided <span class="tt">timeoutMillis</span> value, overriding any timeout configured via <span class="tt"><a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a></span>. If a client connects before the timeout expires, a fully configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> is returned. Otherwise, <span class="tt">std::nullopt</span> is returned instead of throwing.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md777"></a>
⏱ Timeout Behavior</h3>
<ul>
<li><b>Negative</b> <span class="tt">timeoutMillis</span>: Block indefinitely until a client connects</li>
<li><b>Zero</b>: Poll immediately; return <span class="tt">std::nullopt</span> if no client is waiting</li>
<li><b>Positive</b>: Wait up to <span class="tt">timeoutMillis</span> milliseconds; return <span class="tt">std::nullopt</span> if no client connects in time</li>
</ul>
<p>Readiness is detected using <span class="tt">select()</span> via <span class="tt">waitReady(timeoutMillis)</span>, followed by a call to <span class="tt">acceptBlocking(...)</span> if the socket is ready.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md779"></a>
⚙️ Configuration of Accepted Socket</h3>
<p>If a client is accepted, the resulting <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> is configured using the following options:</p><ul>
<li><span class="tt">recvBufferSize</span>, <span class="tt">sendBufferSize</span>: OS-level socket buffer sizes (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li><span class="tt">internalBufferSize</span>: High-level internal buffer used by <span class="tt">read&lt;T&gt;()</span> and <span class="tt">read&lt;std::string&gt;()</span></li>
<li><span class="tt">soRecvTimeoutMillis</span>: <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds</li>
<li><span class="tt">soSendTimeoutMillis</span>: <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds</li>
<li><span class="tt">tcpNoDelay</span>: Disables Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>) for low-latency operation (default: <span class="tt">true</span>)</li>
<li><span class="tt">keepAlive</span>: Enables TCP keep-alive probes (<span class="tt">SO_KEEPALIVE</span>)</li>
<li><span class="tt">nonBlocking</span>: If <span class="tt">true</span>, sets the accepted socket to non-blocking mode</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md781"></a>
⚠️ Race Condition Warning</h3>
<p>Even after readiness is reported, <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> may still fail with <span class="tt">EWOULDBLOCK</span> or <span class="tt">EAGAIN</span> if the client disconnects in the small window before <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> is invoked. In that case, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md783"></a>
⚠️ Thread Safety</h3>
<p>This method is <b>not thread-safe</b>. If used from multiple threads, you must externally synchronize access to the server socket to prevent race conditions.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md785"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> server(8080);</div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <span class="keyword">auto</span> client = server.tryAccept(100,            <span class="comment">// Wait 100 ms per poll</span></div>
<div class="line">                                    8192, 8192, 8192, <span class="comment">// Buffer sizes</span></div>
<div class="line">                                    3000, 1000,     <span class="comment">// Timeouts</span></div>
<div class="line">                                    <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>); <span class="comment">// Tuning flags</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (client) {</div>
<div class="line">        handleClient(*client);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// No client yet — continue polling</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Timeout in milliseconds for this call:<ul>
<li>Negative: block indefinitely</li>
<li>Zero: poll once</li>
<li>Positive: wait up to <span class="tt">timeoutMillis</span> for a connection</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Optional internal buffer for <span class="tt">read&lt;T&gt;()</span>-style calls </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Receive timeout for the accepted socket (<span class="tt">SO_RCVTIMEO</span>); <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Send timeout for the accepted socket (<span class="tt">SO_SNDTIMEO</span>); <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>Whether to disable Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>); default: <span class="tt">true</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>Whether to enable TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>Whether to set the accepted socket to non-blocking mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">std::optional&lt;<a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>&gt;</span> — configured client socket on success, or <span class="tt">std::nullopt</span> on timeout</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the server socket is invalid or <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> fails due to system error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The server socket must be open, bound, and listening </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Returns a valid <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> or <span class="tt">std::nullopt</span> if the timeout expires</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a>, <a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a>, <a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a>, <a class="el" href="#gaa825d267c5cba8febdd2824282869ac1" title="Attempts to accept a client connection in non-blocking mode and returns a fully configured Socket.">acceptNonBlocking()</a>, <a class="el" href="#ga61c1904213b0971817ec917fd2a01ccf" title="Waits for the server socket to become ready to accept an incoming connection.">waitReady()</a>, <a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a> </dd></dl>

</div>
</div>
<a id="ga6eff2e5c775318cfd2813ee72e716571" name="ga6eff2e5c775318cfd2813ee72e716571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eff2e5c775318cfd2813ee72e716571">&#9670;&#160;</a></span>tryAccept() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classjsocketpp_1_1Socket.html">Socket</a> &gt; ServerSocket::tryAccept </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>recvBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>internalBufferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soRecvTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>soSendTimeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tcpNoDelay</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to accept an incoming client connection, returning <span class="tt">std::nullopt</span> on timeout instead of throwing. </p>
<p>This method waits for an incoming client connection using the timeout configured via <span class="tt"><a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a></span>. If a client is available before the timeout expires, it returns a fully configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> object. If no client connects in time, it returns <span class="tt">std::nullopt</span> rather than throwing.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md766"></a>
⏱ Timeout Behavior</h3>
<ul>
<li>If the socket timeout is <b>negative</b> (default), the method blocks indefinitely.</li>
<li>If the timeout is <b>zero</b>, it polls and returns immediately if no client is waiting.</li>
<li>If the timeout is <b>positive</b>, the method waits up to that many milliseconds using <span class="tt">select()</span>.<ul>
<li>If no connection arrives within that time, it returns <span class="tt">std::nullopt</span> (unlike <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> which throws).</li>
</ul>
</li>
</ul>
<p>Internally, <span class="tt"><a class="el" href="#ga61c1904213b0971817ec917fd2a01ccf" title="Waits for the server socket to become ready to accept an incoming connection.">waitReady()</a></span> is used for readiness detection, followed by <span class="tt"><a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a></span> for the actual accept.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md768"></a>
⚙️ Configuration of Accepted Socket</h3>
<p>The returned <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (if any) is configured using the following tuning options:</p><ul>
<li><span class="tt">recvBufferSize</span>, <span class="tt">sendBufferSize</span>: OS-level buffer sizes (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li><span class="tt">internalBufferSize</span>: Internal buffer used by <span class="tt">read&lt;T&gt;()</span> and <span class="tt">read&lt;std::string&gt;()</span></li>
<li><span class="tt">soRecvTimeoutMillis</span>: Receive timeout for the socket (<span class="tt">SO_RCVTIMEO</span>) in milliseconds</li>
<li><span class="tt">soSendTimeoutMillis</span>: Send timeout for the socket (<span class="tt">SO_SNDTIMEO</span>) in milliseconds</li>
<li><span class="tt">tcpNoDelay</span>: Disables Nagle’s algorithm for lower latency (default: <span class="tt">true</span>)</li>
<li><span class="tt">keepAlive</span>: Enables TCP keep-alive probes</li>
<li><span class="tt">nonBlocking</span>: Immediately sets the accepted socket into non-blocking mode</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md770"></a>
⚠️ Thread Safety</h3>
<p>This method is <b>not thread-safe</b>. Concurrent calls from multiple threads or processes may cause race conditions or spurious failures. Use a mutex to guard access to <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> methods if needed.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md772"></a>
💡 Notes</h3>
<ul>
<li>This method is ideal for polling servers and event-driven architectures.</li>
<li>For per-call timeouts instead of using <span class="tt"><a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a></span>, use <span class="tt">tryAccept(int timeoutMillis, ...)</span>.</li>
<li>Unlike <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span>, this method never throws <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span>.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md774"></a>
🧠 Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga58290010ec759550485b8eeede8d931a">ServerSocket</a> server(8080);</div>
<div class="line">server.bind();</div>
<div class="line">server.listen();</div>
<div class="line">server.setSoTimeout(100); <span class="comment">// Poll every 100 ms</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> client = server.tryAccept(</div>
<div class="line">            8192, 8192, 8192,</div>
<div class="line">            3000, 1000,</div>
<div class="line">            <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>)) {</div>
<div class="line">        handleClient(*client);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// No client ready; do other work</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recvBufferSize</td><td>Optional socket receive buffer size (<span class="tt">SO_RCVBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendBufferSize</td><td>Optional socket send buffer size (<span class="tt">SO_SNDBUF</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalBufferSize</td><td>Optional internal buffer for high-level reads </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soRecvTimeoutMillis</td><td>Receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soSendTimeoutMillis</td><td>Send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds; <span class="tt">-1</span> disables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tcpNoDelay</td><td>Whether to disable Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>); default: <span class="tt">true</span> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepAlive</td><td>Whether to enable TCP keep-alive (<span class="tt">SO_KEEPALIVE</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td>Whether to set the accepted socket to non-blocking mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">std::optional&lt;<a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>&gt;</span> — a connected and configured <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> on success, or <span class="tt">std::nullopt</span> on timeout</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the server socket is invalid or <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> fails for other reasons</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Server socket must be valid, bound, and listening </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Returns <span class="tt">std::nullopt</span> if no client connects in time, or a valid <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> if one does</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a>, <a class="el" href="group__socketopts.html#ga7829c558cb7bf5e0a46d882df82acc19" title="Get the logical timeout (in milliseconds) for accept operations.">getSoTimeout()</a>, tryAccept(int), <a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a>, <a class="el" href="#ga4cc6cc771e29a9d1964cb8b351262318" title="Accepts a TCP client connection, configures the socket, and returns a high-level Socket object.">acceptBlocking()</a>, <a class="el" href="#ga61c1904213b0971817ec917fd2a01ccf" title="Waits for the server socket to become ready to accept an incoming connection.">waitReady()</a> </dd></dl>

</div>
</div>
<a id="ga61c1904213b0971817ec917fd2a01ccf" name="ga61c1904213b0971817ec917fd2a01ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61c1904213b0971817ec917fd2a01ccf">&#9670;&#160;</a></span>waitReady() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ServerSocket::waitReady </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the server socket to become ready to accept an incoming connection. </p>
<p>This method blocks or polls until the server socket becomes readable, indicating that a new client is attempting to connect. It is used internally by <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> and <span class="tt"><a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a></span>, but can also be used directly in custom event loops or multiplexed servers.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md829"></a>
Platform Behavior</h3>
<ul>
<li><b>POSIX:</b> Uses <span class="tt">poll()</span> to monitor readiness, avoiding the <span class="tt">FD_SETSIZE</span> constraint imposed by <span class="tt">select()</span>.</li>
<li><b>Windows:</b> Uses <span class="tt">select()</span> to ensure compatibility with all socket types.<ul>
<li>The socket descriptor must be less than <span class="tt">FD_SETSIZE</span> (typically 64 on Windows).</li>
<li>If the descriptor exceeds <span class="tt">FD_SETSIZE</span>, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown to prevent undefined behavior.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md830"></a>
Timeout Semantics</h3>
<ul>
<li><span class="tt">timeoutMillis &lt; 0</span>: Blocks indefinitely until a connection attempt is ready.</li>
<li><span class="tt">timeoutMillis == 0</span>: Performs a non-blocking poll and returns immediately.</li>
<li><span class="tt">timeoutMillis &gt; 0</span>: Waits up to the specified number of milliseconds.</li>
<li>If <span class="tt">timeoutMillis</span> is not provided, the socket's logical timeout (<span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html#a21ecaaf4b757a2dd9cee37231381706f" title="Timeout for accept(); -1 = no timeout, 0 = poll, &gt;0 = timeout in milliseconds.">_soTimeoutMillis</a></span>) is used.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This method does <b>not</b> rely on or modify kernel-level timeouts (e.g., <span class="tt">SO_RCVTIMEO</span>). It uses event polling (<span class="tt">poll()</span> or <span class="tt">select()</span>) for logical timeout behavior.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="autotoc_md831"></a>
Thread Safety</h3>
<p>This method is thread-safe <b>as long as the server socket is not concurrently closed or reconfigured.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Optional timeout in milliseconds. If omitted, the socket's <span class="tt">SO_TIMEOUT</span> is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket is ready to accept a connection, <span class="tt">false</span> if the timeout expired.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The server socket is not initialized (<span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>)</li>
<li>A system-level polling error occurs</li>
<li>The socket descriptor exceeds platform limits (<span class="tt">FD_SETSIZE</span>) on Windows</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a> Accepts a new incoming connection </dd>
<dd>
<a class="el" href="#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a> Non-blocking variant of <span class="tt"><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> </dd>
<dd>
<a class="el" href="group__socketopts.html#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a> Sets the default timeout used by this method </dd>
<dd>
<a class="el" href="group__socketopts.html#ga7829c558cb7bf5e0a46d882df82acc19" title="Get the logical timeout (in milliseconds) for accept operations.">getSoTimeout()</a> Retrieves the current logical timeout value </dd></dl>

</div>
</div>
<a id="ga6b39b1375048cc167409b5b513c3ad8c" name="ga6b39b1375048cc167409b5b513c3ad8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b39b1375048cc167409b5b513c3ad8c">&#9670;&#160;</a></span>waitReady() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Socket::waitReady </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>forWrite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the socket to become ready for reading or writing. </p>
<p>This method performs a blocking or timed wait until the socket is ready for either reading or writing, depending on the <span class="tt">forWrite</span> parameter. Internally, it uses the <span class="tt">select()</span> system call to monitor readiness.</p>
<p>The timeout is specified in milliseconds. A negative timeout value (e.g., <span class="tt">-1</span>) causes the method to wait indefinitely until the socket becomes ready. A timeout of <span class="tt">0</span> performs a non-blocking poll.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md974"></a>
Implementation Notes</h3>
<ul>
<li>Internally uses <span class="tt">select()</span> on both POSIX and Windows platforms.</li>
<li>On POSIX, the socket descriptor must be <b>less than <span class="tt">FD_SETSIZE</span></b> (typically 1024). If the descriptor exceeds this limit, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> is thrown.</li>
<li>On Windows, the first parameter to <span class="tt">select()</span> is ignored and always set to 0.</li>
<li>This method works for both blocking and non-blocking sockets.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md975"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"><span class="keywordflow">if</span> (sock.waitReady(<span class="keyword">false</span>, 5000)) {</div>
<div class="line">    std::string msg = sock.read&lt;std::string&gt;();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">&quot;\\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md976"></a>
Protocol Behavior</h3>
<ul>
<li><span class="tt">forWrite == false</span>: Waits for the socket to be readable (e.g., data available).</li>
<li><span class="tt">forWrite == true</span>: Waits for the socket to be writable (e.g., buffer space available).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">forWrite</td><td>If true, waits for the socket to become writable; if false, waits for it to be readable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Timeout in milliseconds. Use <span class="tt">-1</span> for infinite wait, or <span class="tt">0</span> for non-blocking polling.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The socket is ready for I/O. </td></tr>
    <tr><td class="paramname">false</td><td>The timeout expired before the socket became ready.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid (<span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>)</li>
<li>The socket descriptor exceeds <span class="tt">FD_SETSIZE</span> (POSIX only)</li>
<li>A system error occurs during polling</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method uses the legacy <span class="tt">select()</span> system call, which is portable but has limitations:<br  />
<ul>
<li>On POSIX systems, it cannot monitor descriptors ≥ <span class="tt">FD_SETSIZE</span> (usually 1024)<br  />
</li>
<li><span class="tt">fd_set</span> is a static bitset, and overflow causes undefined behavior<br  />
</li>
<li><span class="tt">select()</span> scales poorly with large socket sets<br  />
<br  />
<b>Alternatives:</b><br  />
</li>
<li>On POSIX: <span class="tt">poll()</span> (removes FD_SETSIZE limit, cleaner API)<br  />
</li>
<li>On Linux: <span class="tt">epoll</span> (scales to thousands of fds)<br  />
</li>
<li>On BSD/macOS: <span class="tt">kqueue</span> (efficient and feature-rich)<br  />
</li>
<li>On Windows: <span class="tt">WSAPoll()</span> (requires Windows Vista+), or I/O Completion Ports for async<br  />
<br  />
These alternatives are better suited for server-side multiplexing and event-driven designs. For single-socket or per-connection waiting, <span class="tt">select()</span> remains simple and widely compatible.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>setBlocking() To configure blocking/non-blocking mode </dd>
<dd>
<a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read()</a> For reading data once the socket is ready </dd>
<dd>
<a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a> For writing data once the socket is ready </dd>
<dd>
FD_SETSIZE System-defined maximum descriptor index for <span class="tt">select()</span> </dd></dl>

</div>
</div>
<a id="ga8b952bd8912694754bb34ab763aa8daa" name="ga8b952bd8912694754bb34ab763aa8daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b952bd8912694754bb34ab763aa8daa">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Socket::write </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends data to the socket using a single, best-effort write operation. </p>
<p>Attempts to write up to <span class="tt">message.size()</span> bytes from the given <span class="tt">std::string_view</span> to the connected socket. This method may return before all data is sent, depending on socket state, system buffer availability, and platform behavior. It performs exactly one <span class="tt">send()</span> call and does <b>not</b> retry if the write is partial.</p>
<p>This is the fundamental low-level output method. For complete delivery guarantees, use <span class="tt"><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a></span> or <span class="tt"><a class="el" href="#ga964bb0e901179bc5eac126d77b0590eb" title="Writes the full payload with a total timeout across all retries.">writeWithTotalTimeout()</a></span> instead.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md943"></a>
Implementation Details</h3>
<ul>
<li>Performs a single call to <span class="tt">send()</span> (platform-specific: <span class="tt">send()</span> or <span class="tt">send_s()</span> on Windows)</li>
<li>Supports binary data, including embedded null bytes (<span class="tt">\0</span>)</li>
<li>Returns the number of bytes actually written (may be less than <span class="tt">message.size()</span>)</li>
<li>This method does not retry; for guaranteed delivery use <a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md944"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line">std::string payload = <span class="stringliteral">&quot;POST /data HTTP/1.1\r\n\r\n&quot;</span>;</div>
<div class="line">std::size_t sent = sock.write(payload);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (sent &lt; payload.size()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Partial write: sent &quot;</span> &lt;&lt; sent &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; payload.size() &lt;&lt; <span class="stringliteral">&quot; bytes\n&quot;</span>;</div>
<div class="line">    <span class="comment">// Handle retries or buffering as needed</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The data to send. Can contain binary content, including null characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually written to the socket. May be less than <span class="tt">message.size()</span> for partial writes.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid, closed, or unconnected (<span class="tt">ENOTCONN</span>, <span class="tt">EBADF</span>)</li>
<li>A network error occurs (<span class="tt">ECONNRESET</span>, <span class="tt">ENETDOWN</span>, <span class="tt">EPIPE</span>)</li>
<li>The operation would block on a full buffer in non-blocking mode (<span class="tt">EWOULDBLOCK</span>)</li>
<li>A system-level error occurs (<span class="tt">EINTR</span>, <span class="tt">EINVAL</span>, etc.)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>[[nodiscard]] is applied to enforce that the return value must be checked. Ignoring the result may lead to silent data loss if only part of the data was sent. Always compare against <span class="tt">message.size()</span> to detect partial delivery.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a> For guaranteed delivery via retries </dd>
<dd>
<a class="el" href="#ga964bb0e901179bc5eac126d77b0590eb" title="Writes the full payload with a total timeout across all retries.">writeWithTotalTimeout()</a> For deadline-bounded full writes </dd>
<dd>
<a class="el" href="#gab4484254fc3c113a373718198c382dd9" title="Writes up to len bytes from a raw memory buffer in a single send call.">writeFrom()</a> For zero-copy buffer-based sending </dd>
<dd>
<a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a> For vectorized scatter/gather writes </dd>
<dd>
<a class="el" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a> To configure non-blocking socket behavior </dd>
<dd>
<a class="el" href="group__socketopts.html#ga7107a9da459b00bf39ec2fe4d3e83396" title="Sets the socket send timeout (SO_SNDTIMEO) in milliseconds.">setSoSendTimeout()</a> To configure <a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write</a> timeouts </dd></dl>

</div>
</div>
<a id="gad1803ae12c1562ec09c28d19c1067914" name="gad1803ae12c1562ec09c28d19c1067914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1803ae12c1562ec09c28d19c1067914">&#9670;&#160;</a></span>writeAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Socket::writeAll </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the entire contents of a message to the socket, retrying as needed. </p>
<p>Ensures that the entire <span class="tt">message</span> is transmitted by repeatedly invoking the low-level <span class="tt"><a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a></span> method to handle partial writes. This method blocks until all data is successfully sent, the connection is lost, or an error occurs. It is suitable for protocols or data formats that require full delivery of fixed-size payloads, headers, or serialized objects.</p>
<p>Unlike <span class="tt"><a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a></span>, which may send only part of the input in a single call, this method transparently retries until all bytes are written, making it reliable for complete transmission scenarios (e.g., HTTP requests, framed packets, serialized data).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md945"></a>
Implementation Details</h3>
<ul>
<li>Uses <span class="tt"><a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a></span> internally for each chunk</li>
<li>Tracks remaining bytes and offset for partial sends</li>
<li>Retries automatically until <span class="tt">message.size()</span> bytes are sent</li>
<li>Blocks if necessary (unless socket is configured as non-blocking)</li>
<li>Binary-safe: supports null bytes and non-text data</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md946"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line">std::string msg = <span class="stringliteral">&quot;POST /data HTTP/1.1\r\nContent-Length: 42\r\n\r\n...&quot;</span>;</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    std::size_t sent = sock.writeAll(msg);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully sent all &quot;</span> &lt;&lt; sent &lt;&lt; <span class="stringliteral">&quot; bytes\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>&amp; ex) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to send full message: &quot;</span> &lt;&lt; ex.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The message to send in full. May contain binary or textual content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes written. Will always equal <span class="tt">message.size()</span> on success.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid or not connected (<span class="tt">ENOTCONN</span>, <span class="tt">EBADF</span>)</li>
<li>The connection is closed during transmission</li>
<li>A network error occurs (<span class="tt">ECONNRESET</span>, <span class="tt">ENETDOWN</span>, <span class="tt">EPIPE</span>, etc.)</li>
<li>A socket timeout is triggered (<span class="tt">SO_SNDTIMEO</span>)</li>
<li>A system-level failure interrupts transmission</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method will block until all data is sent or an error/timeout occurs. For non-blocking or time-bounded writes, use <span class="tt"><a class="el" href="#ga964bb0e901179bc5eac126d77b0590eb" title="Writes the full payload with a total timeout across all retries.">writeWithTotalTimeout()</a></span>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a> For a single-attempt best-effort <a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write</a> </dd>
<dd>
<a class="el" href="#ga964bb0e901179bc5eac126d77b0590eb" title="Writes the full payload with a total timeout across all retries.">writeWithTotalTimeout()</a> For full delivery under time constraints </dd>
<dd>
<a class="el" href="group__socketopts.html#ga7107a9da459b00bf39ec2fe4d3e83396" title="Sets the socket send timeout (SO_SNDTIMEO) in milliseconds.">setSoSendTimeout()</a> To configure <a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write</a> timeouts </dd>
<dd>
<a class="el" href="group__socketopts.html#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a> To avoid blocking behavior </dd>
<dd>
<a class="el" href="#gab1e4f32614be9a3609820f75dbcb4fc2" title="Indicates whether the socket has been successfully connected to a remote host.">isConnected()</a> To check socket status before writing </dd></dl>

</div>
</div>
<a id="ga16bb8c36a3fd9a3a97a0d4f5d5036550" name="ga16bb8c36a3fd9a3a97a0d4f5d5036550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16bb8c36a3fd9a3a97a0d4f5d5036550">&#9670;&#160;</a></span>writeAtMostWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writeAtMostWithTimeout </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a best-effort write with a total timeout. </p>
<p>Waits up to <span class="tt">timeoutMillis</span> milliseconds for the socket to become writable, then attempts a single <span class="tt">send()</span> operation to write up to <span class="tt">data.size()</span> bytes. This method does not retry on partial writes and is designed for time-sensitive, latency-focused applications.</p>
<p>This is a timeout-aware counterpart to <span class="tt"><a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a></span> that returns early in the event of timeout or connection closure. Use this when you need responsiveness rather than guaranteed delivery.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md957"></a>
Implementation Details</h3>
<ul>
<li>Calls <span class="tt">waitReady(true, timeoutMillis)</span> to wait for socket writability.</li>
<li>If writable, performs one <span class="tt">send()</span> call.</li>
<li>Returns the number of bytes successfully written (which may be less than <span class="tt">data.size()</span>).</li>
<li>Returns 0 if the connection is closed before any data is written.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md958"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::string payload = <span class="stringliteral">&quot;POST /data&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    std::size_t sent = sock.writeAtMostWithTimeout(payload, 500); <span class="comment">// wait up to 500 ms</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sent &quot;</span> &lt;&lt; sent &lt;&lt; <span class="stringliteral">&quot; bytes.\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketTimeoutException.html">SocketTimeoutException</a>&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Write timed out: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> SocketException&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Write error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Maximum time to wait for writability, in milliseconds:<ul>
<li>&gt; 0: Wait up to the given duration</li>
<li>0: Poll immediately (non-blocking)</li>
<li>&lt; 0: Invalid; throws exception</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written (may be 0 if the socket was closed or data not sent).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If the socket does not become writable within <span class="tt">timeoutMillis</span>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><span class="tt">send()</span> fails with a network or system error</li>
<li>The socket is closed or invalid</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a single-attempt, low-latency write. Use <span class="tt"><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a></span> or <span class="tt"><a class="el" href="#ga964bb0e901179bc5eac126d77b0590eb" title="Writes the full payload with a total timeout across all retries.">writeWithTotalTimeout()</a></span> for guaranteed delivery with retries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a> To send full content regardless of time </dd>
<dd>
<a class="el" href="#ga964bb0e901179bc5eac126d77b0590eb" title="Writes the full payload with a total timeout across all retries.">writeWithTotalTimeout()</a> To retry until timeout expires </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a> For timeout-specific error classification </dd></dl>

</div>
</div>
<a id="gab4484254fc3c113a373718198c382dd9" name="gab4484254fc3c113a373718198c382dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4484254fc3c113a373718198c382dd9">&#9670;&#160;</a></span>writeFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writeFrom </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes up to <span class="tt">len</span> bytes from a raw memory buffer in a single send call. </p>
<p>This method sends data directly from a raw memory pointer using a best-effort write. It may write fewer bytes than requested, depending on socket buffer availability. It is the low-level counterpart to <span class="tt">write(std::string_view)</span> and avoids constructing or copying into strings.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md959"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">const</span> uint8_t buffer[] = { 0x01, 0x02, 0x03 };</div>
<div class="line">std::size_t sent = sock.writeFrom(buffer, <span class="keyword">sizeof</span>(buffer));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the memory to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes successfully written (can be &lt; len).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid</li>
<li>send() fails due to a network error</li>
<li>Connection is closed</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method does not guarantee full delivery. Use <span class="tt"><a class="el" href="#ga686c95af72f4193d1a7c6dd6e658e4ba" title="Writes all bytes from a raw memory buffer, retrying until complete.">writeFromAll()</a></span> for that.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a> For std::string_view interface </dd>
<dd>
<a class="el" href="#ga686c95af72f4193d1a7c6dd6e658e4ba" title="Writes all bytes from a raw memory buffer, retrying until complete.">writeFromAll()</a> To guarantee full transmission </dd>
<dd>
<a class="el" href="#gac2bfca99305ede78697fc0b39fbbeed8" title="Reads available data from the socket into the provided buffer.">readInto()</a> For symmetric <a class="el" href="#gaa7498d51b547b52699055bdb16b9d68b" title="Reads a fixed-size, trivially copyable object of type T from the socket.">read</a> into raw buffer </dd></dl>

</div>
</div>
<a id="ga686c95af72f4193d1a7c6dd6e658e4ba" name="ga686c95af72f4193d1a7c6dd6e658e4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga686c95af72f4193d1a7c6dd6e658e4ba">&#9670;&#160;</a></span>writeFromAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writeFromAll </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all bytes from a raw memory buffer, retrying until complete. </p>
<p>This method repeatedly calls <span class="tt">send()</span> until the full <span class="tt">len</span> bytes of the buffer are successfully transmitted. It guarantees that all bytes are written, or throws an exception on failure. This is the raw-buffer equivalent of <span class="tt"><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a></span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md960"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::vector&lt;uint8_t&gt; payload = generateMessage();</div>
<div class="line">sock.writeFromAll(payload.data(), payload.size());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the binary buffer to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to transmit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes written (equal to <span class="tt">len</span> on success).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid</li>
<li>send() fails</li>
<li>The connection is closed prematurely</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method blocks until all data is sent or an error occurs. For partial/best-effort sends, use <span class="tt"><a class="el" href="#gab4484254fc3c113a373718198c382dd9" title="Writes up to len bytes from a raw memory buffer in a single send call.">writeFrom()</a></span> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab4484254fc3c113a373718198c382dd9" title="Writes up to len bytes from a raw memory buffer in a single send call.">writeFrom()</a> For best-effort version </dd>
<dd>
<a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a> For string-based equivalent </dd>
<dd>
<a class="el" href="#gabb8631cb8242b3573a2679da0b6a4f4d" title="Reads exactly len bytes into the given buffer (looped recv).">readIntoExact()</a> For guaranteed binary reads </dd></dl>

</div>
</div>
<a id="ga81f896d90e08fbfb1d63f1aabb21c970" name="ga81f896d90e08fbfb1d63f1aabb21c970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81f896d90e08fbfb1d63f1aabb21c970">&#9670;&#160;</a></span>writePrefixed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::Socket::writePrefixed </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>payload</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a length-prefixed payload using a fixed-size integral prefix. </p>
<p>Sends a message that consists of a length prefix followed by the actual payload. The prefix is encoded in <b>network byte order</b> to ensure cross-platform compatibility.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md947"></a>
Implementation Details</h3>
<ul>
<li>The length of the payload is cast to type <span class="tt">T</span> (must not exceed its maximum value)</li>
<li>The prefix is converted to <b>network byte order</b> using <span class="tt"><a class="el" href="namespacejsocketpp_1_1net.html#a30e0ea56a20c62070f079482d8cabfa5" title="Converts a 16-bit unsigned integer from host to network byte order.">net::toNetwork()</a></span></li>
<li>The prefix is copied into a properly aligned buffer to avoid undefined behavior</li>
<li>The prefix is written first, followed immediately by the payload</li>
<li>This overload accepts any <span class="tt">std::string_view</span>, allowing use with string literals, slices, or raw binary buffers</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md948"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6da94c322a3ed5f85efd26a7fbadbe0a">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 8080);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line">std::string_view msg = <span class="stringliteral">&quot;Hello, world!&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send message with 32-bit length prefix</span></div>
<div class="line">std::size_t totalBytes = sock.writePrefixed&lt;uint32_t&gt;(msg);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Sent &quot;</span> &lt;&lt; totalBytes &lt;&lt; <span class="stringliteral">&quot; bytes\\n&quot;</span>;</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md949"></a>
Protocol Format</h3>
<pre>
+----------------+----------------------+
| Length (T)     | Payload (n bytes)    |
+----------------+----------------------+
|&lt;- sizeof(T) -&gt;|&lt;---- length -------&gt;|
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unsigned integral type used for the length prefix (e.g., <span class="tt">uint32_t</span>). Must be trivially copyable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>The payload data to send. The length of this view will be encoded as the prefix and must not exceed the maximum representable value of type <span class="tt">T</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes written (prefix + payload).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>Writing the prefix or payload fails</li>
<li>Payload size exceeds the maximum encodable value for type <span class="tt">T</span></li>
<li>The connection is closed or interrupted</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The prefix is automatically converted to <b>network byte order</b> using <span class="tt"><a class="el" href="namespacejsocketpp_1_1net.html#a30e0ea56a20c62070f079482d8cabfa5" title="Converts a 16-bit unsigned integer from host to network byte order.">jsocketpp::net::toNetwork()</a></span>. The receiving side must decode it using <span class="tt"><a class="el" href="#gab1aaaa6572bcf756be7bcdb801e35812" title="Reads a length-prefixed payload using a fixed-size prefix type.">readPrefixed</a>&lt;T&gt;()</span> or equivalent logic.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab1aaaa6572bcf756be7bcdb801e35812" title="Reads a length-prefixed payload using a fixed-size prefix type.">readPrefixed()</a> To decode the corresponding message </dd>
<dd>
<a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a> To <a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write</a> data without a length prefix </dd>
<dd>
<a class="el" href="namespacejsocketpp_1_1net.html#a30e0ea56a20c62070f079482d8cabfa5" title="Converts a 16-bit unsigned integer from host to network byte order.">net::toNetwork()</a> For details on byte order conversion </dd></dl>

</div>
</div>
<a id="gab0b48a69153c1ed31dd158ec7afb901c" name="gab0b48a69153c1ed31dd158ec7afb901c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0b48a69153c1ed31dd158ec7afb901c">&#9670;&#160;</a></span>writePrefixed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t jsocketpp::Socket::writePrefixed </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a binary payload prefixed with its length using a fixed-size integer type. </p>
<p>Sends a length-prefixed binary message, where the prefix is a fixed-size integral type <span class="tt">T</span> followed by a raw binary buffer. This version avoids constructing a temporary <span class="tt">std::string</span>, making it efficient for zero-copy binary protocols and high-performance I/O paths.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md950"></a>
Implementation Details</h3>
<ul>
<li>Validates that <span class="tt">len</span> fits within the range of type <span class="tt">T</span></li>
<li>Converts the prefix to <b>network byte order</b> using <span class="tt"><a class="el" href="namespacejsocketpp_1_1net.html#a30e0ea56a20c62070f079482d8cabfa5" title="Converts a 16-bit unsigned integer from host to network byte order.">net::toNetwork()</a></span></li>
<li>Sends <span class="tt">sizeof(T)</span> bytes of the length prefix</li>
<li>Sends <span class="tt">len</span> bytes of raw payload data immediately afterward</li>
<li>Uses <span class="tt"><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a></span> to ensure full delivery of both parts</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md951"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::vector&lt;uint8_t&gt; imageData = loadImage();</div>
<div class="line">sock.writePrefixed&lt;uint32_t&gt;(imageData.data(), imageData.size());</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md952"></a>
Protocol Format</h3>
<pre>
+----------------+----------------------+
| Length (T)     | Payload (n bytes)   |
+----------------+----------------------+
|&lt;- sizeof(T) -&gt;|&lt;---- len ---------&gt;|
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unsigned integral type used for the length prefix (e.g., <span class="tt">uint32_t</span>). Must be a trivially copyable type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the binary payload data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to write from <span class="tt">data</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes written (<span class="tt">sizeof(T) + len</span>).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><span class="tt">len</span> exceeds the maximum value representable by <span class="tt">T</span></li>
<li>If data is null and len &gt; 0</li>
<li>Writing the prefix or payload fails</li>
<li>Connection is closed or interrupted</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The prefix is automatically converted to <b>network byte order</b> using <span class="tt"><a class="el" href="namespacejsocketpp_1_1net.html#a30e0ea56a20c62070f079482d8cabfa5" title="Converts a 16-bit unsigned integer from host to network byte order.">jsocketpp::net::toNetwork()</a></span>. Receivers must decode it accordingly using <span class="tt"><a class="el" href="#gab1aaaa6572bcf756be7bcdb801e35812" title="Reads a length-prefixed payload using a fixed-size prefix type.">readPrefixed</a>&lt;T&gt;()</span> or equivalent.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab1aaaa6572bcf756be7bcdb801e35812" title="Reads a length-prefixed payload using a fixed-size prefix type.">readPrefixed()</a> For the corresponding deserialization method </dd>
<dd>
<a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a> For guaranteed single-buffer transmission </dd>
<dd>
writePrefixed(std::string) For the string-based variant </dd>
<dd>
<a class="el" href="namespacejsocketpp_1_1net.html#a30e0ea56a20c62070f079482d8cabfa5" title="Converts a 16-bit unsigned integer from host to network byte order.">net::toNetwork()</a> For details on byte order conversion </dd></dl>

</div>
</div>
<a id="gadf5094228dfdef090b0d49a3a9e9e78d" name="gadf5094228dfdef090b0d49a3a9e9e78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf5094228dfdef090b0d49a3a9e9e78d">&#9670;&#160;</a></span>writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writev </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::string_view &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes multiple buffers in a single system call using scatter/gather I/O. </p>
<p>This method efficiently writes multiple non-contiguous buffers to the socket using platform-specific vectorized I/O calls. It is ideal for sending structured packets, headers + body, or other segmented data without concatenating them.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md953"></a>
Implementation Details</h3>
<ul>
<li>On POSIX: uses <span class="tt"><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a></span> with <span class="tt">struct iovec[]</span></li>
<li>On Windows: uses <span class="tt">WSASend()</span> with <span class="tt">WSABUF[]</span></li>
<li>Handles up to IOV_MAX or WSABUF_MAX entries (platform limit)</li>
<li>Ensures the total byte count written is returned</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md954"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::string_view header = <span class="stringliteral">&quot;Content-Length: 12\r\n\r\n&quot;</span>;</div>
<div class="line">std::string_view body   = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">std::array&lt;std::string_view, 2&gt; segments = {header, body};</div>
<div class="line">std::size_t sent = sock.writev(segments);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>A span of string views to send as a scatter/gather I/O batch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes sent.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> is not connected</li>
<li>System I/O call fails</li>
<li>Connection is broken or interrupted</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not retry partial writes. You must manually check the return value and retry unsent segments if needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a> For single-buffer sends </dd>
<dd>
<a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a> To send all bytes in a single string </dd></dl>

</div>
</div>
<a id="ga804a69fa791fc8adb91f32ab37244a0a" name="ga804a69fa791fc8adb91f32ab37244a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804a69fa791fc8adb91f32ab37244a0a">&#9670;&#160;</a></span>writevAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writevAll </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::string_view &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all buffers fully using vectorized I/O with automatic retry on partial sends. </p>
<p>Ensures that the entire contents of all buffers in the given span are fully transmitted, retrying as needed. This is the guaranteed-delivery counterpart to <span class="tt"><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a></span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md955"></a>
Implementation Details</h3>
<ul>
<li>Uses <span class="tt"><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a></span> or <span class="tt">WSASend()</span> to send as much as possible</li>
<li>Tracks which buffers are partially sent</li>
<li>Rebuilds the buffer list on each retry to resume from the last offset</li>
<li>Stops only when all buffers are fully transmitted or an error occurs</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md956"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::array&lt;std::string_view, 3&gt; fragments = {</div>
<div class="line">    <span class="stringliteral">&quot;HTTP/1.1 200 OK\r\n&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Content-Length: 5\r\n\r\n&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">};</div>
<div class="line">sock.writevAll(fragments);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>A span of string fragments to send as a contiguous logical payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes written (equal to sum of all buffer sizes).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>A send error occurs</li>
<li>The connection is closed mid-transmission</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method guarantees full delivery, unlike <a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a>, which may send only part.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a> For single-shot scatter/gather <a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write</a> </dd>
<dd>
<a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a> For full single-buffer delivery </dd>
<dd>
<a class="el" href="#ga8b952bd8912694754bb34ab763aa8daa" title="Sends data to the socket using a single, best-effort write operation.">write()</a> For low-level single-buffer writes </dd></dl>

</div>
</div>
<a id="ga650e041e62870ef5710b0e45401e679d" name="ga650e041e62870ef5710b0e45401e679d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga650e041e62870ef5710b0e45401e679d">&#9670;&#160;</a></span>writevFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writevFrom </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes multiple raw memory regions using vectorized I/O. </p>
<p>Sends the contents of all buffers in the given span using scatter/gather I/O. This performs a single system call (<span class="tt"><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a></span> on POSIX, <span class="tt">WSASend()</span> on Windows), and may transmit fewer bytes than requested. Use <span class="tt"><a class="el" href="#ga7b3ab7a896b7fbfeba9b80672c41b236" title="Writes all raw memory regions fully using scatter/gather I/O.">writevFromAll()</a></span> for full delivery.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md965"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::array&lt;std::byte, 4&gt; header = ...;</div>
<div class="line">std::vector&lt;std::byte&gt; body = ...;</div>
<div class="line"> </div>
<div class="line">std::array&lt;BufferView, 2&gt; buffers = {</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{header.data(), header.size()},</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{body.data(), body.size()}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::size_t sent = sock.writevFrom(buffers);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>A span of <a class="el" href="structjsocketpp_1_1BufferView.html" title="Represents a raw writable memory region for scatter/gather I/O.">BufferView</a> elements (data + size). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes successfully written (can be &lt; total).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>The socket is invalid</li>
<li>sendv fails (e.g., WSA error, broken pipe)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7b3ab7a896b7fbfeba9b80672c41b236" title="Writes all raw memory regions fully using scatter/gather I/O.">writevFromAll()</a> For full-delivery retry logic </dd>
<dd>
<a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a> For string-based scatter I/O </dd></dl>

</div>
</div>
<a id="ga7b3ab7a896b7fbfeba9b80672c41b236" name="ga7b3ab7a896b7fbfeba9b80672c41b236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b3ab7a896b7fbfeba9b80672c41b236">&#9670;&#160;</a></span>writevFromAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writevFromAll </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all raw memory regions fully using scatter/gather I/O. </p>
<p>This method guarantees full delivery of all bytes across the given buffer span. Internally retries <span class="tt"><a class="el" href="#ga650e041e62870ef5710b0e45401e679d" title="Writes multiple raw memory regions using vectorized I/O.">writevFrom()</a></span> until every buffer is fully written. This is the binary-safe, zero-copy equivalent of <span class="tt"><a class="el" href="#ga804a69fa791fc8adb91f32ab37244a0a" title="Writes all buffers fully using vectorized I/O with automatic retry on partial sends.">writevAll()</a></span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md966"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::array&lt;std::byte, 8&gt; header;</div>
<div class="line">std::vector&lt;std::byte&gt; body;</div>
<div class="line"> </div>
<div class="line">std::array&lt;BufferView, 2&gt; buffers = {</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{header.data(), header.size()},</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{body.data(), body.size()}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">sock.writevFromAll(buffers);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>A span of raw buffers to send completely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes written (equal to sum of buffer sizes).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li>A socket error occurs during send</li>
<li>The connection is closed prematurely</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method blocks until completion or error. Use <span class="tt"><a class="el" href="#ga650e041e62870ef5710b0e45401e679d" title="Writes multiple raw memory regions using vectorized I/O.">writevFrom()</a></span> for best-effort, single-attempt version.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga650e041e62870ef5710b0e45401e679d" title="Writes multiple raw memory regions using vectorized I/O.">writevFrom()</a> For non-retrying variant </dd>
<dd>
<a class="el" href="#ga804a69fa791fc8adb91f32ab37244a0a" title="Writes all buffers fully using vectorized I/O with automatic retry on partial sends.">writevAll()</a> For string-view based equivalent </dd></dl>

</div>
</div>
<a id="ga3e2b5bd60122d459134cd5b0a3a27077" name="ga3e2b5bd60122d459134cd5b0a3a27077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e2b5bd60122d459134cd5b0a3a27077">&#9670;&#160;</a></span>writevFromWithTotalTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writevFromWithTotalTimeout </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="structjsocketpp_1_1BufferView.html">BufferView</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all raw memory buffers fully within a timeout using scatter I/O. </p>
<p>Sends multiple binary buffers using scatter/gather I/O, retrying partial writes as needed until all data is delivered or the specified timeout period elapses. If the timeout expires before completing the transmission, a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> is thrown.</p>
<p>This is the binary-buffer equivalent of <span class="tt"><a class="el" href="#ga8e539c866c9fcad3578f9be78cbfdaf4" title="Writes all buffers fully within a total timeout using vectorized I/O.">writevWithTotalTimeout()</a></span>, intended for use with low-level, structured protocols or custom serialization layers.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md967"></a>
Implementation Details</h3>
<ul>
<li>Enforces a wall-clock timeout using <span class="tt">std::chrono::steady_clock</span>.</li>
<li>Waits for writability using <span class="tt"><a class="el" href="#ga6b39b1375048cc167409b5b513c3ad8c" title="Waits for the socket to become ready for reading or writing.">waitReady()</a></span> before each write attempt.</li>
<li>Uses <span class="tt"><a class="el" href="#ga650e041e62870ef5710b0e45401e679d" title="Writes multiple raw memory regions using vectorized I/O.">writevFrom()</a></span> to send multiple non-contiguous memory blocks efficiently.</li>
<li>After partial writes, dynamically adjusts buffer offsets to resume transmission.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md968"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::array&lt;std::byte, 4&gt; hdr = ...;</div>
<div class="line">std::vector&lt;std::byte&gt; body = ...;</div>
<div class="line"> </div>
<div class="line">std::array&lt;BufferView, 2&gt; bufs = {</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{hdr.data(), hdr.size()},</div>
<div class="line">    <a class="code hl_struct" href="structjsocketpp_1_1BufferView.html">BufferView</a>{body.data(), body.size()}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    sock.writevFromWithTotalTimeout(bufs, 2000); <span class="comment">// must finish in 2s</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Transmission complete.\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> SocketTimeoutException&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Write timed out: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> SocketException&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Write error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>A span of <span class="tt"><a class="el" href="structjsocketpp_1_1BufferView.html" title="Represents a raw writable memory region for scatter/gather I/O.">BufferView</a></span> objects representing raw memory regions to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Total timeout duration in milliseconds across all write attempts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes written (equal to the sum of all buffer sizes on success).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If:<ul>
<li>The socket does not become writable within the remaining timeout</li>
<li>The full payload is not sent before the deadline expires</li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><span class="tt"><a class="el" href="#ga650e041e62870ef5710b0e45401e679d" title="Writes multiple raw memory regions using vectorized I/O.">writevFrom()</a></span> fails due to a system or network error</li>
<li>The socket is invalid or disconnected</li>
<li>The connection is closed during transmission</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the low-level, binary-buffer counterpart to <span class="tt"><a class="el" href="#ga8e539c866c9fcad3578f9be78cbfdaf4" title="Writes all buffers fully within a total timeout using vectorized I/O.">writevWithTotalTimeout()</a></span>. Use <span class="tt"><a class="el" href="#ga7b3ab7a896b7fbfeba9b80672c41b236" title="Writes all raw memory regions fully using scatter/gather I/O.">writevFromAll()</a></span> for unbounded full delivery.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7b3ab7a896b7fbfeba9b80672c41b236" title="Writes all raw memory regions fully using scatter/gather I/O.">writevFromAll()</a> For retrying without a timeout </dd>
<dd>
<a class="el" href="#ga8e539c866c9fcad3578f9be78cbfdaf4" title="Writes all buffers fully within a total timeout using vectorized I/O.">writevWithTotalTimeout()</a> For <span class="tt">std::string_view</span>-based variant </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a> For timeout-specific error handling </dd></dl>

</div>
</div>
<a id="ga8e539c866c9fcad3578f9be78cbfdaf4" name="ga8e539c866c9fcad3578f9be78cbfdaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e539c866c9fcad3578f9be78cbfdaf4">&#9670;&#160;</a></span>writevWithTotalTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writevWithTotalTimeout </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::string_view &gt;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all buffers fully within a total timeout using vectorized I/O. </p>
<p>Sends the contents of all buffers in the provided span using scatter/gather I/O. Retries partial sends as needed, resuming from where the last send left off. The entire operation must complete within <span class="tt">timeoutMillis</span> milliseconds or a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span> will be thrown.</p>
<p>This method guarantees that all data across all buffers will be sent in order—or none at all. It is the timeout-aware variant of <span class="tt"><a class="el" href="#ga804a69fa791fc8adb91f32ab37244a0a" title="Writes all buffers fully using vectorized I/O with automatic retry on partial sends.">writevAll()</a></span> and suitable for time-bounded, multi-buffer transmission (e.g., structured headers + body).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md963"></a>
Implementation Details</h3>
<ul>
<li>Uses <span class="tt">std::chrono::steady_clock</span> to enforce a total wall-clock timeout.</li>
<li>Waits for writability using <span class="tt">waitReady(true, remainingTime)</span> between sends.</li>
<li>Uses <span class="tt"><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a></span> to send multiple buffers in one system call.</li>
<li>After partial sends, dynamically rebuilds the buffer span to reflect unsent data.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md964"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::array&lt;std::string_view, 3&gt; parts = {</div>
<div class="line">    <span class="stringliteral">&quot;Header: &quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;value\r\n\r\n&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;Body content&quot;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    sock.writevWithTotalTimeout(parts, 1500); <span class="comment">// Must finish in 1.5 seconds</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message sent.\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> SocketTimeoutException&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Write timeout: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> SocketException&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Write failure: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Span of string views representing logically distinct memory segments to send in order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Total allowed duration in milliseconds to complete the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes sent (must equal the sum of all buffer sizes on success).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If:<ul>
<li>The socket does not become writable in time</li>
<li>The full payload is not sent before the timeout expires</li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><span class="tt"><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a></span> fails due to a system or network error</li>
<li>The socket is closed or invalid</li>
<li>The connection is interrupted during transmission</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method guarantees complete delivery of all buffers, bounded by time. Use <span class="tt"><a class="el" href="#ga804a69fa791fc8adb91f32ab37244a0a" title="Writes all buffers fully using vectorized I/O with automatic retry on partial sends.">writevAll()</a></span> for unbounded retries or <span class="tt"><a class="el" href="#gadf5094228dfdef090b0d49a3a9e9e78d" title="Writes multiple buffers in a single system call using scatter/gather I/O.">writev()</a></span> for a single attempt.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga804a69fa791fc8adb91f32ab37244a0a" title="Writes all buffers fully using vectorized I/O with automatic retry on partial sends.">writevAll()</a> For unlimited retries and guaranteed delivery </dd>
<dd>
<a class="el" href="#ga964bb0e901179bc5eac126d77b0590eb" title="Writes the full payload with a total timeout across all retries.">writeWithTotalTimeout()</a> For single-buffer full delivery under timeout </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a> To differentiate timeout from generic network errors </dd></dl>

</div>
</div>
<a id="ga964bb0e901179bc5eac126d77b0590eb" name="ga964bb0e901179bc5eac126d77b0590eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga964bb0e901179bc5eac126d77b0590eb">&#9670;&#160;</a></span>writeWithTotalTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Socket::writeWithTotalTimeout </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the full payload with a total timeout across all retries. </p>
<p>Repeatedly attempts to send the entire contents of <span class="tt">data</span>, retrying partial writes as needed. The complete operation must finish within <span class="tt">timeoutMillis</span> milliseconds or it will throw a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></span>.</p>
<p>This method ensures full delivery like <span class="tt"><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a></span>, but it is time-bounded by wall-clock time. It is suitable for real-time or responsiveness-sensitive applications where you must send everything or fail within a deadline.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md961"></a>
Implementation Details</h3>
<ul>
<li>Uses <span class="tt">std::chrono::steady_clock</span> to enforce a wall-clock deadline.</li>
<li>Calls <span class="tt">waitReady(true, remainingTime)</span> before each <span class="tt">send()</span> attempt.</li>
<li>Retries partial writes until complete or until timeout is reached.</li>
<li>Returns the total number of bytes sent (equal to <span class="tt">data.size()</span> on success).</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md962"></a>
Example Usage</h3>
<div class="fragment"><div class="line">std::string json = buildPayload();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    sock.writeWithTotalTimeout(json, 1000); <span class="comment">// Must finish in 1 second</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Payload sent.\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="classjsocketpp_1_1SocketTimeoutException.html">SocketTimeoutException</a>&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Timed out: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> SocketException&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Write error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMillis</td><td>Maximum time in milliseconds to send the full payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes written (equals <span class="tt">data.size()</span> on success).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a></td><td>If:<ul>
<li>The socket does not become writable in time</li>
<li>The full payload could not be sent before the deadline</li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If:<ul>
<li><span class="tt">send()</span> fails due to a network or system error</li>
<li>The socket is closed or invalid</li>
<li>The connection is closed during the operation</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method guarantees full delivery or throws. Use <span class="tt"><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a></span> for unbounded retries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad1803ae12c1562ec09c28d19c1067914" title="Writes the entire contents of a message to the socket, retrying as needed.">writeAll()</a> For guaranteed delivery without time constraint </dd>
<dd>
<a class="el" href="#ga16bb8c36a3fd9a3a97a0d4f5d5036550" title="Performs a best-effort write with a total timeout.">writeAtMostWithTimeout()</a> For single-shot, best-effort delivery </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketTimeoutException.html" title="Exception class for socket operations that time out.">SocketTimeoutException</a> To catch time-limit-specific failures </dd></dl>

</div>
</div>
<a id="ga06c96fc5f87b1cde4c12cb6175b8a129" name="ga06c96fc5f87b1cde4c12cb6175b8a129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06c96fc5f87b1cde4c12cb6175b8a129">&#9670;&#160;</a></span>~ServerSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ServerSocket::~ServerSocket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor that automatically closes the server socket and releases all associated resources. </p>
<p>This destructor ensures proper cleanup of system resources when a <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> object is destroyed:</p><ul>
<li>Closes the underlying socket handle/descriptor if still open</li>
<li>Frees any allocated memory for address structures</li>
<li>Releases system socket resources</li>
<li>Sets internal state to closed/invalid</li>
</ul>
<p>The destructor is marked <span class="tt">noexcept</span> to prevent exception propagation during stack unwinding, as per C++ best practices. Any errors that occur during cleanup are logged but not thrown.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md745"></a>
Resource Cleanup</h3>
<ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> handle is closed via <a class="el" href="#ga0245d40096ca089255c67303eebf17e6" title="Closes the server socket and releases its associated system resources.">close()</a></li>
<li>Address info structures (_srvAddrInfo) are freed</li>
<li>Internal buffers and state are reset</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md746"></a>
Thread Safety</h3>
<ul>
<li>This destructor is <b>not thread-safe</b></li>
<li>The <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> must not be used by other threads during destruction</li>
<li>If multiple threads might access the socket during shutdown, external synchronization is required</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>Do not destroy a <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> while other threads are using it</li>
<li>Ensure all client operations are complete before destruction</li>
<li>Use proper synchronization if the socket might be accessed during shutdown</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0245d40096ca089255c67303eebf17e6" title="Closes the server socket and releases its associated system resources.">close()</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> </dd></dl>

</div>
</div>
<a id="gafa933f0914d99522c857b30f64c9ce32" name="gafa933f0914d99522c857b30f64c9ce32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa933f0914d99522c857b30f64c9ce32">&#9670;&#160;</a></span>~Socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket::~Socket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs the <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object, closing connections and freeing resources. </p>
<p>This destructor ensures proper cleanup of all resources owned by the <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>:</p><ul>
<li>Closes the socket file descriptor if still open</li>
<li>Frees any allocated address information structures</li>
<li>Releases internal buffers</li>
</ul>
<p>The destructor is marked noexcept to prevent exception propagation during stack unwinding, as per C++ best practices. Any errors that occur during cleanup (e.g., socket closure failures) are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This destructor is thread-safe with respect to other <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> instances but not with concurrent operations on the same <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga75ee749264ccbcfc4dfbf5442e55dcb8" title="Closes the socket connection and releases associated resources.">close()</a> For explicit connection closure before destruction </dd>
<dd>
<a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown()</a> For controlled <a class="el" href="#gaacbacf59cf8239e66c80c66a09243ec3" title="Shutdown specific communication aspects of the socket.">shutdown</a> of specific socket operations </dd></dl>

</div>
</div>
<a name="doc-friend-members" id="doc-friend-members"></a><h2 id="header-doc-friend-members" class="groupheader">Friends</h2>
<a id="ga11a8bb11feaafab939278a8285afa567" name="ga11a8bb11feaafab939278a8285afa567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11a8bb11feaafab939278a8285afa567">&#9670;&#160;</a></span>ServerSocket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ServerSocket</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grants <a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> access to private members. </p>
<p><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> needs access to <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a>'s private members during accept() operations to:</p><ul>
<li>Initialize client <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> objects directly with the accepted socket descriptor</li>
<li>Set address information for the connected client</li>
<li>Configure internal buffers</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">ServerSocket::accept()</a> Creates new <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> instances from accepted connections </dd>
<dd>
Socket(SOCKET,const sockaddr_storage&amp;,socklen_t,std::size_t,std::size_t,std::size_t) Protected constructor used by accept() </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
