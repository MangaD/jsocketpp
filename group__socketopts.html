<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>jsocketpp: Socket Options</title>
<link rel="icon" href="logo55px.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo55px.png"/></td>
  <td id="projectalign">
   <div id="projectname">jsocketpp<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A cross-platform C++20 socket library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__socketopts.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Socket Options <div class="ingroups"><a class="el" href="group__jsocketpp.html">jsocketpp: C++20 cross-platform socket library</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Low-level socket configuration options exposed via the <span class="tt">Socket</span> and related classes.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Socket Options:</div>
<div class="dyncontent">
<div class="center"><img src="group__socketopts.png" border="0" usemap="#agroup____socketopts" loading="lazy" alt=""/></div>
<map name="agroup____socketopts" id="agroup____socketopts">
<area shape="rect" href="group__jsocketpp.html" title="All core classes and functions of the jsocketpp networking library." alt="" coords="5,5,182,50"/>
<area shape="rect" title="Low&#45;level socket configuration options exposed via the Socket and related classes." alt="" coords="230,14,348,42"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jsocketpp_3A_3ASocketOptions" id="r_jsocketpp_3A_3ASocketOptions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsocketpp_1_1SocketOptions.html">jsocketpp::SocketOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public base class for raw socket option access via <span class="tt">setsockopt()</span> and <span class="tt">getsockopt()</span>.  <a href="classjsocketpp_1_1SocketOptions.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad11b9d3378834eab9c28e32e70fc249a" id="r_gad11b9d3378834eab9c28e32e70fc249a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad11b9d3378834eab9c28e32e70fc249a">jsocketpp::MulticastSocket::getTimeToLive</a> () const</td></tr>
<tr class="memdesc:gad11b9d3378834eab9c28e32e70fc249a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current default multicast TTL / hop limit cached on this socket.  <br /></td></tr>
<tr class="memitem:ga0f0ab03631b48add0e1b8845e553ebab" id="r_ga0f0ab03631b48add0e1b8845e553ebab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f0ab03631b48add0e1b8845e553ebab">jsocketpp::MulticastSocket::getLoopbackMode</a> () const</td></tr>
<tr class="memdesc:ga0f0ab03631b48add0e1b8845e553ebab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current multicast loopback mode cached on this socket.  <br /></td></tr>
<tr class="memitem:ga2087f337f22de16821132208b94b1441" id="r_ga2087f337f22de16821132208b94b1441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2087f337f22de16821132208b94b1441">jsocketpp::ServerSocket::setSoTimeout</a> (const int timeoutMillis)</td></tr>
<tr class="memdesc:ga2087f337f22de16821132208b94b1441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the logical timeout (in milliseconds) for accepting client connections.  <br /></td></tr>
<tr class="memitem:ga7829c558cb7bf5e0a46d882df82acc19" id="r_ga7829c558cb7bf5e0a46d882df82acc19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7829c558cb7bf5e0a46d882df82acc19">jsocketpp::ServerSocket::getSoTimeout</a> () const noexcept</td></tr>
<tr class="memdesc:ga7829c558cb7bf5e0a46d882df82acc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the logical timeout (in milliseconds) for accept operations.  <br /></td></tr>
<tr class="memitem:gad113886a7cc6100e5ef2c25ea504696e" id="r_gad113886a7cc6100e5ef2c25ea504696e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad113886a7cc6100e5ef2c25ea504696e">jsocketpp::ServerSocket::isPassiveSocket</a> () const noexcept override</td></tr>
<tr class="memdesc:gad113886a7cc6100e5ef2c25ea504696e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies this socket as a passive (listening) socket.  <br /></td></tr>
<tr class="memitem:ga9e263722ea800db82c34769d8f49be3a" id="r_ga9e263722ea800db82c34769d8f49be3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e263722ea800db82c34769d8f49be3a">jsocketpp::SocketOptions::SocketOptions</a> ()=delete</td></tr>
<tr class="memdesc:ga9e263722ea800db82c34769d8f49be3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (deleted) for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a> base class.  <br /></td></tr>
<tr class="memitem:gab6fea2ad1b8aac819f3726ab8846527b" id="r_gab6fea2ad1b8aac819f3726ab8846527b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab6fea2ad1b8aac819f3726ab8846527b">jsocketpp::SocketOptions::SocketOptions</a> (const <a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a> sock) noexcept</td></tr>
<tr class="memdesc:gab6fea2ad1b8aac819f3726ab8846527b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the socket option interface with a specific socket descriptor.  <br /></td></tr>
<tr class="memitem:ga74663905817ec41a5b3a7f3d7a16550d" id="r_ga74663905817ec41a5b3a7f3d7a16550d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga74663905817ec41a5b3a7f3d7a16550d">jsocketpp::SocketOptions::~SocketOptions</a> ()=default</td></tr>
<tr class="memdesc:ga74663905817ec41a5b3a7f3d7a16550d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for safe polymorphic destruction.  <br /></td></tr>
<tr class="memitem:ga64de913573af3ff3cb6f40bcb71c1ba0" id="r_ga64de913573af3ff3cb6f40bcb71c1ba0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga64de913573af3ff3cb6f40bcb71c1ba0">jsocketpp::SocketOptions::SocketOptions</a> (const SocketOptions &amp;)=delete</td></tr>
<tr class="memdesc:ga64de913573af3ff3cb6f40bcb71c1ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (deleted) for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>.  <br /></td></tr>
<tr class="memitem:ga244a62ac8b74854e58066a242976793d" id="r_ga244a62ac8b74854e58066a242976793d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga244a62ac8b74854e58066a242976793d">jsocketpp::SocketOptions::SocketOptions</a> (SocketOptions &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ga244a62ac8b74854e58066a242976793d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>.  <br /></td></tr>
<tr class="memitem:gacd5f26363d219e39f4a8fbce1bec758a" id="r_gacd5f26363d219e39f4a8fbce1bec758a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd5f26363d219e39f4a8fbce1bec758a">jsocketpp::SocketOptions::operator=</a> (const <a class="el" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> &amp;)=delete</td></tr>
<tr class="memdesc:gacd5f26363d219e39f4a8fbce1bec758a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator (deleted) for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>.  <br /></td></tr>
<tr class="memitem:gac396d98978063f302938aa9ee80bf634" id="r_gac396d98978063f302938aa9ee80bf634"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac396d98978063f302938aa9ee80bf634">jsocketpp::SocketOptions::operator=</a> (<a class="el" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:gac396d98978063f302938aa9ee80bf634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>.  <br /></td></tr>
<tr class="memitem:gaced4c6dc799564ece9ce4e6766b1d794" id="r_gaced4c6dc799564ece9ce4e6766b1d794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaced4c6dc799564ece9ce4e6766b1d794">jsocketpp::SocketOptions::getSocketFd</a> () const noexcept</td></tr>
<tr class="memdesc:gaced4c6dc799564ece9ce4e6766b1d794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the native socket handle (file descriptor or OS-level handle).  <br /></td></tr>
<tr class="memitem:ga1b7061a0f4d13e8d33d3065b8ad4998b" id="r_ga1b7061a0f4d13e8d33d3065b8ad4998b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b">jsocketpp::SocketOptions::setOption</a> (int level, int optName, int value)</td></tr>
<tr class="memdesc:ga1b7061a0f4d13e8d33d3065b8ad4998b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a low-level socket option on the underlying socket.  <br /></td></tr>
<tr class="memitem:ga04df6377e302cc0cedff070517021950" id="r_ga04df6377e302cc0cedff070517021950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga04df6377e302cc0cedff070517021950">jsocketpp::SocketOptions::setOption</a> (int level, int optName, const void *value, socklen_t len)</td></tr>
<tr class="memdesc:ga04df6377e302cc0cedff070517021950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a low-level socket option using a structured or binary value.  <br /></td></tr>
<tr class="memitem:ga6a5264b995eb2a1143f45c5de6ad92c3" id="r_ga6a5264b995eb2a1143f45c5de6ad92c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6a5264b995eb2a1143f45c5de6ad92c3">jsocketpp::SocketOptions::getOption</a> (int level, int optName) const</td></tr>
<tr class="memdesc:ga6a5264b995eb2a1143f45c5de6ad92c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current value of a low-level socket option.  <br /></td></tr>
<tr class="memitem:ga9c068d958d55e865948b2015c82450a7" id="r_ga9c068d958d55e865948b2015c82450a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9c068d958d55e865948b2015c82450a7">jsocketpp::SocketOptions::getOption</a> (int level, int optName, void *result, socklen_t *len) const</td></tr>
<tr class="memdesc:ga9c068d958d55e865948b2015c82450a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a socket option into a structured or binary buffer.  <br /></td></tr>
<tr class="memitem:gab358ea7ed49e95717b1e9438251b3d9a" id="r_gab358ea7ed49e95717b1e9438251b3d9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab358ea7ed49e95717b1e9438251b3d9a">jsocketpp::SocketOptions::setReuseAddress</a> (bool on)</td></tr>
<tr class="memdesc:gab358ea7ed49e95717b1e9438251b3d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the <span class="tt">SO_REUSEADDR</span> socket option.  <br /></td></tr>
<tr class="memitem:ga8e8783ada3142cd6c3b275e01b7b12f2" id="r_ga8e8783ada3142cd6c3b275e01b7b12f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e8783ada3142cd6c3b275e01b7b12f2">jsocketpp::SocketOptions::getReuseAddress</a> () const</td></tr>
<tr class="memdesc:ga8e8783ada3142cd6c3b275e01b7b12f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether the socket is currently configured to allow address reuse.  <br /></td></tr>
<tr class="memitem:ga69fdecc0aaaef4bbd2826c448a8bbe1d" id="r_ga69fdecc0aaaef4bbd2826c448a8bbe1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga69fdecc0aaaef4bbd2826c448a8bbe1d">jsocketpp::SocketOptions::setReceiveBufferSize</a> (std::size_t size)</td></tr>
<tr class="memdesc:ga69fdecc0aaaef4bbd2826c448a8bbe1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the socket's receive buffer size (SO_RCVBUF).  <br /></td></tr>
<tr class="memitem:ga2eaf2835ebba5587c238a0bd6c2be188" id="r_ga2eaf2835ebba5587c238a0bd6c2be188"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2eaf2835ebba5587c238a0bd6c2be188">jsocketpp::SocketOptions::getReceiveBufferSize</a> () const</td></tr>
<tr class="memdesc:ga2eaf2835ebba5587c238a0bd6c2be188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current receive buffer size (SO_RCVBUF) of the socket.  <br /></td></tr>
<tr class="memitem:ga8279b0c70f6a0fddf73d84aac691422b" id="r_ga8279b0c70f6a0fddf73d84aac691422b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8279b0c70f6a0fddf73d84aac691422b">jsocketpp::SocketOptions::setSendBufferSize</a> (std::size_t size)</td></tr>
<tr class="memdesc:ga8279b0c70f6a0fddf73d84aac691422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the socket's send buffer size (SO_SNDBUF).  <br /></td></tr>
<tr class="memitem:gaeb5f9d1ae3f1b7b9fdb94335b10723f6" id="r_gaeb5f9d1ae3f1b7b9fdb94335b10723f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb5f9d1ae3f1b7b9fdb94335b10723f6">jsocketpp::SocketOptions::getSendBufferSize</a> () const</td></tr>
<tr class="memdesc:gaeb5f9d1ae3f1b7b9fdb94335b10723f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current send buffer size (SO_SNDBUF) of the socket.  <br /></td></tr>
<tr class="memitem:ga707a637112e5ec1309da4e6dfe2fddb3" id="r_ga707a637112e5ec1309da4e6dfe2fddb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga707a637112e5ec1309da4e6dfe2fddb3">jsocketpp::SocketOptions::setSoLinger</a> (bool enable, int seconds)</td></tr>
<tr class="memdesc:ga707a637112e5ec1309da4e6dfe2fddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the socket's linger behavior (<span class="tt">SO_LINGER</span>) during close.  <br /></td></tr>
<tr class="memitem:ga15ba6d555b0f3b7809c746f827398c5e" id="r_ga15ba6d555b0f3b7809c746f827398c5e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga15ba6d555b0f3b7809c746f827398c5e">jsocketpp::SocketOptions::getSoLinger</a> () const</td></tr>
<tr class="memdesc:ga15ba6d555b0f3b7809c746f827398c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current <span class="tt">SO_LINGER</span> configuration of the socket.  <br /></td></tr>
<tr class="memitem:gab3fbb8682b1313dc38abddd541ca4abf" id="r_gab3fbb8682b1313dc38abddd541ca4abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab3fbb8682b1313dc38abddd541ca4abf">jsocketpp::SocketOptions::setKeepAlive</a> (bool on)</td></tr>
<tr class="memdesc:gab3fbb8682b1313dc38abddd541ca4abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables TCP-level keepalive behavior on the socket (<span class="tt">SO_KEEPALIVE</span>).  <br /></td></tr>
<tr class="memitem:ga1193748a866e07a7f25e97a0640ad8dd" id="r_ga1193748a866e07a7f25e97a0640ad8dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1193748a866e07a7f25e97a0640ad8dd">jsocketpp::SocketOptions::getKeepAlive</a> () const</td></tr>
<tr class="memdesc:ga1193748a866e07a7f25e97a0640ad8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether TCP-level keepalive (<span class="tt">SO_KEEPALIVE</span>) is currently enabled.  <br /></td></tr>
<tr class="memitem:ga5ad18e598507d04059bdaff086b01721" id="r_ga5ad18e598507d04059bdaff086b01721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ad18e598507d04059bdaff086b01721">jsocketpp::SocketOptions::setSoRecvTimeout</a> (int millis)</td></tr>
<tr class="memdesc:ga5ad18e598507d04059bdaff086b01721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the socket receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds.  <br /></td></tr>
<tr class="memitem:ga7107a9da459b00bf39ec2fe4d3e83396" id="r_ga7107a9da459b00bf39ec2fe4d3e83396"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7107a9da459b00bf39ec2fe4d3e83396">jsocketpp::SocketOptions::setSoSendTimeout</a> (int millis)</td></tr>
<tr class="memdesc:ga7107a9da459b00bf39ec2fe4d3e83396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the socket send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds.  <br /></td></tr>
<tr class="memitem:gaaee02a4007c38decf8925319b9f3e5f2" id="r_gaaee02a4007c38decf8925319b9f3e5f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaee02a4007c38decf8925319b9f3e5f2">jsocketpp::SocketOptions::getSoRecvTimeout</a> () const</td></tr>
<tr class="memdesc:gaaee02a4007c38decf8925319b9f3e5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the socket receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds.  <br /></td></tr>
<tr class="memitem:ga1bef2499ed5c13367dc73752484298c0" id="r_ga1bef2499ed5c13367dc73752484298c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1bef2499ed5c13367dc73752484298c0">jsocketpp::SocketOptions::getSoSendTimeout</a> () const</td></tr>
<tr class="memdesc:ga1bef2499ed5c13367dc73752484298c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the socket send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds.  <br /></td></tr>
<tr class="memitem:ga5f2dffc2949b06b1d945e590bce7f05b" id="r_ga5f2dffc2949b06b1d945e590bce7f05b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f2dffc2949b06b1d945e590bce7f05b">jsocketpp::SocketOptions::setNonBlocking</a> (bool nonBlocking)</td></tr>
<tr class="memdesc:ga5f2dffc2949b06b1d945e590bce7f05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables non-blocking mode on the socket.  <br /></td></tr>
<tr class="memitem:ga56fa4549b175d2913b64a43f1ecd2409" id="r_ga56fa4549b175d2913b64a43f1ecd2409"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga56fa4549b175d2913b64a43f1ecd2409">jsocketpp::SocketOptions::getNonBlocking</a> () const</td></tr>
<tr class="memdesc:ga56fa4549b175d2913b64a43f1ecd2409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether the socket is currently in non-blocking mode.  <br /></td></tr>
<tr class="memitem:ga9839dd8837c7519a627f28b3a4c7a513" id="r_ga9839dd8837c7519a627f28b3a4c7a513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9839dd8837c7519a627f28b3a4c7a513">jsocketpp::SocketOptions::setTcpNoDelay</a> (bool on)</td></tr>
<tr class="memdesc:ga9839dd8837c7519a627f28b3a4c7a513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>) on TCP sockets.  <br /></td></tr>
<tr class="memitem:ga05137fbdc55ab065739e220b7a4f41c0" id="r_ga05137fbdc55ab065739e220b7a4f41c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga05137fbdc55ab065739e220b7a4f41c0">jsocketpp::SocketOptions::getTcpNoDelay</a> () const</td></tr>
<tr class="memdesc:ga05137fbdc55ab065739e220b7a4f41c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether Nagle's algorithm (<span class="tt">TCP_NODELAY</span>) is currently disabled.  <br /></td></tr>
<tr class="memitem:gacb9e27d93d3107ad8641fa7a179658c6" id="r_gacb9e27d93d3107ad8641fa7a179658c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacb9e27d93d3107ad8641fa7a179658c6">jsocketpp::SocketOptions::setBroadcast</a> (bool on)</td></tr>
<tr class="memdesc:gacb9e27d93d3107ad8641fa7a179658c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the ability to send UDP broadcast messages.  <br /></td></tr>
<tr class="memitem:gab0df7d40f7d6b40737cbf3271be57f37" id="r_gab0df7d40f7d6b40737cbf3271be57f37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab0df7d40f7d6b40737cbf3271be57f37">jsocketpp::SocketOptions::getBroadcast</a> () const</td></tr>
<tr class="memdesc:gab0df7d40f7d6b40737cbf3271be57f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the socket is currently allowed to send broadcast messages.  <br /></td></tr>
<tr class="memitem:gab96d6fa640ac34113cb1f76bfbf970dc" id="r_gab96d6fa640ac34113cb1f76bfbf970dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab96d6fa640ac34113cb1f76bfbf970dc">jsocketpp::SocketOptions::setIPv6Only</a> (bool enable)</td></tr>
<tr class="memdesc:gab96d6fa640ac34113cb1f76bfbf970dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables <span class="tt">IPV6_V6ONLY</span> mode for IPv6-capable sockets.  <br /></td></tr>
<tr class="memitem:ga1d44e7f23739c1ef4a9ad550b4a1ff1d" id="r_ga1d44e7f23739c1ef4a9ad550b4a1ff1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1d44e7f23739c1ef4a9ad550b4a1ff1d">jsocketpp::SocketOptions::getIPv6Only</a> () const</td></tr>
<tr class="memdesc:ga1d44e7f23739c1ef4a9ad550b4a1ff1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether the <span class="tt">IPV6_V6ONLY</span> option is enabled on this socket.  <br /></td></tr>
<tr class="memitem:ga05c3ae5067a7d83965249d00c5d564c3" id="r_ga05c3ae5067a7d83965249d00c5d564c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga05c3ae5067a7d83965249d00c5d564c3">jsocketpp::SocketOptions::setReusePort</a> (const bool enable)</td></tr>
<tr class="memdesc:ga05c3ae5067a7d83965249d00c5d564c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the <span class="tt">SO_REUSEPORT</span> socket option.  <br /></td></tr>
<tr class="memitem:ga0472e21ad70ac9b778aac3d6177577ca" id="r_ga0472e21ad70ac9b778aac3d6177577ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0472e21ad70ac9b778aac3d6177577ca">jsocketpp::SocketOptions::getReusePort</a> () const</td></tr>
<tr class="memdesc:ga0472e21ad70ac9b778aac3d6177577ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the <span class="tt">SO_REUSEPORT</span> option is currently enabled on the socket.  <br /></td></tr>
<tr class="memitem:ga147307de53a210acda7c64dc1540c40e" id="r_ga147307de53a210acda7c64dc1540c40e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga147307de53a210acda7c64dc1540c40e">jsocketpp::SocketOptions::setMulticastTTL</a> (int ttl)</td></tr>
<tr class="memdesc:ga147307de53a210acda7c64dc1540c40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default multicast hop limit / TTL for this socket.  <br /></td></tr>
<tr class="memitem:ga55f73b7c90f7f6b507c69eead5cfc10f" id="r_ga55f73b7c90f7f6b507c69eead5cfc10f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga55f73b7c90f7f6b507c69eead5cfc10f">jsocketpp::SocketOptions::getMulticastTTL</a> () const</td></tr>
<tr class="memdesc:ga55f73b7c90f7f6b507c69eead5cfc10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the socket’s default multicast hop limit / TTL.  <br /></td></tr>
<tr class="memitem:ga145c0c5a7e075ac0bdda7f30e860c717" id="r_ga145c0c5a7e075ac0bdda7f30e860c717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">jsocketpp::SocketOptions::setMulticastLoopback</a> (bool enable)</td></tr>
<tr class="memdesc:ga145c0c5a7e075ac0bdda7f30e860c717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable multicast loopback for this socket.  <br /></td></tr>
<tr class="memitem:ga67d056eeb49ad2f3fb831e9653c23b6e" id="r_ga67d056eeb49ad2f3fb831e9653c23b6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga67d056eeb49ad2f3fb831e9653c23b6e">jsocketpp::SocketOptions::getMulticastLoopback</a> () const</td></tr>
<tr class="memdesc:ga67d056eeb49ad2f3fb831e9653c23b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the socket’s multicast loopback flag.  <br /></td></tr>
<tr class="memitem:ga0303c931f324a501e2502df58b8a9232" id="r_ga0303c931f324a501e2502df58b8a9232"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0303c931f324a501e2502df58b8a9232">jsocketpp::SocketOptions::setMulticastInterfaceIPv4</a> (in_addr addr)</td></tr>
<tr class="memdesc:ga0303c931f324a501e2502df58b8a9232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the outgoing IPv4 interface for multicast.  <br /></td></tr>
<tr class="memitem:gad8e171cfa4daf58cde0f27d26794e35c" id="r_gad8e171cfa4daf58cde0f27d26794e35c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad8e171cfa4daf58cde0f27d26794e35c">jsocketpp::SocketOptions::setMulticastInterfaceIPv6</a> (unsigned int ifindex)</td></tr>
<tr class="memdesc:gad8e171cfa4daf58cde0f27d26794e35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the outgoing IPv6 interface for multicast.  <br /></td></tr>
<tr class="memitem:ga65375075d5e7b8009730e0d28b199d73" id="r_ga65375075d5e7b8009730e0d28b199d73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga65375075d5e7b8009730e0d28b199d73">jsocketpp::SocketOptions::joinGroupIPv4</a> (in_addr group, in_addr iface)</td></tr>
<tr class="memdesc:ga65375075d5e7b8009730e0d28b199d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an IPv4 any-source multicast (ASM) group on a specific interface.  <br /></td></tr>
<tr class="memitem:ga31401a44675c8fd07c2e80a674106ce9" id="r_ga31401a44675c8fd07c2e80a674106ce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga31401a44675c8fd07c2e80a674106ce9">jsocketpp::SocketOptions::leaveGroupIPv4</a> (in_addr group, in_addr iface)</td></tr>
<tr class="memdesc:ga31401a44675c8fd07c2e80a674106ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a previously joined IPv4 multicast group on a specific interface.  <br /></td></tr>
<tr class="memitem:ga26253ae313b6ef1417af775668ffbf24" id="r_ga26253ae313b6ef1417af775668ffbf24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga26253ae313b6ef1417af775668ffbf24">jsocketpp::SocketOptions::joinGroupIPv6</a> (in6_addr group, unsigned int ifindex)</td></tr>
<tr class="memdesc:ga26253ae313b6ef1417af775668ffbf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an IPv6 any-source multicast (ASM) group on a specific interface index.  <br /></td></tr>
<tr class="memitem:ga99ae2e1e73aa0ddb9b00377a0b888285" id="r_ga99ae2e1e73aa0ddb9b00377a0b888285"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga99ae2e1e73aa0ddb9b00377a0b888285">jsocketpp::SocketOptions::leaveGroupIPv6</a> (in6_addr group, unsigned int ifindex)</td></tr>
<tr class="memdesc:ga99ae2e1e73aa0ddb9b00377a0b888285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a previously joined IPv6 multicast group on a specific interface index.  <br /></td></tr>
<tr class="memitem:ga97706ddf21aab33a18db00bd0b8eb65d" id="r_ga97706ddf21aab33a18db00bd0b8eb65d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga97706ddf21aab33a18db00bd0b8eb65d">jsocketpp::SocketOptions::setSocketFd</a> (const <a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a> sock) noexcept</td></tr>
<tr class="memdesc:ga97706ddf21aab33a18db00bd0b8eb65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the socket descriptor used by this object.  <br /></td></tr>
<tr class="memitem:gaace6c3364b4016979537571b36c58727" id="r_gaace6c3364b4016979537571b36c58727"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaace6c3364b4016979537571b36c58727">jsocketpp::SocketOptions::isPassiveSocket</a> () const noexcept</td></tr>
<tr class="memdesc:gaace6c3364b4016979537571b36c58727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the socket behaves as a passive (listening) socket.  <br /></td></tr>
<tr class="memitem:ga10fe0331596fddffb6dbd483c95a2490" id="r_ga10fe0331596fddffb6dbd483c95a2490"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10fe0331596fddffb6dbd483c95a2490">jsocketpp::SocketOptions::is_ipv4_multicast</a> (const in_addr v4)</td></tr>
<tr class="memdesc:ga10fe0331596fddffb6dbd483c95a2490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether an IPv4 address is in the multicast range (224.0.0.0/4).  <br /></td></tr>
<tr class="memitem:ga10be210b19c0e6d6deb641cb74ed1c0a" id="r_ga10be210b19c0e6d6deb641cb74ed1c0a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10be210b19c0e6d6deb641cb74ed1c0a">jsocketpp::SocketOptions::is_ipv6_multicast</a> (const in6_addr &amp;v6)</td></tr>
<tr class="memdesc:ga10be210b19c0e6d6deb641cb74ed1c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether an IPv6 address is in the multicast range (ff00::/8).  <br /></td></tr>
<tr class="memitem:ga80ed710cbeac63301d2b68dc6a26a661" id="r_ga80ed710cbeac63301d2b68dc6a26a661"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80ed710cbeac63301d2b68dc6a26a661">jsocketpp::SocketOptions::detectFamily</a> (<a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a> fd)</td></tr>
<tr class="memdesc:ga80ed710cbeac63301d2b68dc6a26a661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the address family (AF_INET or AF_INET6) of a socket.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Low-level socket configuration options exposed via the <span class="tt">Socket</span> and related classes. </p>
<p>This module contains functions and accessors for configuring standard socket options such as SO_LINGER, SO_RCVTIMEO, TCP_NODELAY, SO_REUSEADDR, and SO_KEEPALIVE.</p>
<p>These options provide fine-grained control over low-level socket behavior such as timeout behavior, connection shutdown semantics, buffering, and performance tuning.</p>
<p>All functions in this group are cross-platform abstractions over <span class="tt">setsockopt()</span> and <span class="tt">getsockopt()</span>.</p>
<dl class="section note"><dt>Note</dt><dd>Some options may not be available or meaningful on all platforms. Platform-specific behavior is documented per function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Socket::setSoLinger(), Socket::getSoLinger(), Socket::setTcpNoDelay(), etc. </dd></dl>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga80ed710cbeac63301d2b68dc6a26a661" name="ga80ed710cbeac63301d2b68dc6a26a661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80ed710cbeac63301d2b68dc6a26a661">&#9670;&#160;</a></span>detectFamily()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jsocketpp::SocketOptions::detectFamily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a></td>          <td class="paramname"><span class="paramname"><em>fd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the address family (AF_INET or AF_INET6) of a socket. </p>
<p>Returns the protocol family with which <code class="param">fd</code> was created. On platforms that support it, this first attempts <span class="tt">getsockopt(SOL_SOCKET, SO_DOMAIN, ...)</span> and falls back to <span class="tt">getsockname()</span> for broad compatibility.</p>
<p>The result is used to pick the correct per-family options for subsequent operations (e.g., <span class="tt">IP_MULTICAST_TTL</span> vs <span class="tt">IPV6_MULTICAST_HOPS</span>, <span class="tt">IP_MULTICAST_LOOP</span> vs <span class="tt">IPV6_MULTICAST_LOOP</span>, <span class="tt">IP_MULTICAST_IF</span> vs <span class="tt">IPV6_MULTICAST_IF</span>, and IPv4/IPv6 group membership APIs).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>The socket handle to inspect. Must be a valid datagram or stream socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">AF_INET</span> for IPv4 sockets or <span class="tt">AF_INET6</span> for IPv6 sockets.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code class="param">fd</code> is a valid, open socket descriptor/handle.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>No socket state is modified. This is a read-only query.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td><ul>
<li>If <code class="param">fd</code> is invalid (<span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> on Windows or negative on POSIX).</li>
<li>If the underlying <span class="tt">getsockopt(SO_DOMAIN)</span> or <span class="tt">getsockname()</span> call fails; the exception carries the OS error code and message from <span class="tt">SocketErrorMessage(...)</span>.</li>
<li>If the determined family is neither <span class="tt">AF_INET</span> nor <span class="tt">AF_INET6</span> (e.g., <span class="tt">AF_UNSPEC</span>).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>On dual-stack sockets (created as <span class="tt">AF_INET6</span> with <span class="tt">IPV6_V6ONLY</span> disabled), this function returns <span class="tt">AF_INET6</span>. Whether IPv4 behavior is also available is governed by the <span class="tt">IPV6_V6ONLY</span> option and OS capabilities.</li>
<li><span class="tt">SO_DOMAIN</span> is not universally available; the implementation transparently falls back to <span class="tt">getsockname()</span> where necessary.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related</dt><dd><ul>
<li><span class="tt"><a class="el" href="#ga147307de53a210acda7c64dc1540c40e" title="Set the default multicast hop limit / TTL for this socket.">setMulticastTTL(int)</a></span> / <span class="tt"><a class="el" href="#ga55f73b7c90f7f6b507c69eead5cfc10f" title="Get the socket’s default multicast hop limit / TTL.">getMulticastTTL()</a></span> — per-family TTL/hop-limit.</li>
<li><span class="tt"><a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717" title="Enable or disable multicast loopback for this socket.">setMulticastLoopback(bool)</a></span> / <span class="tt"><a class="el" href="#ga67d056eeb49ad2f3fb831e9653c23b6e" title="Read the socket’s multicast loopback flag.">getMulticastLoopback()</a></span> — per-family loopback.</li>
<li><span class="tt"><a class="el" href="#ga0303c931f324a501e2502df58b8a9232" title="Select the outgoing IPv4 interface for multicast.">setMulticastInterfaceIPv4(in_addr)</a></span> / <span class="tt">setMulticastInterfaceIPv6(unsigned)</span> — select multicast egress per family.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: choose the correct loopback optname by family</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> fam = <a class="code hl_function" href="#ga80ed710cbeac63301d2b68dc6a26a661">detectFamily</a>(sockFd);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> level   = (fam == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> optname = (fam == AF_INET6) ? IPV6_MULTICAST_LOOP : IP_MULTICAST_LOOP;</div>
<div class="line"><span class="keywordtype">int</span> on = 1;</div>
<div class="line">setsockopt(sockFd, level, optname, <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;on), <span class="keyword">sizeof</span>(on));</div>
<div class="ttc" id="agroup__socketopts_html_ga80ed710cbeac63301d2b68dc6a26a661"><div class="ttname"><a href="#ga80ed710cbeac63301d2b68dc6a26a661">jsocketpp::SocketOptions::detectFamily</a></div><div class="ttdeci">static int detectFamily(SOCKET fd)</div><div class="ttdoc">Determine the address family (AF_INET or AF_INET6) of a socket.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:340</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gab0df7d40f7d6b40737cbf3271be57f37" name="gab0df7d40f7d6b40737cbf3271be57f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0df7d40f7d6b40737cbf3271be57f37">&#9670;&#160;</a></span>getBroadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::getBroadcast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the socket is currently allowed to send broadcast messages. </p>
<p>This method retrieves the <span class="tt">SO_BROADCAST</span> option using <span class="tt">getsockopt()</span> to determine whether the socket can send datagrams to broadcast addresses like <span class="tt">255.255.255.255</span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1146"></a>
Applicability</h3>
<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>: ✅ Primary use case</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (TCP): ❌ Invalid, will throw</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>: ❌ Not applicable</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1148"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (datagramSocket.getBroadcast()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Broadcast is enabled.\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Broadcast is disabled.\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if broadcast mode is enabled, <span class="tt">false</span> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li>The system call fails (<span class="tt">getsockopt()</span> error)</li>
<li>The socket type is incompatible with this option</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacb9e27d93d3107ad8641fa7a179658c6" title="Enables or disables the ability to send UDP broadcast messages.">setBroadcast()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/socket.7.html">https://man7.org/linux/man-pages/man7/socket.7.html</a> </dd></dl>

</div>
</div>
<a id="ga1d44e7f23739c1ef4a9ad550b4a1ff1d" name="ga1d44e7f23739c1ef4a9ad550b4a1ff1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d44e7f23739c1ef4a9ad550b4a1ff1d">&#9670;&#160;</a></span>getIPv6Only()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::getIPv6Only </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries whether the <span class="tt">IPV6_V6ONLY</span> option is enabled on this socket. </p>
<p>This method checks whether the socket is currently restricted to IPv6-only traffic, or whether it allows dual-stack operation (accepting both IPv6 and IPv4-mapped addresses).</p>
<p>The <span class="tt">IPV6_V6ONLY</span> flag is primarily relevant to sockets using the <span class="tt">AF_INET6</span> address family.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1160"></a>
🌍 Applicability by Socket Type</h3>
<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>: ✅ Affects accept() behavior for IPv6 listeners</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>: ✅ Optional, useful for bound clients or diagnostic purposes</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>: ✅ Relevant when binding to IPv6 multicast or wildcard addresses</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>: ❌ Not applicable; throws if called</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1162"></a>
⚠️ Platform Behavior</h3>
<ul>
<li><b>Linux</b>: Defaults to <span class="tt">false</span> (dual-stack), but configurable</li>
<li><b>Windows</b>: Defaults to <span class="tt">true</span> (IPv6-only), must be explicitly disabled</li>
<li><b>macOS/BSD</b>: May disallow toggling at runtime or enforce <span class="tt">true</span></li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1164"></a>
Example: Check if socket is IPv6-only</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (socket.getIPv6Only()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;This socket is IPv6-only.\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Dual-stack mode is active.\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if <span class="tt">IPV6_V6ONLY</span> is enabled (IPv6-only mode), <span class="tt">false</span> if dual-stack is allowed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid or closed</li>
<li>The system call fails (<span class="tt">getsockopt()</span> error)</li>
<li>The socket is not an IPv6 socket (i.e., <span class="tt">AF_INET6</span>)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always check that the socket is using the <span class="tt">AF_INET6</span> family before interpreting this flag. Calling this method on a non-IPv6 socket will throw.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab96d6fa640ac34113cb1f76bfbf970dc" title="Enables or disables IPV6_V6ONLY mode for IPv6-capable sockets.">setIPv6Only()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/ipv6.7.html">https://man7.org/linux/man-pages/man7/ipv6.7.html</a> </dd></dl>

</div>
</div>
<a id="ga1193748a866e07a7f25e97a0640ad8dd" name="ga1193748a866e07a7f25e97a0640ad8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1193748a866e07a7f25e97a0640ad8dd">&#9670;&#160;</a></span>getKeepAlive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::getKeepAlive </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether TCP-level keepalive (<span class="tt">SO_KEEPALIVE</span>) is currently enabled. </p>
<p>This method queries the socket's current <span class="tt">SO_KEEPALIVE</span> setting, which determines whether the operating system sends periodic keepalive probes to verify that idle, stream-oriented connections are still alive.</p>
<p>Keepalive is especially useful for detecting silent disconnects in long-lived connections (e.g., crash, power loss, cable pull) where no TCP FIN/RST is received.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1081"></a>
🔁 Applicability</h3>
<ul>
<li>✅ <b>TCP sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>)</b>: Fully supported. Returns the current setting.</li>
<li>✅ <b>UNIX domain stream sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>)</b>: Supported on most POSIX platforms.</li>
<li>✅ <b>Accepted sockets in <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span></b>: Each accepted socket can be queried individually.</li>
<li>⚠️ <b>UDP / datagram sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</b>: Most systems ignore this option; querying may return <span class="tt">false</span> or raise an error depending on platform behavior.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1082"></a>
Platform Behavior</h3>
<ul>
<li><b>Linux/macOS/BSD</b>: Returns <span class="tt">true</span> if <span class="tt">SO_KEEPALIVE</span> is enabled at the socket level. Probe intervals and behavior are system-controlled unless overridden via additional options.</li>
<li><b>Windows</b>: Returns <span class="tt">true</span> if enabled. Advanced tuning requires use of <span class="tt">WSAIoctl</span>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1083"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!socket.getKeepAlive()) {</div>
<div class="line">    socket.setKeepAlive(<span class="keyword">true</span>);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Keepalive enabled.\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if keepalive is enabled; <span class="tt">false</span> if disabled.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid or closed</li>
<li><span class="tt">getsockopt()</span> fails</li>
<li>The platform does not support the option on this socket type</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab3fbb8682b1313dc38abddd541ca4abf" title="Enables or disables TCP-level keepalive behavior on the socket (SO_KEEPALIVE).">setKeepAlive()</a> </dd>
<dd>
<a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/tcp.7.html">https://man7.org/linux/man-pages/man7/tcp.7.html</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method only checks whether <span class="tt">SO_KEEPALIVE</span> is enabled. It does <b>not</b> report the configured keepalive timing parameters (interval, probes, idle time), which are system-defined. </dd></dl>

</div>
</div>
<a id="ga0f0ab03631b48add0e1b8845e553ebab" name="ga0f0ab03631b48add0e1b8845e553ebab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f0ab03631b48add0e1b8845e553ebab">&#9670;&#160;</a></span>getLoopbackMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::MulticastSocket::getLoopbackMode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current multicast loopback mode cached on this socket. </p>
<p>Reports whether this object is configured to receive <b>local copies of its own multicast transmissions</b> (“loopback”). The value reflects the last successful call to <a class="el" href="group__udp.html#gab6608be5d1aff24ad5077f6ea9a9168a">setLoopbackMode(bool)</a> made through this class; it does <b>not</b> perform a fresh kernel query.</p>
<p>Semantics of the returned flag:</p><ul>
<li><span class="tt">true</span> — loopback enabled; if this socket has joined the destination group, the kernel may deliver local copies of this socket’s outbound multicast.</li>
<li><span class="tt">false</span> — loopback disabled; local delivery of this socket’s outbound multicast is suppressed on the host.</li>
</ul>
<p>This accessor concerns <b>multicast</b> only; it does not affect nor report unicast behavior.</p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if multicast loopback is enabled according to this object’s cached state; otherwise <span class="tt">false</span>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None. This is a read-only accessor.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>No side effects; neither socket nor object state is modified.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The value is <b>cached</b> in this class (e.g., <span class="tt"><a class="el" href="classjsocketpp_1_1MulticastSocket.html#afee075e307c36c143cf62a119a8f7e9a" title="Controls whether multicast packets loop back to the sending host.">_loopbackEnabled</a></span>). If other code changes the OS-level setting directly (e.g., via <a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> on the underlying options object), this cached flag may not reflect the kernel’s current configuration. Use <a class="el" href="#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> to perform a fresh OS query.</li>
<li>To actually receive your own transmissions on this socket, two conditions must hold: (1) loopback is enabled, and (2) the socket has <b>joined</b> the destination group.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="group__udp.html#gab6608be5d1aff24ad5077f6ea9a9168a">setLoopbackMode(bool)</a> — update this cached flag and the OS setting.</li>
<li><a class="el" href="#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> — query the OS-level loopback flag (fresh <span class="tt">getsockopt</span>).</li>
<li><a class="el" href="group__udp.html#ga72172a10bc5ba13a908f31c791c90ec5">setTimeToLive(int)</a> / <a class="el" href="#gad11b9d3378834eab9c28e32e70fc249a">getTimeToLive()</a> — control/query multicast scope.</li>
<li><a class="el" href="group__udp.html#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface(const std::string&amp;)</a> — select the outgoing interface.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Ensure we will receive our own announcements on this host:</span></div>
<div class="line"><span class="keywordflow">if</span> (!sock.getLoopbackMode()) {</div>
<div class="line">    sock.setLoopbackMode(<span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga67d056eeb49ad2f3fb831e9653c23b6e" name="ga67d056eeb49ad2f3fb831e9653c23b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d056eeb49ad2f3fb831e9653c23b6e">&#9670;&#160;</a></span>getMulticastLoopback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::getMulticastLoopback </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the socket’s multicast loopback flag. </p>
<p>Queries whether <b>multicast datagrams transmitted by this socket</b> are eligible for <b>local delivery back to the host</b> (“loopback”).</p>
<ul>
<li><b>IPv4:</b> reads <span class="tt">IP_MULTICAST_LOOP</span>.</li>
<li><b>IPv6:</b> reads <span class="tt">IPV6_MULTICAST_LOOP</span>.</li>
</ul>
<p>Semantics of the returned flag:</p><ul>
<li><span class="tt">true</span> — the kernel may deliver local copies of this socket’s outbound multicast to sockets on the same host that have joined the destination group (including this socket if it has joined).</li>
<li><span class="tt">false</span> — the kernel suppresses local delivery of this socket’s outbound multicast.</li>
</ul>
<p>This is a read-only query of the <b>per-socket default</b> and does not affect unicast traffic, nor does it consider any per-message control data. It reports the socket’s current loopback policy only.</p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if multicast loopback is enabled for this socket; otherwise <span class="tt">false</span>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The underlying descriptor is a valid socket of family <span class="tt">AF_INET</span> or <span class="tt">AF_INET6</span>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state is unchanged; this call performs no modifications.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Platform mapping</dt><dd><ul>
<li><b>IPv4:</b> <span class="tt">getsockopt(fd, IPPROTO_IP,  IP_MULTICAST_LOOP,  ...)</span></li>
<li><b>IPv6:</b> <span class="tt">getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, ...)</span></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error conditions</dt><dd><ul>
<li>The socket is invalid or closed.</li>
<li>The socket family cannot be determined or is unsupported on this platform.</li>
<li>The underlying <span class="tt">getsockopt</span> call fails (e.g., <span class="tt">ENOTSOCK</span>, <span class="tt">ENOPROTOOPT</span>, <span class="tt">EINVAL</span>, or Windows equivalents <span class="tt">WSAENOTSOCK</span>, <span class="tt">WSAENOPROTOOPT</span>, <span class="tt">WSAEINVAL</span>).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the query fails for any of the reasons above. The exception carries the OS error code and a descriptive message produced by <span class="tt">SocketErrorMessage(...)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Typical default is <b>enabled</b> on many stacks, but this is implementation-defined; applications that rely on a specific policy should call <a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> during initialization.</li>
<li>Loopback controls <b>local delivery only</b>. Remote receivers are unaffected.</li>
<li>To receive your own transmissions on this socket, both conditions must hold: (1) loopback is enabled, and (2) the socket has joined the destination group.</li>
<li>Concurrent calls to <a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> may race with this query; the value returned is a snapshot at the time of the call.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> — enable/disable local delivery of this socket’s outbound multicast.</li>
<li><a class="el" href="#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> / <a class="el" href="#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL()</a> — control and query the default multicast scope (TTL/hop-limit).</li>
<li><a class="el" href="#ga0303c931f324a501e2502df58b8a9232">setMulticastInterfaceIPv4(in_addr)</a> / setMulticastInterfaceIPv6(unsigned) — select the outgoing interface for multicast.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: ensure loopback is enabled so we can observe our own group traffic</span></div>
<div class="line"><span class="keywordflow">if</span> (!sock.getMulticastLoopback()) {</div>
<div class="line">    sock.setMulticastLoopback(<span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Now, if this socket has joined the group, it can receive its own sends.</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga55f73b7c90f7f6b507c69eead5cfc10f" name="ga55f73b7c90f7f6b507c69eead5cfc10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55f73b7c90f7f6b507c69eead5cfc10f">&#9670;&#160;</a></span>getMulticastTTL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jsocketpp::SocketOptions::getMulticastTTL </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the socket’s default multicast hop limit / TTL. </p>
<p>Returns the current <b>per-socket default</b> scope used for outbound <b>multicast</b> transmissions:</p><ul>
<li>For IPv4 sockets, this queries <span class="tt">IP_MULTICAST_TTL</span> (time-to-live).</li>
<li>For IPv6 sockets, this queries <span class="tt">IPV6_MULTICAST_HOPS</span> (hop limit).</li>
</ul>
<p>The returned value determines how far multicast packets sent from this socket may propagate by default:</p><ul>
<li><span class="tt">0</span> confines delivery to the local host.</li>
<li><span class="tt">1</span> confines delivery to the local link / subnet.</li>
<li>Larger values permit traversal across additional multicast routers, up to the limit.</li>
</ul>
<p>This query does <b>not</b> affect unicast traffic—use <span class="tt">IP_TTL</span> / <span class="tt">IPV6_UNICAST_HOPS</span> for unicast scope—and does <b>not</b> consider any per-message overrides supplied via ancillary data (e.g., <span class="tt">IP_MULTICAST_TTL</span> / <span class="tt">IPV6_HOPLIMIT</span> control messages). It reports the socket’s default only.</p>
<dl class="section return"><dt>Returns</dt><dd>TTL / hop-limit in the range <span class="tt">[0, 255]</span> currently configured on this socket for multicast transmissions.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The underlying descriptor is a valid socket of family <span class="tt">AF_INET</span> or <span class="tt">AF_INET6</span>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> state is unchanged; this is a read-only query.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Platform mapping</dt><dd><ul>
<li><b>IPv4:</b> <span class="tt">getsockopt(fd, IPPROTO_IP,  IP_MULTICAST_TTL,  ...)</span></li>
<li><b>IPv6:</b> <span class="tt">getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, ...)</span></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error conditions</dt><dd><ul>
<li>The socket is invalid or closed.</li>
<li>The socket family cannot be determined or is unsupported.</li>
<li>The underlying <span class="tt">getsockopt</span> call fails (e.g., <span class="tt">ENOTSOCK</span>, <span class="tt">ENOPROTOOPT</span>, <span class="tt">EINVAL</span>, or Windows equivalents such as <span class="tt">WSAENOTSOCK</span>, <span class="tt">WSAENOPROTOOPT</span>, <span class="tt">WSAEINVAL</span>).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the query fails for any of the reasons above. The exception carries the OS error code and a descriptive message produced by <span class="tt">SocketErrorMessage(...)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The initial value is implementation-defined (commonly <span class="tt">1</span>); applications that require a specific scope should call <a class="el" href="#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> during initialization.</li>
<li>Concurrent calls to <a class="el" href="#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> may race with this query; the value returned is a snapshot at the time of the call.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> — set the default multicast scope.</li>
<li><a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> — control whether this socket receives its own multicast transmissions.</li>
<li><a class="el" href="#ga0303c931f324a501e2502df58b8a9232">setMulticastInterfaceIPv4(in_addr)</a> / setMulticastInterfaceIPv6(unsigned) — choose the outgoing interface for multicast.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: read current default, ensure at least link-local reach (&gt;= 1)</span></div>
<div class="line">[[maybe_unused]] <span class="keyword">auto</span> current = sock.getMulticastTTL();</div>
<div class="line"><span class="keywordflow">if</span> (current &lt; 1) {</div>
<div class="line">    sock.setMulticastTTL(1);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga56fa4549b175d2913b64a43f1ecd2409" name="ga56fa4549b175d2913b64a43f1ecd2409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56fa4549b175d2913b64a43f1ecd2409">&#9670;&#160;</a></span>getNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::getNonBlocking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries whether the socket is currently in non-blocking mode. </p>
<p>This method inspects the I/O mode of the socket and returns <span class="tt">true</span> if it is configured for non-blocking operations. In non-blocking mode, I/O system calls return immediately if they cannot complete, rather than blocking the calling thread.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1116"></a>
🔀 Platform Behavior</h3>
<ul>
<li><b>POSIX</b>: Checks the <span class="tt">O_NONBLOCK</span> flag using <span class="tt">fcntl(F_GETFL)</span>.</li>
<li><b>Windows</b>: No direct API exists to query non-blocking state. This function will conservatively return <span class="tt">false</span> and emit a warning if queried.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1118"></a>
Use Cases</h3>
<ul>
<li>Debugging or inspecting socket configuration</li>
<li>Adaptive I/O logic based on runtime state</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1120"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!socket.getNonBlocking()) {</div>
<div class="line">    socket.setNonBlocking(<span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket is in non-blocking mode, <span class="tt">false</span> otherwise. On Windows, always returns <span class="tt">false</span> due to lack of system support.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li>The system query fails (e.g., <span class="tt">fcntl</span> returns error on POSIX)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On Windows, there is <b>no way to detect</b> the current non-blocking state via public APIs. You must track it manually in application logic if needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a> </dd></dl>

</div>
</div>
<a id="ga6a5264b995eb2a1143f45c5de6ad92c3" name="ga6a5264b995eb2a1143f45c5de6ad92c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a5264b995eb2a1143f45c5de6ad92c3">&#9670;&#160;</a></span>getOption() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jsocketpp::SocketOptions::getOption </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>optName</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the current value of a low-level socket option. </p>
<p>This method queries a socket option using the system-level <span class="tt">getsockopt()</span> interface. It returns the current value as an integer and is useful for inspecting platform defaults, runtime configuration, or verifying changes made via <span class="tt"><a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a></span>.</p>
<p>This method is supported by all socket types provided by the library:</p><ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (TCP)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> (listening)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> (UDP)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span> (UNIX domain)</li>
</ul>
<p>It supports standard protocol levels such as <span class="tt">SOL_SOCKET</span>, <span class="tt">IPPROTO_TCP</span>, and <span class="tt">IPPROTO_UDP</span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1032"></a>
🔧 Use Cases</h3>
<ul>
<li>Verify receive/send buffer sizes (<span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>)</li>
<li>Check if keepalive or broadcast is enabled (<span class="tt">SO_KEEPALIVE</span>, <span class="tt">SO_BROADCAST</span>)</li>
<li>Inspect linger state (<span class="tt">SO_LINGER</span>) via the structured overload</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1034"></a>
Example: Read configured receive buffer size</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> rcvBuf = socket.getOption(SOL_SOCKET, SO_RCVBUF);</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1036"></a>
⚠️ ServerSocket-specific Notes</h3>
<ul>
<li>Applies only to the listening socket.</li>
<li>Use this to inspect pre-accept behavior such as:<ul>
<li><span class="tt">SO_REUSEADDR</span>, <span class="tt">SO_LINGER</span>, <span class="tt">SO_RCVBUF</span>, etc.</li>
</ul>
</li>
<li>Accepted client sockets must be queried individually.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> reuse = serverSocket.getOption(SOL_SOCKET, SO_REUSEADDR);</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1038"></a>
📡 DatagramSocket-specific Notes</h3>
<ul>
<li>Useful for checking <span class="tt">SO_BROADCAST</span>, <span class="tt">SO_RCVTIMEO</span>, <span class="tt">SO_SNDTIMEO</span>, and buffer sizes.</li>
<li>Behavior is consistent across connected and unconnected UDP sockets.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> timeout = datagramSocket.getOption(SOL_SOCKET, SO_RCVTIMEO);</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1040"></a>
🧿 UnixSocket-specific Notes</h3>
<ul>
<li><span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span>, <span class="tt">SO_PASSCRED</span>, and timeout options are supported.</li>
<li>Can be used for IPC performance diagnostics.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> bufSize = unixSocket.getOption(SOL_SOCKET, SO_SNDBUF);</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Protocol level (e.g., <span class="tt">SOL_SOCKET</span>, <span class="tt">IPPROTO_TCP</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optName</td><td><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> option name (e.g., <span class="tt">SO_KEEPALIVE</span>, <span class="tt">SO_SNDBUF</span>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value of the requested option</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li>The option is unsupported or improperly configured</li>
<li>The <span class="tt">getsockopt()</span> call fails</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption(int, int, int)</a> </dd>
<dd>
getOption(int, int, void*, socklen_t*) For retrieving structured options </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man2/getsockopt.2.html">https://man7.org/linux/man-pages/man2/getsockopt.2.html</a> </dd></dl>

</div>
</div>
<a id="ga9c068d958d55e865948b2015c82450a7" name="ga9c068d958d55e865948b2015c82450a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c068d958d55e865948b2015c82450a7">&#9670;&#160;</a></span>getOption() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::getOption </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>optName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a socket option into a structured or binary buffer. </p>
<p>This overload of <span class="tt"><a class="el" href="#ga6a5264b995eb2a1143f45c5de6ad92c3" title="Retrieves the current value of a low-level socket option.">getOption()</a></span> allows querying complex or platform-specific socket options that require structured output (e.g., <span class="tt">struct linger</span>, <span class="tt">struct timeval</span>, etc.). It wraps the system-level <span class="tt">getsockopt()</span> call using a raw memory buffer and returns the result through the provided pointer.</p>
<p>The semantics are identical to the <span class="tt">getOption(int, int)</span> overload, but this version is used for retrieving non-integer options.</p>
<p>This method works uniformly across:</p><ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (TCP)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> (listening TCP)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> (UDP)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span> (local IPC)</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1043"></a>
🔧 Use Cases</h3>
<ul>
<li>Query <span class="tt">SO_LINGER</span> using <span class="tt">struct linger</span></li>
<li>Read timeout values into <span class="tt">struct timeval</span></li>
<li>Inspect platform-specific flags or metadata structures</li>
<li>Use with low-level protocol options that return binary data</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1045"></a>
Example: Read <span class="tt">SO_LINGER</span> setting</h3>
<div class="fragment"><div class="line">linger lin{};</div>
<div class="line">socklen_t len = <span class="keyword">sizeof</span>(lin);</div>
<div class="line">socket.getOption(SOL_SOCKET, SO_LINGER, &amp;lin, &amp;len);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (lin.l_onoff)</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Linger enabled for &quot;</span> &lt;&lt; lin.l_linger &lt;&lt; <span class="stringliteral">&quot; seconds.\n&quot;</span>;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Linger is disabled.\n&quot;</span>;</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1047"></a>
⚠️ ServerSocket-specific Notes</h3>
<ul>
<li>Applies to the listening socket only (not accepted clients).</li>
<li>Common for querying <span class="tt">SO_LINGER</span>, <span class="tt">SO_RCVBUF</span>, etc.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1049"></a>
📡 DatagramSocket-specific Notes</h3>
<ul>
<li>Use to inspect structured timeouts (<span class="tt">SO_RCVTIMEO</span>) or multicast settings.</li>
<li>Valid on both connected and unconnected sockets.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1051"></a>
🧿 UnixSocket-specific Notes</h3>
<ul>
<li>Retrieve <span class="tt">SO_PASSCRED</span>, buffer sizes, and timeouts using appropriate structures.</li>
<li>Useful for debugging IPC characteristics and system resource tuning.</li>
</ul>
<hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Protocol level (e.g., <span class="tt">SOL_SOCKET</span>, <span class="tt">IPPROTO_TCP</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optName</td><td><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> option name (e.g., <span class="tt">SO_LINGER</span>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to a buffer to receive the option value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len</td><td>Pointer to the size of the buffer. On return, holds the actual size used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid or closed</li>
<li><span class="tt">result</span> or <span class="tt">len</span> is null</li>
<li>The option is unsupported or the system call fails</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible for allocating and sizing the buffer. The <span class="tt">len</span> parameter must be set to the size of the buffer before the call.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>getOption(int, int) For integer-based options </dd>
<dd>
<a class="el" href="#ga04df6377e302cc0cedff070517021950" title="Sets a low-level socket option using a structured or binary value.">setOption(int, int, const void*, socklen_t)</a> For setting structured values </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man2/getsockopt.2.html">https://man7.org/linux/man-pages/man2/getsockopt.2.html</a> </dd></dl>

</div>
</div>
<a id="ga2eaf2835ebba5587c238a0bd6c2be188" name="ga2eaf2835ebba5587c238a0bd6c2be188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eaf2835ebba5587c238a0bd6c2be188">&#9670;&#160;</a></span>getReceiveBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jsocketpp::SocketOptions::getReceiveBufferSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the current receive buffer size (SO_RCVBUF) of the socket. </p>
<p>Queries the operating system for the size of the receive buffer allocated to this socket. This buffer temporarily holds incoming data before it is read by the application. The size is determined by system policy, user configuration, and the value set via <span class="tt"><a class="el" href="#ga69fdecc0aaaef4bbd2826c448a8bbe1d" title="Sets the socket&#39;s receive buffer size (SO_RCVBUF).">setReceiveBufferSize()</a></span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1062"></a>
Applicability</h3>
<p>This method works for:</p><ul>
<li><b>TCP sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>)</b>: Indicates how much inbound data can be queued before blocking or drop.</li>
<li><b>UDP sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</b>: Critical for burst tolerance and loss avoidance.</li>
<li><b>UNIX domain sockets</b>: Supported on most platforms.</li>
<li><b><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></b>: Reflects configuration of the passive socket itself (not accepted sockets).</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1063"></a>
Platform Notes</h3>
<ul>
<li><b>Linux</b>: Returned value is typically <em>twice</em> the requested size due to internal accounting.</li>
<li><b>Windows</b>: Rounded to alignment boundaries; value reflects what was granted, not requested.</li>
<li><b>BSD/macOS</b>: Exact behavior may vary, but returned size reflects the OS’s accepted setting.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1064"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> size = socket.getReceiveBufferSize();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Current OS receive buffer: &quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot; bytes\n&quot;</span>;</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The actual receive buffer size in bytes as allocated by the operating system.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid (e.g., not open or moved-from)</li>
<li>The system call fails (e.g., due to low-level error)</li>
<li>Permissions are insufficient</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To verify that <span class="tt"><a class="el" href="#ga69fdecc0aaaef4bbd2826c448a8bbe1d" title="Sets the socket&#39;s receive buffer size (SO_RCVBUF).">setReceiveBufferSize()</a></span> took effect, compare the returned value here. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga69fdecc0aaaef4bbd2826c448a8bbe1d" title="Sets the socket&#39;s receive buffer size (SO_RCVBUF).">setReceiveBufferSize()</a> </dd>
<dd>
<a class="el" href="#gaeb5f9d1ae3f1b7b9fdb94335b10723f6" title="Retrieves the current send buffer size (SO_SNDBUF) of the socket.">getSendBufferSize()</a> </dd>
<dd>
setInternalBufferSize() </dd></dl>

</div>
</div>
<a id="ga8e8783ada3142cd6c3b275e01b7b12f2" name="ga8e8783ada3142cd6c3b275e01b7b12f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e8783ada3142cd6c3b275e01b7b12f2">&#9670;&#160;</a></span>getReuseAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::getReuseAddress </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries whether the socket is currently configured to allow address reuse. </p>
<p>This method retrieves the state of the <span class="tt">SO_REUSEADDR</span> socket option using <span class="tt">getsockopt()</span>. When enabled, it allows the socket to bind to a local address/port that is already in use or still in the <span class="tt">TIME_WAIT</span> state. This is particularly useful in scenarios such as:</p>
<ul>
<li>Restartable TCP servers that must rebind quickly</li>
<li>UDP or multicast receivers sharing the same port</li>
<li>Clients using fixed local ports across reconnects</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1056"></a>
Platform Behavior</h3>
<ul>
<li><b>POSIX:</b> Multiple sockets can bind the same local address/port if all use <span class="tt">SO_REUSEADDR</span>.</li>
<li><b>Windows:</b> <span class="tt">SO_REUSEADDR</span> allows rebinding to a port in <span class="tt">TIME_WAIT</span>, but does <b>not</b> allow simultaneous binds. Additionally, <span class="tt">SO_EXCLUSIVEADDRUSE</span> is enabled by default and disables reuse — this method reflects the effective state of <span class="tt">SO_REUSEADDR</span>, not <span class="tt">SO_EXCLUSIVEADDRUSE</span>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1057"></a>
Protocol Applicability</h3>
<ul>
<li><b>TCP:</b> Useful for both client and server sockets.</li>
<li><b>UDP:</b> Required for multicast and shared-port scenarios.</li>
<li><b>Unix domain sockets:</b> <span class="tt">SO_REUSEADDR</span> may be supported but is typically a no-op; Unix path conflicts are governed by the file system.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1058"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!socket.getReuseAddress()) {</div>
<div class="line">    socket.setReuseAddress(<span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if address reuse is currently enabled; <span class="tt">false</span> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the socket is invalid or the option cannot be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always call this after socket creation and before <span class="tt">bind()</span> to ensure valid results.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/socket.7.html">https://man7.org/linux/man-pages/man7/socket.7.html</a> </dd></dl>

</div>
</div>
<a id="ga0472e21ad70ac9b778aac3d6177577ca" name="ga0472e21ad70ac9b778aac3d6177577ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0472e21ad70ac9b778aac3d6177577ca">&#9670;&#160;</a></span>getReusePort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::getReusePort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the <span class="tt">SO_REUSEPORT</span> option is currently enabled on the socket. </p>
<p>This method queries the <span class="tt">SO_REUSEPORT</span> setting via <span class="tt">getsockopt()</span> to determine whether the socket is configured to allow multiple bindings to the same address/port.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1174"></a>
🌍 Applicability</h3>
<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>: ✅ Used to verify shared accept-mode configuration</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>: ✅ Useful for multicast receivers or redundant UDP listeners</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>: ✅ Rare, but valid for bound client sockets</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>: ❌ Not applicable — method excluded at compile time</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1176"></a>
🔀 Platform Support</h3>
<ul>
<li>✅ <b>Linux (≥ 3.9)</b>, FreeBSD, macOS (some BSDs require extra sysctls)</li>
<li>❌ <b>Windows</b>: Not supported — this method is not compiled</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1178"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#if defined(SO_REUSEPORT)</span></div>
<div class="line"><span class="keywordflow">if</span> (socket.getReusePort()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Port reuse is enabled.\n&quot;</span>;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Port reuse is not enabled.\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><hr  />
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if <span class="tt">SO_REUSEPORT</span> is enabled on the socket; <span class="tt">false</span> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid or uninitialized</li>
<li>The system call fails (<span class="tt">getsockopt()</span> error)</li>
<li>The option is not supported or the socket type is incompatible</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga05c3ae5067a7d83965249d00c5d564c3" title="Enables or disables the SO_REUSEPORT socket option.">setReusePort()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/socket.7.html">https://man7.org/linux/man-pages/man7/socket.7.html</a> </dd></dl>

</div>
</div>
<a id="gaeb5f9d1ae3f1b7b9fdb94335b10723f6" name="gaeb5f9d1ae3f1b7b9fdb94335b10723f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5f9d1ae3f1b7b9fdb94335b10723f6">&#9670;&#160;</a></span>getSendBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jsocketpp::SocketOptions::getSendBufferSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the current send buffer size (SO_SNDBUF) of the socket. </p>
<p>Queries the operating system for the size of the send buffer allocated to this socket. This buffer holds outgoing data that has been written by the application but not yet transmitted over the network or IPC channel. A larger send buffer allows the socket to tolerate bursts of data or temporary network slowdowns without blocking the writer.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1068"></a>
Applicability</h3>
<p>This method is supported for:</p><ul>
<li><b>TCP sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>)</b>: Improves write throughput and non-blocking behavior.</li>
<li><b>UDP sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</b>: Enables larger bursts of outgoing datagrams.</li>
<li><b>UNIX domain sockets</b>: Applies to stream or datagram sockets on most platforms.</li>
<li><b><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></b>: Returns the buffer size of the passive socket, but has no effect on accepted sockets.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1069"></a>
Platform Notes</h3>
<ul>
<li><b>Linux</b>: May return a value twice the requested size due to kernel bookkeeping.</li>
<li><b>Windows</b>: Returns the actual allocated size, rounded internally by Winsock.</li>
<li><b>BSD/macOS</b>: Behavior follows BSD socket semantics.</li>
<li>System-wide limits may apply, and the kernel may clamp, align, or ignore extreme values.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1070"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> size = socket.getSendBufferSize();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Send buffer size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot; bytes\n&quot;</span>;</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Actual send buffer size in bytes, as reported by the kernel.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid or closed</li>
<li>The <span class="tt">getsockopt()</span> call fails</li>
<li>Permissions are insufficient to query socket settings</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The value returned may differ from what was passed to <span class="tt"><a class="el" href="#ga8279b0c70f6a0fddf73d84aac691422b" title="Sets the socket&#39;s send buffer size (SO_SNDBUF).">setSendBufferSize()</a></span>. Always query after setting to determine the effective size.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8279b0c70f6a0fddf73d84aac691422b" title="Sets the socket&#39;s send buffer size (SO_SNDBUF).">setSendBufferSize()</a> </dd>
<dd>
<a class="el" href="#ga2eaf2835ebba5587c238a0bd6c2be188" title="Retrieves the current receive buffer size (SO_RCVBUF) of the socket.">getReceiveBufferSize()</a> </dd>
<dd>
<a class="el" href="#ga69fdecc0aaaef4bbd2826c448a8bbe1d" title="Sets the socket&#39;s receive buffer size (SO_RCVBUF).">setReceiveBufferSize()</a> </dd></dl>

</div>
</div>
<a id="gaced4c6dc799564ece9ce4e6766b1d794" name="gaced4c6dc799564ece9ce4e6766b1d794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced4c6dc799564ece9ce4e6766b1d794">&#9670;&#160;</a></span>getSocketFd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a> jsocketpp::SocketOptions::getSocketFd </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the native socket handle (file descriptor or OS-level handle). </p>
<p>This method provides low-level access to the socket’s operating system identifier:</p><ul>
<li>On <b>POSIX</b> systems, this is an integer file descriptor (<span class="tt">int</span>)</li>
<li>On <b>Windows</b>, this is a <span class="tt"><a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a></span> handle (<span class="tt">uintptr_t</span>-like)</li>
</ul>
<p>It is intended for <b>advanced use cases only</b>, such as:</p><ul>
<li>Integrating with external event loops (<span class="tt">select()</span>, <span class="tt">poll()</span>, <span class="tt">epoll</span>, <span class="tt">kqueue</span>)</li>
<li>Passing the socket to platform APIs or native libraries</li>
<li>Monitoring socket state or readiness using system primitives</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1008"></a>
⚠️ HANDLE WITH EXTREME CARE</h3>
<p>This method exposes the raw handle <b>without ownership transfer</b>. Misuse may lead to:</p><ul>
<li>Resource leaks (if manually closed)</li>
<li>Double-close or shutdown</li>
<li>Corruption of internal state</li>
<li>Thread-safety issues in multithreaded environments</li>
<li>Broken invariants inside the jsocketpp abstraction</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1010"></a>
✅ Safe Usage Guidelines</h3>
<ul>
<li><b>DO</b> use this handle for non-destructive introspection (e.g., <span class="tt">poll()</span>, <span class="tt">select()</span>)</li>
<li><b>DO NOT</b> call <span class="tt">close()</span>, <span class="tt">shutdown()</span>, or <span class="tt">setsockopt()</span> directly unless you fully understand the consequences</li>
<li><b>DO NOT</b> store the handle beyond the lifetime of the socket object</li>
<li><b>DO NOT</b> share across threads without synchronization</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1012"></a>
Example: Use with <span class="tt">select()</span></h3>
<div class="fragment"><div class="line">fd_set readSet;</div>
<div class="line">FD_ZERO(&amp;readSet);</div>
<div class="line">FD_SET(socket.getSocketFd(), &amp;readSet);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (::select(socket.getSocketFd() + 1, &amp;readSet, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, &amp;timeout) &gt; 0) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Socket is readable!\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The underlying OS-level socket identifier (<span class="tt"><a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a></span> or file descriptor). Returns <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> if the socket is not initialized.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga97706ddf21aab33a18db00bd0b8eb65d" title="Updates the socket descriptor used by this object.">setSocketFd()</a> – Internal method for synchronizing base state </dd>
<dd>
<a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a>, <a class="el" href="#ga6a5264b995eb2a1143f45c5de6ad92c3" title="Retrieves the current value of a low-level socket option.">getOption()</a> </dd>
<dd>
waitReady(), <a class="el" href="#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a> </dd></dl>

</div>
</div>
<a id="ga15ba6d555b0f3b7809c746f827398c5e" name="ga15ba6d555b0f3b7809c746f827398c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15ba6d555b0f3b7809c746f827398c5e">&#9670;&#160;</a></span>getSoLinger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, int &gt; jsocketpp::SocketOptions::getSoLinger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the current <span class="tt">SO_LINGER</span> configuration of the socket. </p>
<p>Queries the operating system for the current linger behavior configured on this socket. Linger settings determine whether the socket blocks on <span class="tt">close()</span> to allow unsent data to be transmitted, or terminates the connection immediately (potentially discarding unsent data).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1074"></a>
🔁 Applicability</h3>
<ul>
<li>✅ <b>TCP sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>)</b>: Fully supported; reflects actual linger settings.</li>
<li>✅ <b>UNIX domain stream sockets</b>: Supported on most POSIX platforms.</li>
<li>⚠️ <b>UDP / datagram sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</b>: <span class="tt">SO_LINGER</span> is silently ignored by most systems.</li>
<li>⚠️ <b><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></b>: Applies only to the passive (listening) socket. To inspect accepted clients, query each returned <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> individually.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1075"></a>
Return Value</h3>
<p>Returns a pair <span class="tt">{enabled, timeout}</span>:</p><ul>
<li><span class="tt">first</span> (<span class="tt">bool</span>): Whether <span class="tt">SO_LINGER</span> is currently enabled.</li>
<li><span class="tt">second</span> (<span class="tt">int</span>): Timeout value in seconds (typically <span class="tt">0</span> if disabled).</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1076"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [enabled, timeout] = socket.getSoLinger();</div>
<div class="line"><span class="keywordflow">if</span> (enabled)</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Linger is enabled for &quot;</span> &lt;&lt; timeout &lt;&lt; <span class="stringliteral">&quot; seconds.\n&quot;</span>;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Linger is disabled.\n&quot;</span>;</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li>The system call fails</li>
<li>The option is unsupported or not implemented on the platform</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga707a637112e5ec1309da4e6dfe2fddb3" title="Configures the socket&#39;s linger behavior (SO_LINGER) during close.">setSoLinger()</a> </dd>
<dd>
shutdown() </dd>
<dd>
close()</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On many platforms, this option is only meaningful for stream-oriented sockets. Behavior for datagram sockets is undefined or silently ignored. </dd></dl>

</div>
</div>
<a id="gaaee02a4007c38decf8925319b9f3e5f2" name="gaaee02a4007c38decf8925319b9f3e5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee02a4007c38decf8925319b9f3e5f2">&#9670;&#160;</a></span>getSoRecvTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jsocketpp::SocketOptions::getSoRecvTimeout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the socket receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds. </p>
<p>This method queries the configured timeout for blocking read operations, such as <span class="tt">read()</span>, <span class="tt">readExact()</span>, <span class="tt">receiveFrom()</span>, etc. The value returned represents the number of milliseconds a read will block before failing with a timeout.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1095"></a>
🔀 Platform Behavior</h3>
<ul>
<li><b>Windows</b>: Returns the timeout directly as an <span class="tt">int</span> in milliseconds.</li>
<li><b>POSIX</b>: Retrieves a <span class="tt">struct timeval</span> and converts it to milliseconds.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1097"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> timeout = socket.getSoRecvTimeout();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Read timeout is &quot;</span> &lt;&lt; timeout &lt;&lt; <span class="stringliteral">&quot; ms\n&quot;</span>;</div>
</div><!-- fragment --><hr  />
<dl class="section return"><dt>Returns</dt><dd>The current receive timeout in milliseconds. A value of <span class="tt">0</span> indicates no timeout (i.e., blocking indefinitely).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li><span class="tt">getsockopt()</span> fails</li>
<li>The timeout cannot be retrieved due to system-level error</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a> </dd>
<dd>
<a class="el" href="#ga1bef2499ed5c13367dc73752484298c0" title="Retrieves the socket send timeout (SO_SNDTIMEO) in milliseconds.">getSoSendTimeout()</a> </dd></dl>

</div>
</div>
<a id="ga1bef2499ed5c13367dc73752484298c0" name="ga1bef2499ed5c13367dc73752484298c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bef2499ed5c13367dc73752484298c0">&#9670;&#160;</a></span>getSoSendTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jsocketpp::SocketOptions::getSoSendTimeout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the socket send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds. </p>
<p>This method queries the configured timeout for blocking send operations, such as <span class="tt">write()</span>, <span class="tt">writeAll()</span>, or <span class="tt">sendTo()</span>. The returned value represents how long a send operation will block before timing out.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1100"></a>
🔀 Platform Behavior</h3>
<ul>
<li><b>Windows</b>: Timeout is retrieved as a plain <span class="tt">int</span> (milliseconds).</li>
<li><b>POSIX</b>: The timeout is stored in a <span class="tt">struct timeval</span> and converted back.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1102"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> timeout = socket.getSoSendTimeout();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Send timeout is &quot;</span> &lt;&lt; timeout &lt;&lt; <span class="stringliteral">&quot; ms\n&quot;</span>;</div>
</div><!-- fragment --><hr  />
<dl class="section return"><dt>Returns</dt><dd>The current send timeout in milliseconds. A value of <span class="tt">0</span> indicates no timeout (i.e., blocking indefinitely).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li><span class="tt">getsockopt()</span> fails</li>
<li>The system reports an unexpected or unsupported configuration</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7107a9da459b00bf39ec2fe4d3e83396" title="Sets the socket send timeout (SO_SNDTIMEO) in milliseconds.">setSoSendTimeout()</a> </dd>
<dd>
<a class="el" href="#gaaee02a4007c38decf8925319b9f3e5f2" title="Retrieves the socket receive timeout (SO_RCVTIMEO) in milliseconds.">getSoRecvTimeout()</a> </dd></dl>

</div>
</div>
<a id="ga7829c558cb7bf5e0a46d882df82acc19" name="ga7829c558cb7bf5e0a46d882df82acc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7829c558cb7bf5e0a46d882df82acc19">&#9670;&#160;</a></span>getSoTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jsocketpp::ServerSocket::getSoTimeout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the logical timeout (in milliseconds) for accept operations. </p>
<p>This value determines how long methods like <span class="tt"><a class="el" href="group__tcp.html#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> and <span class="tt"><a class="el" href="group__tcp.html#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a></span> will wait for an incoming client connection before timing out. It is used internally by <span class="tt">select()</span> or similar readiness mechanisms.</p>
<dl class="section note"><dt>Note</dt><dd>This timeout is a logical userland timeout and does <b>not</b> affect the socket descriptor via <span class="tt">setsockopt()</span> (unlike <span class="tt">Socket::getSoTimeout()</span>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The configured accept timeout in milliseconds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2087f337f22de16821132208b94b1441" title="Set the logical timeout (in milliseconds) for accepting client connections.">setSoTimeout()</a> </dd>
<dd>
<a class="el" href="group__tcp.html#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a> </dd>
<dd>
<a class="el" href="group__tcp.html#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a> </dd></dl>

</div>
</div>
<a id="ga05137fbdc55ab065739e220b7a4f41c0" name="ga05137fbdc55ab065739e220b7a4f41c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05137fbdc55ab065739e220b7a4f41c0">&#9670;&#160;</a></span>getTcpNoDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::getTcpNoDelay </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries whether Nagle's algorithm (<span class="tt">TCP_NODELAY</span>) is currently disabled. </p>
<p>This method checks if <span class="tt">TCP_NODELAY</span> is set on the socket, which controls the behavior of <b>Nagle's algorithm</b> for TCP connections. When <span class="tt">TCP_NODELAY</span> is enabled (<span class="tt">true</span>), small writes are sent immediately without waiting to coalesce packets. When disabled (<span class="tt">false</span>), the system may buffer small packets to improve network efficiency.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1130"></a>
🔍 Applicability</h3>
<p>This option applies only to:</p><ul>
<li>TCP stream sockets (<span class="tt">SOCK_STREAM</span> with <span class="tt">AF_INET</span> or <span class="tt">AF_INET6</span>)</li>
</ul>
<p>It does <b>not</b> apply to:</p><ul>
<li>UDP sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</li>
<li>UNIX domain sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>)</li>
<li>Listening sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>) — check accepted <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> objects instead</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1132"></a>
Use Cases</h3>
<ul>
<li>Determine latency behavior at runtime</li>
<li>Validate low-latency configuration in unit tests</li>
<li>Debug unexpected TCP buffering issues</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1134"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!socket.getTcpNoDelay()) {</div>
<div class="line">    socket.setTcpNoDelay(<span class="keyword">true</span>);  <span class="comment">// Reduce latency</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if Nagle's algorithm is disabled (<span class="tt">TCP_NODELAY = 1</span>), <span class="tt">false</span> if Nagle’s algorithm is enabled (<span class="tt">TCP_NODELAY = 0</span>)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid or closed</li>
<li>The option is not supported on the current socket type</li>
<li>A system-level query fails (<span class="tt">getsockopt()</span> error)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga9839dd8837c7519a627f28b3a4c7a513" title="Enables or disables Nagle’s algorithm (TCP_NODELAY) on TCP sockets.">setTcpNoDelay()</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">https://en.wikipedia.org/wiki/Nagle%27s_algorithm</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/tcp.7.html">https://man7.org/linux/man-pages/man7/tcp.7.html</a> </dd></dl>

</div>
</div>
<a id="gad11b9d3378834eab9c28e32e70fc249a" name="gad11b9d3378834eab9c28e32e70fc249a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad11b9d3378834eab9c28e32e70fc249a">&#9670;&#160;</a></span>getTimeToLive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jsocketpp::MulticastSocket::getTimeToLive </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current default multicast TTL / hop limit cached on this socket. </p>
<p>Returns this object’s <b>cached</b> per-socket default scope for outbound <b>multicast</b> transmissions as last set via <a class="el" href="group__udp.html#ga72172a10bc5ba13a908f31c791c90ec5">setTimeToLive(int)</a>. It does <b>not</b> perform a fresh kernel query and does <b>not</b> affect any state.</p>
<p>Semantics of the returned value (applies to multicast only):</p><ul>
<li><span class="tt">0</span> — restricted to the local host (no network egress);</li>
<li><span class="tt">1</span> — restricted to the local link / subnet (commonly the default);</li>
<li><span class="tt">32</span> — typically site scope;</li>
<li><span class="tt">64</span> — typically region scope;</li>
<li><span class="tt">128</span> — typically continent scope;</li>
<li><span class="tt">255</span> — unrestricted (global), subject to network policy.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The cached multicast TTL / hop-limit in the range <span class="tt">[0, 255]</span>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None. This is a read-only accessor.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>No side effects; socket and object state are unchanged.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This accessor reports the value cached by this class (e.g., updated by <a class="el" href="group__udp.html#ga72172a10bc5ba13a908f31c791c90ec5">setTimeToLive(int)</a>). If other code changes the OS-level default directly (e.g., via <a class="el" href="#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> on <a class="el" href="classjsocketpp_1_1SocketOptions.html">SocketOptions</a>), this cached value may not reflect the kernel’s current setting.</li>
<li>The value applies to <b>multicast</b> only. Unicast scope is controlled by <span class="tt">IP_TTL</span> / <span class="tt">IPV6_UNICAST_HOPS</span>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="group__udp.html#ga72172a10bc5ba13a908f31c791c90ec5">setTimeToLive(int)</a> — update this cached default and the OS setting.</li>
<li><a class="el" href="#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL()</a> — query the OS-level default (fresh <span class="tt">getsockopt</span>).</li>
<li><a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> / <a class="el" href="#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> — control/query local delivery of this socket’s own multicast.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Ensure at least link-local reach for multicast</span></div>
<div class="line"><span class="keywordflow">if</span> (sock.getTimeToLive() &lt; 1) {</div>
<div class="line">    sock.setTimeToLive(1);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga10fe0331596fddffb6dbd483c95a2490" name="ga10fe0331596fddffb6dbd483c95a2490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10fe0331596fddffb6dbd483c95a2490">&#9670;&#160;</a></span>is_ipv4_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::is_ipv4_multicast </td>
          <td>(</td>
          <td class="paramtype">const in_addr</td>          <td class="paramname"><span class="paramname"><em>v4</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether an IPv4 address is in the multicast range (224.0.0.0/4). </p>
<p>Lightweight predicate that checks if <code class="param">v4</code> lies within the IPv4 multicast block <b>224.0.0.0/4</b> (i.e., 224.0.0.0–239.255.255.255). Internally uses the standard <span class="tt">IN_MULTICAST()</span> macro against the host-order form of the address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v4</td><td>IPv4 address in a POSIX <span class="tt">in_addr</span> struct. <b>Byte order:</b> <span class="tt">v4.s_addr</span> must be in <b>network byte order</b> (as produced by <span class="tt">inet_pton(AF_INET, ...)</span> or stored in socket APIs). This helper converts to host order before evaluation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the address is multicast; otherwise <span class="tt">false</span>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None. The function is total for any <span class="tt">in_addr</span> value.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>No side effects. This function is <span class="tt">constexpr</span>-friendly in spirit (not declared <span class="tt">constexpr</span> purely due to macro use) and <b>thread-safe</b>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Byte order</dt><dd><ul>
<li><span class="tt">IN_MULTICAST()</span> expects a host-order 32-bit address. This helper applies <span class="tt">ntohl(v4.s_addr)</span> to ensure correctness regardless of caller endianness.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Implementation notes</dt><dd><ul>
<li>Equivalent to: <span class="tt">return IN_MULTICAST(ntohl(v4.s_addr)) != 0;</span></li>
<li>This check does <b>not</b> validate group semantics beyond the range test (e.g., administratively scoped subranges). Use it as a fast guard before calling join/leave APIs.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="#ga65375075d5e7b8009730e0d28b199d73">joinGroupIPv4(in_addr, in_addr)</a></li>
<li><a class="el" href="#ga31401a44675c8fd07c2e80a674106ce9">leaveGroupIPv4(in_addr, in_addr)</a></li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example 1: literal parse and check</span></div>
<div class="line">in_addr g{};</div>
<div class="line"><span class="keywordflow">if</span> (inet_pton(AF_INET, <span class="stringliteral">&quot;239.1.2.3&quot;</span>, &amp;g) != 1)</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;invalid IPv4 address&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="#ga10fe0331596fddffb6dbd483c95a2490">SocketOptions::is_ipv4_multicast</a>(g))</div>
<div class="line">    <span class="keywordflow">throw</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>(<span class="stringliteral">&quot;Expected an IPv4 multicast address&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example 2: reject non-multicast</span></div>
<div class="line">in_addr u{};</div>
<div class="line">inet_pton(AF_INET, <span class="stringliteral">&quot;192.168.1.10&quot;</span>, &amp;u);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga10fe0331596fddffb6dbd483c95a2490">SocketOptions::is_ipv4_multicast</a>(u)) {</div>
<div class="line">    <span class="comment">// unreachable in this example</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example 3: guard before joining a group</span></div>
<div class="line">in_addr iface{}; iface.s_addr = htonl(INADDR_ANY);</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="#ga10fe0331596fddffb6dbd483c95a2490">SocketOptions::is_ipv4_multicast</a>(g))</div>
<div class="line">    <span class="keywordflow">throw</span> SocketException(<span class="stringliteral">&quot;Not a multicast group&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ga65375075d5e7b8009730e0d28b199d73">joinGroupIPv4</a>(g, iface);</div>
<div class="ttc" id="aclassjsocketpp_1_1SocketException_html"><div class="ttname"><a href="classjsocketpp_1_1SocketException.html">jsocketpp::SocketException</a></div><div class="ttdoc">Represents socket-related errors in the jsocketpp library.</div><div class="ttdef"><b>Definition</b> SocketException.hpp:63</div></div>
<div class="ttc" id="agroup__socketopts_html_ga10fe0331596fddffb6dbd483c95a2490"><div class="ttname"><a href="#ga10fe0331596fddffb6dbd483c95a2490">jsocketpp::SocketOptions::is_ipv4_multicast</a></div><div class="ttdeci">static bool is_ipv4_multicast(const in_addr v4)</div><div class="ttdoc">Test whether an IPv4 address is in the multicast range (224.0.0.0/4).</div><div class="ttdef"><b>Definition</b> SocketOptions.hpp:2370</div></div>
<div class="ttc" id="agroup__socketopts_html_ga65375075d5e7b8009730e0d28b199d73"><div class="ttname"><a href="#ga65375075d5e7b8009730e0d28b199d73">jsocketpp::SocketOptions::joinGroupIPv4</a></div><div class="ttdeci">void joinGroupIPv4(in_addr group, in_addr iface)</div><div class="ttdoc">Join an IPv4 any-source multicast (ASM) group on a specific interface.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:470</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga10be210b19c0e6d6deb641cb74ed1c0a" name="ga10be210b19c0e6d6deb641cb74ed1c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10be210b19c0e6d6deb641cb74ed1c0a">&#9670;&#160;</a></span>is_ipv6_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::SocketOptions::is_ipv6_multicast </td>
          <td>(</td>
          <td class="paramtype">const in6_addr &amp;</td>          <td class="paramname"><span class="paramname"><em>v6</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether an IPv6 address is in the multicast range (ff00::/8). </p>
<p>Lightweight predicate that checks if <code class="param">v6</code> lies within the IPv6 multicast prefix <b>ff00::/8</b>. Internally uses the standard <span class="tt">IN6_IS_ADDR_MULTICAST()</span> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v6</td><td>IPv6 address in a POSIX <span class="tt">in6_addr</span> struct. No byte-order adjustment is required by the caller; the macro reads the struct fields directly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the address is multicast; otherwise <span class="tt">false</span>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>None. The function is total for any <span class="tt">in6_addr</span> value.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>No side effects; <b>thread-safe</b>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Scope vs. membership</dt><dd><ul>
<li>This helper only verifies membership in <span class="tt">ff00::/8</span>. It does <b>not</b> report the multicast <b>scope</b> (node, link, site, org, global). If you need scope, consult the standard predicates such as: <span class="tt">IN6_IS_ADDR_MC_NODELOCAL</span>, <span class="tt">IN6_IS_ADDR_MC_LINKLOCAL</span>, <span class="tt">IN6_IS_ADDR_MC_SITELOCAL</span>, etc., depending on your platform.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Implementation notes</dt><dd><ul>
<li>Equivalent to: <span class="tt">return IN6_IS_ADDR_MULTICAST(&amp;v6) != 0;</span></li>
<li>Use as a fast guard prior to join/leave calls for IPv6 groups.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="#ga26253ae313b6ef1417af775668ffbf24">joinGroupIPv6(in6_addr, unsigned int)</a></li>
<li><a class="el" href="#ga99ae2e1e73aa0ddb9b00377a0b888285">leaveGroupIPv6(in6_addr, unsigned int)</a></li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example 1: literal parse and check</span></div>
<div class="line">in6_addr g6{};</div>
<div class="line"><span class="keywordflow">if</span> (inet_pton(AF_INET6, <span class="stringliteral">&quot;ff02::1&quot;</span>, &amp;g6) != 1)</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;invalid IPv6 address&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="#ga10be210b19c0e6d6deb641cb74ed1c0a">SocketOptions::is_ipv6_multicast</a>(g6))</div>
<div class="line">    <span class="keywordflow">throw</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>(<span class="stringliteral">&quot;Expected an IPv6 multicast address&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example 2: reject non-multicast</span></div>
<div class="line">in6_addr u6{};</div>
<div class="line">inet_pton(AF_INET6, <span class="stringliteral">&quot;2001:db8::1&quot;</span>, &amp;u6);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga10be210b19c0e6d6deb641cb74ed1c0a">SocketOptions::is_ipv6_multicast</a>(u6)) {</div>
<div class="line">    <span class="comment">// unreachable in this example</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example 3: guard before joining a group (interface index 0 = default)</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ifindex = 0;</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="#ga10be210b19c0e6d6deb641cb74ed1c0a">SocketOptions::is_ipv6_multicast</a>(g6))</div>
<div class="line">    <span class="keywordflow">throw</span> SocketException(<span class="stringliteral">&quot;Not a multicast group&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="#ga26253ae313b6ef1417af775668ffbf24">joinGroupIPv6</a>(g6, ifindex);</div>
<div class="ttc" id="agroup__socketopts_html_ga10be210b19c0e6d6deb641cb74ed1c0a"><div class="ttname"><a href="#ga10be210b19c0e6d6deb641cb74ed1c0a">jsocketpp::SocketOptions::is_ipv6_multicast</a></div><div class="ttdeci">static bool is_ipv6_multicast(const in6_addr &amp;v6)</div><div class="ttdoc">Test whether an IPv6 address is in the multicast range (ff00::/8).</div><div class="ttdef"><b>Definition</b> SocketOptions.hpp:2430</div></div>
<div class="ttc" id="agroup__socketopts_html_ga26253ae313b6ef1417af775668ffbf24"><div class="ttname"><a href="#ga26253ae313b6ef1417af775668ffbf24">jsocketpp::SocketOptions::joinGroupIPv6</a></div><div class="ttdeci">void joinGroupIPv6(in6_addr group, unsigned int ifindex)</div><div class="ttdoc">Join an IPv6 any-source multicast (ASM) group on a specific interface index.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:500</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gad113886a7cc6100e5ef2c25ea504696e" name="gad113886a7cc6100e5ef2c25ea504696e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad113886a7cc6100e5ef2c25ea504696e">&#9670;&#160;</a></span>isPassiveSocket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jsocketpp::ServerSocket::isPassiveSocket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies this socket as a passive (listening) socket. </p>
<p>Overrides the base <span class="tt"><a class="el" href="#gaace6c3364b4016979537571b36c58727" title="Indicates whether the socket behaves as a passive (listening) socket.">SocketOptions::isPassiveSocket()</a></span> to return <span class="tt">true</span>, indicating that this <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> instance is intended to accept incoming connections rather than initiate outbound ones.</p>
<p>This designation is important for platform-specific behaviors — particularly on Windows, where passive sockets use <span class="tt">SO_EXCLUSIVEADDRUSE</span> instead of <span class="tt">SO_REUSEADDR</span> to control address reuse semantics. The <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> interface uses this signal to select the correct option and logic in <span class="tt"><a class="el" href="#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a></span> and <span class="tt"><a class="el" href="#ga8e8783ada3142cd6c3b275e01b7b12f2" title="Queries whether the socket is currently configured to allow address reuse.">getReuseAddress()</a></span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md835"></a>
When <span class="tt">true</span> matters</h3>
<ul>
<li>Enables use of <span class="tt">SO_EXCLUSIVEADDRUSE</span> on Windows</li>
<li>Prevents unsafe or misleading reuse logic on listening sockets</li>
<li>Helps unify reuse handling logic across all socket types in a central place</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Always returns <span class="tt">true</span> for <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> to indicate passive socket behavior.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaace6c3364b4016979537571b36c58727" title="Indicates whether the socket behaves as a passive (listening) socket.">SocketOptions::isPassiveSocket()</a> </dd>
<dd>
<a class="el" href="#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">SocketOptions::setReuseAddress()</a> </dd>
<dd>
<a class="el" href="#ga8e8783ada3142cd6c3b275e01b7b12f2" title="Queries whether the socket is currently configured to allow address reuse.">SocketOptions::getReuseAddress()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="#gaace6c3364b4016979537571b36c58727">jsocketpp::SocketOptions</a>.</p>

</div>
</div>
<a id="gaace6c3364b4016979537571b36c58727" name="gaace6c3364b4016979537571b36c58727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaace6c3364b4016979537571b36c58727">&#9670;&#160;</a></span>isPassiveSocket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool jsocketpp::SocketOptions::isPassiveSocket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the socket behaves as a passive (listening) socket. </p>
<p>This virtual method is used internally by the <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> interface to determine whether the socket is operating in a <em>passive role</em> — that is, it is a listening socket typically created by a server to accept incoming connections. This distinction is particularly relevant on platforms like Windows, where different socket options apply to passive vs. active sockets.</p>
<p>Specifically, this affects how address reuse logic is applied:</p><ul>
<li>On Windows, <span class="tt">SO_EXCLUSIVEADDRUSE</span> is used for passive sockets to control port reuse semantics.</li>
<li>On POSIX systems, all sockets use <span class="tt">SO_REUSEADDR</span>, but server sockets may still follow different best practices.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1182"></a>
Usage</h3>
<ul>
<li>Override this method in subclasses like <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> to return <span class="tt">true</span>.</li>
<li>Leave it as <span class="tt">false</span> (default) in client sockets, UDP sockets, or Unix domain sockets.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the socket is used in a listening or acceptor role; <span class="tt">false</span> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method has no direct side effects. It exists purely to guide conditional logic in reusable base class operations such as <span class="tt"><a class="el" href="#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a></span> and <span class="tt"><a class="el" href="#ga8e8783ada3142cd6c3b275e01b7b12f2" title="Queries whether the socket is currently configured to allow address reuse.">getReuseAddress()</a></span>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a> </dd>
<dd>
<a class="el" href="#ga8e8783ada3142cd6c3b275e01b7b12f2" title="Queries whether the socket is currently configured to allow address reuse.">getReuseAddress()</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> </dd></dl>

<p>Reimplemented in <a class="el" href="#gad113886a7cc6100e5ef2c25ea504696e">jsocketpp::ServerSocket</a>.</p>

</div>
</div>
<a id="ga65375075d5e7b8009730e0d28b199d73" name="ga65375075d5e7b8009730e0d28b199d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65375075d5e7b8009730e0d28b199d73">&#9670;&#160;</a></span>joinGroupIPv4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::joinGroupIPv4 </td>
          <td>(</td>
          <td class="paramtype">in_addr</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in_addr</td>          <td class="paramname"><span class="paramname"><em>iface</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an IPv4 any-source multicast (ASM) group on a specific interface. </p>
<p>Joins <code class="param">group</code> on the IPv4 interface identified by <code class="param">iface</code>. The interface must be specified by its unicast IPv4 address (network order). Use {INADDR_ANY} to let the stack choose a default interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Multicast group address (network order). Must satisfy IN_MULTICAST(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>Local interface address (network order). Use {INADDR_ANY} for default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is invalid, <code class="param">group</code> is not multicast, or the underlying <span class="tt">setsockopt(IP_ADD_MEMBERSHIP)</span> fails. Error text is produced by <span class="tt">SocketErrorMessage(...)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26253ae313b6ef1417af775668ffbf24" name="ga26253ae313b6ef1417af775668ffbf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26253ae313b6ef1417af775668ffbf24">&#9670;&#160;</a></span>joinGroupIPv6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::joinGroupIPv6 </td>
          <td>(</td>
          <td class="paramtype">in6_addr</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>ifindex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an IPv6 any-source multicast (ASM) group on a specific interface index. </p>
<p>Joins <code class="param">group</code> on the interface identified by <code class="param">ifindex</code>. Use 0 for the default interface. <code class="param">group</code> must be a multicast address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>IPv6 multicast group address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifindex</td><td>IPv6 interface index (0 for default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the socket is invalid, <code class="param">group</code> is not multicast, or the underlying <span class="tt">setsockopt(IPV6_JOIN_GROUP)</span> (POSIX) or <span class="tt">IPV6_ADD_MEMBERSHIP</span> (Windows) fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31401a44675c8fd07c2e80a674106ce9" name="ga31401a44675c8fd07c2e80a674106ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31401a44675c8fd07c2e80a674106ce9">&#9670;&#160;</a></span>leaveGroupIPv4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::leaveGroupIPv4 </td>
          <td>(</td>
          <td class="paramtype">in_addr</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in_addr</td>          <td class="paramname"><span class="paramname"><em>iface</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a previously joined IPv4 multicast group on a specific interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Multicast group address (network order). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>Interface address used when joining (network order).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>on failure of <span class="tt">setsockopt(IP_DROP_MEMBERSHIP)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99ae2e1e73aa0ddb9b00377a0b888285" name="ga99ae2e1e73aa0ddb9b00377a0b888285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ae2e1e73aa0ddb9b00377a0b888285">&#9670;&#160;</a></span>leaveGroupIPv6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::leaveGroupIPv6 </td>
          <td>(</td>
          <td class="paramtype">in6_addr</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>ifindex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a previously joined IPv6 multicast group on a specific interface index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>IPv6 multicast group address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifindex</td><td>Interface index used when joining.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>on failure of <span class="tt">IPV6_LEAVE_GROUP</span> (POSIX) or <span class="tt">IPV6_DROP_MEMBERSHIP</span> (Windows). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd5f26363d219e39f4a8fbce1bec758a" name="gacd5f26363d219e39f4a8fbce1bec758a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5f26363d219e39f4a8fbce1bec758a">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> &amp; jsocketpp::SocketOptions::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator (deleted) for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>. </p>
<p>The copy assignment operator is explicitly deleted to prevent reassignment between <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> instances. Copying would duplicate the socket handle without transferring ownership, leading to potential issues such as:</p>
<ul>
<li>Double <span class="tt">close()</span> calls on the same socket</li>
<li>Confusing ownership semantics</li>
<li>Race conditions in multithreaded environments</li>
</ul>
<p>This deletion is consistent with the rest of the socket library, where all socket classes are designed to be non-copyable and resource-owning via RAII.</p>
<dl class="section note"><dt>Note</dt><dd>Use move assignment (<span class="tt">operator=(<a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>&amp;&amp;)</span>) to transfer ownership safely.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> a(sockFd);</div>
<div class="line"><a class="code hl_function" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> b;</div>
<div class="line">b = a; <span class="comment">// ❌ Compilation error (copy assignment is deleted)</span></div>
<div class="ttc" id="agroup__socketopts_html_ga9e263722ea800db82c34769d8f49be3a"><div class="ttname"><a href="#ga9e263722ea800db82c34769d8f49be3a">jsocketpp::SocketOptions::SocketOptions</a></div><div class="ttdeci">SocketOptions()=delete</div><div class="ttdoc">Default constructor (deleted) for SocketOptions base class.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac396d98978063f302938aa9ee80bf634" title="Move assignment operator for SocketOptions.">operator=(SocketOptions&amp;&amp;)</a> noexcept </dd></dl>

</div>
</div>
<a id="gac396d98978063f302938aa9ee80bf634" name="gac396d98978063f302938aa9ee80bf634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac396d98978063f302938aa9ee80bf634">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> &amp; jsocketpp::SocketOptions::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>. </p>
<p>Transfers the socket handle (<span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a></span>) and internal state from another <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> instance to this one. Any existing state in the current object is overwritten. The moved-from object is left in a valid but unspecified state (usually with <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a> == <a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>).</p>
<p>This operator supports efficient reassignment of socket resources in derived classes while preserving RAII guarantees and preventing resource leaks.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1006"></a>
Rationale</h3>
<ul>
<li>Allows efficient reassignment of socket wrappers</li>
<li>Ensures only one object retains ownership of the socket handle</li>
<li>Preserves safe ownership semantics across the library</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The moved-from object should not be used after assignment.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> a(sockFd1);</div>
<div class="line"><a class="code hl_function" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> b(sockFd2);</div>
<div class="line">b = std::move(a); <span class="comment">// ✅ b now owns sockFd1, sockFd2 is released or overwritten</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga244a62ac8b74854e58066a242976793d" title="Move constructor for SocketOptions.">SocketOptions(SocketOptions&amp;&amp;)</a> noexcept </dd></dl>

</div>
</div>
<a id="gacb9e27d93d3107ad8641fa7a179658c6" name="gacb9e27d93d3107ad8641fa7a179658c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9e27d93d3107ad8641fa7a179658c6">&#9670;&#160;</a></span>setBroadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setBroadcast </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the ability to send UDP broadcast messages. </p>
<p>This method sets the <span class="tt">SO_BROADCAST</span> socket option, which allows the socket to send datagrams to broadcast addresses (e.g., <span class="tt">255.255.255.255</span> or <span class="tt">192.168.1.255</span>).</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1137"></a>
🌍 Applicability</h3>
<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>: ✅ Required for broadcasting over UDP</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (TCP): ❌ Not applicable — will throw</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>: ❌ Not applicable</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>: ❌ Not applicable</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1139"></a>
🔐 Platform Behavior</h3>
<ul>
<li>Most OSes require <span class="tt">SO_BROADCAST = 1</span> before sending to broadcast addresses</li>
<li>Without it, <span class="tt">sendto()</span> to a broadcast address may fail with <span class="tt">EACCES</span> or <span class="tt">Permission denied</span></li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1141"></a>
Use Cases</h3>
<ul>
<li>UDP service discovery (e.g., mDNS, SSDP)</li>
<li>Device presence announcements</li>
<li>Peer-to-peer local communication</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1143"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1DatagramSocket.html">DatagramSocket</a> sock(AF_INET);</div>
<div class="line">sock.setBroadcast(<span class="keyword">true</span>);</div>
<div class="line">sock.bind(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 0);</div>
<div class="line"> </div>
<div class="line">sockaddr_in broadcastAddr = {};</div>
<div class="line">broadcastAddr.sin_family = AF_INET;</div>
<div class="line">broadcastAddr.sin_port = htons(12345);</div>
<div class="line">inet_pton(AF_INET, <span class="stringliteral">&quot;255.255.255.255&quot;</span>, &amp;broadcastAddr.sin_addr);</div>
<div class="line"> </div>
<div class="line">sock.sendTo(<span class="stringliteral">&quot;Hello LAN&quot;</span>, <span class="keyword">reinterpret_cast&lt;</span>sockaddr*<span class="keyword">&gt;</span>(&amp;broadcastAddr), <span class="keyword">sizeof</span>(broadcastAddr));</div>
<div class="ttc" id="aclassjsocketpp_1_1DatagramSocket_html"><div class="ttname"><a href="classjsocketpp_1_1DatagramSocket.html">jsocketpp::DatagramSocket</a></div><div class="ttdoc">Cross-platform UDP socket class with Java-style interface.</div><div class="ttdef"><b>Definition</b> DatagramSocket.hpp:484</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">on</td><td><span class="tt">true</span> to enable broadcast permission, <span class="tt">false</span> to disable it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li>The option is not supported by the socket type</li>
<li>The system call fails (e.g., <span class="tt">EBADF</span>, <span class="tt">ENOPROTOOPT</span>, <span class="tt">EACCES</span>)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab0df7d40f7d6b40737cbf3271be57f37" title="Checks whether the socket is currently allowed to send broadcast messages.">getBroadcast()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/socket.7.html">https://man7.org/linux/man-pages/man7/socket.7.html</a> </dd></dl>

</div>
</div>
<a id="gab96d6fa640ac34113cb1f76bfbf970dc" name="gab96d6fa640ac34113cb1f76bfbf970dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab96d6fa640ac34113cb1f76bfbf970dc">&#9670;&#160;</a></span>setIPv6Only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setIPv6Only </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables <span class="tt">IPV6_V6ONLY</span> mode for IPv6-capable sockets. </p>
<p>This method configures the <span class="tt">IPV6_V6ONLY</span> socket option, which determines whether an IPv6 socket can accept <b>only</b> IPv6 connections or <b>both</b> IPv6 and IPv4-mapped addresses (e.g., <span class="tt">::ffff:a.b.c.d</span>).</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1151"></a>
🌍 Applicability by Socket Type</h3>
<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>: ✅ Common — determines which protocols are accepted via <span class="tt">bind()</span></li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>: ✅ Optional — may control behavior of outgoing connections or bound local endpoint</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>: ✅ Applies when binding to <span class="tt">::</span> for dual-stack multicast or receiving</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>: ❌ Not applicable — local domain sockets do not use IP protocols</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1153"></a>
🔀 Platform Behavior</h3>
<ul>
<li><b>Linux</b>: <span class="tt">IPV6_V6ONLY</span> defaults to <span class="tt">0</span> (dual-stack enabled)</li>
<li><b>Windows</b>: Defaults to <span class="tt">1</span> (IPv6-only); must disable explicitly for dual-stack</li>
<li><b>macOS / BSD</b>: Often defaults to <span class="tt">1</span>, some systems disallow disabling</li>
</ul>
<p>⚠️ On all platforms, this option <b>must be set before <span class="tt">bind()</span></b>. Changing it afterward is undefined or ignored.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1155"></a>
💡 Use Cases</h3>
<ul>
<li>Enforce strict IPv6-only policy (security or protocol compliance)</li>
<li>Enable dual-stack sockets that handle both IPv6 and IPv4 transparently</li>
<li>Configure UDP or multicast receivers to receive from both protocol families</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1157"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1ServerSocket.html">ServerSocket</a> server(AF_INET6);</div>
<div class="line">server.setIPv6Only(<span class="keyword">true</span>);      <span class="comment">// Only allow IPv6 clients</span></div>
<div class="line">server.bind(<span class="stringliteral">&quot;::&quot;</span>, 8080);</div>
<div class="line">server.listen();</div>
<div class="ttc" id="aclassjsocketpp_1_1ServerSocket_html"><div class="ttname"><a href="classjsocketpp_1_1ServerSocket.html">jsocketpp::ServerSocket</a></div><div class="ttdoc">TCP server socket abstraction for cross-platform C++ networking.</div><div class="ttdef"><b>Definition</b> ServerSocket.hpp:100</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><span class="tt">true</span> to enable IPv6-only mode (<span class="tt">IPV6_V6ONLY = 1</span>), <span class="tt">false</span> to allow dual-stack operation (<span class="tt">IPV6_V6ONLY = 0</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is not valid</li>
<li>The option is unsupported on the platform or socket type</li>
<li>The system call (<span class="tt">setsockopt()</span>) fails</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This setting has no effect on UNIX domain sockets, and calling it on one will throw.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1d44e7f23739c1ef4a9ad550b4a1ff1d" title="Queries whether the IPV6_V6ONLY option is enabled on this socket.">getIPv6Only()</a> </dd>
<dd>
<a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/ipv6.7.html">https://man7.org/linux/man-pages/man7/ipv6.7.html</a> </dd></dl>

</div>
</div>
<a id="gab3fbb8682b1313dc38abddd541ca4abf" name="gab3fbb8682b1313dc38abddd541ca4abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3fbb8682b1313dc38abddd541ca4abf">&#9670;&#160;</a></span>setKeepAlive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setKeepAlive </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables TCP-level keepalive behavior on the socket (<span class="tt">SO_KEEPALIVE</span>). </p>
<p>Configures the <span class="tt">SO_KEEPALIVE</span> socket option, which instructs the operating system to periodically send keepalive probes on otherwise idle <b>stream-oriented sockets</b>. This helps detect half-open connections where the remote peer has silently disconnected, crashed, or become unreachable without sending a FIN or RST.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1077"></a>
🔁 Applicability</h3>
<ul>
<li>✅ <b>TCP sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>)</b>: Fully supported and commonly used.</li>
<li>✅ <b>UNIX domain stream sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>)</b>: Supported on most POSIX platforms.</li>
<li>✅ <b>Accepted client sockets in <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span></b>: Enable per-socket after <span class="tt">accept()</span>.</li>
<li>⚠️ <b>UDP or datagram sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</b>: Not applicable. Most systems ignore this flag.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1078"></a>
Platform Behavior</h3>
<ul>
<li><b>Linux</b>: Keepalive timing is controlled by <span class="tt">/proc/sys/net/ipv4/tcp_keepalive_*</span> parameters. Per-socket tuning (e.g., idle, interval, probes) is available using advanced options (not exposed here).</li>
<li><b>Windows</b>: Default timeout is ~2 hours. Fine-tuning requires <span class="tt">WSAIoctl</span> with <span class="tt">SIO_KEEPALIVE_VALS</span>.</li>
<li><b>macOS/BSD</b>: Controlled by system-level TCP settings; per-socket control is limited.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1079"></a>
Effects</h3>
<ul>
<li>If enabled (<span class="tt">on == true</span>), the OS sends periodic probes on idle connections. If the peer does not respond after several attempts, the connection is forcefully closed.</li>
<li>If disabled (<span class="tt">on == false</span>), no keepalive probes are sent. The socket may remain open indefinitely.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1080"></a>
Example</h3>
<div class="fragment"><div class="line">socket.setKeepAlive(<span class="keyword">true</span>);  <span class="comment">// Enable periodic liveness checks on TCP</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">on</td><td>Set to <span class="tt">true</span> to enable keepalive, or <span class="tt">false</span> to disable it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li><span class="tt">SO_KEEPALIVE</span> is unsupported for this socket type</li>
<li>The system call fails due to platform-level constraints</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1193748a866e07a7f25e97a0640ad8dd" title="Checks whether TCP-level keepalive (SO_KEEPALIVE) is currently enabled.">getKeepAlive()</a> </dd>
<dd>
<a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/tcp.7.html">https://man7.org/linux/man-pages/man7/tcp.7.html</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method does not configure the keepalive <b>timing parameters</b> (interval, probes, timeout). Use platform-specific APIs for advanced tuning. </dd></dl>

</div>
</div>
<a id="ga0303c931f324a501e2502df58b8a9232" name="ga0303c931f324a501e2502df58b8a9232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0303c931f324a501e2502df58b8a9232">&#9670;&#160;</a></span>setMulticastInterfaceIPv4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setMulticastInterfaceIPv4 </td>
          <td>(</td>
          <td class="paramtype">in_addr</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the outgoing IPv4 interface for multicast. </p>
<p>Sets the per-socket <b>default egress interface</b> used for <b>IPv4 multicast</b> transmissions. For IPv4, the egress is specified by the interface’s <b>unicast IPv4 address</b>. Passing <span class="tt">INADDR_ANY</span> (in network byte order) restores the system default route.</p>
<p>This call affects only <b>outbound multicast</b> selection for the IPv4 family; it does not join or leave any multicast group, and it does not affect IPv6.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>IPv4 address (network byte order) of the desired egress interface. Use <span class="tt">in_addr{ .s_addr = htonl(INADDR_ANY) }</span> to reset to the system default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The underlying descriptor is a valid UDP-capable socket opened for <span class="tt">AF_INET</span> or capable of IPv4 multicast sends (e.g., dual-stack if supported).</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The socket’s default IPv4 multicast egress interface is updated. Subsequent IPv4 multicast sends on this socket will use the selected interface until changed again or reset to default.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Platform mapping</dt><dd><ul>
<li><span class="tt">setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, ...)</span><ul>
<li><b>POSIX:</b> value is a <span class="tt">struct in_addr</span> (network byte order).</li>
<li><b>Windows:</b> value is a <span class="tt">DWORD</span> containing the IPv4 address in network byte order.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error conditions</dt><dd><ul>
<li>The socket is invalid or closed.</li>
<li>The specified address is malformed or otherwise rejected by the OS.</li>
<li>The underlying <span class="tt">setsockopt(IP_MULTICAST_IF)</span> fails (e.g., <span class="tt">ENOTSOCK</span>, <span class="tt">EINVAL</span>, <span class="tt">ENOPROTOOPT</span>; Windows: <span class="tt">WSAENOTSOCK</span>, <span class="tt">WSAEINVAL</span>, <span class="tt">WSAENOPROTOOPT</span>).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the option cannot be applied. The exception carries the OS error code and a descriptive message produced by <span class="tt">SocketErrorMessage(...)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function <b>does not</b> verify that <code class="param">addr</code> is currently assigned to a local interface. Some stacks may accept the option but later fail to send if routing is not feasible. Prefer to pass an address you know is bound to a local interface.</li>
<li>This setting is <b>per-socket</b> and only influences <b>multicast</b> egress selection. It does not affect unicast routing nor which local interfaces receive multicast (reception depends on group membership on each socket).</li>
<li>For IPv6 multicast egress, use <a class="el" href="#gad8e171cfa4daf58cde0f27d26794e35c">setMulticastInterfaceIPv6(unsigned int)</a>.</li>
<li>Higher-level convenience: if you need to accept human-friendly identifiers (empty string, IPv4 literal, IPv6 index/name on POSIX), consider using setMulticastInterface(const std::string&amp;).</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> / <a class="el" href="#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL()</a> — control/query multicast scope.</li>
<li><a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> / <a class="el" href="#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> — control/query local delivery of this socket’s own multicast.</li>
<li><a class="el" href="#gad8e171cfa4daf58cde0f27d26794e35c">setMulticastInterfaceIPv6(unsigned int)</a> — select the IPv6 multicast egress.</li>
<li>joinGroup(const std::string&amp;, const std::string&amp;) / leaveGroup(const std::string&amp;, const std::string&amp;) — manage group membership.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: choose IPv4 egress by literal</span></div>
<div class="line">in_addr eg{};</div>
<div class="line"><span class="keywordflow">if</span> (inet_pton(AF_INET, <span class="stringliteral">&quot;192.0.2.10&quot;</span>, &amp;eg) != 1) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;invalid IPv4 address&quot;</span>);</div>
<div class="line">}</div>
<div class="line">sock.setMulticastInterfaceIPv4(eg);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example: reset to default IPv4 multicast egress</span></div>
<div class="line">in_addr any{}; any.s_addr = htonl(INADDR_ANY);</div>
<div class="line">sock.setMulticastInterfaceIPv4(any);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gad8e171cfa4daf58cde0f27d26794e35c" name="gad8e171cfa4daf58cde0f27d26794e35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8e171cfa4daf58cde0f27d26794e35c">&#9670;&#160;</a></span>setMulticastInterfaceIPv6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setMulticastInterfaceIPv6 </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>ifindex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the outgoing IPv6 interface for multicast. </p>
<p>Sets the per-socket <b>default egress interface</b> used for <b>IPv6 multicast</b> transmissions by specifying a <b>numeric interface index</b>. Passing <span class="tt">0</span> resets to the system default route.</p>
<p>This call affects only <b>outbound IPv6 multicast</b> selection; it does not join or leave any multicast group and does not affect IPv4 egress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifindex</td><td>IPv6 interface index for multicast egress. Use <span class="tt">0</span> to restore the system default. On POSIX systems you can obtain this via <span class="tt">if_nametoindex()</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The underlying descriptor is a valid UDP-capable socket (typically <span class="tt">AF_INET6</span> or dual-stack if enabled).</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The socket’s default IPv6 multicast egress interface is updated. Subsequent IPv6 multicast sends from this socket will use the selected interface until changed again or reset to default.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Platform mapping</dt><dd><ul>
<li><span class="tt">setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF, &amp;ifindex, sizeof(ifindex))</span><ul>
<li><b>Windows:</b> <span class="tt">ifindex</span> is passed as a <span class="tt">DWORD</span>.</li>
<li><b>POSIX:</b> <span class="tt">ifindex</span> is an <span class="tt">unsigned int</span> (commonly the value returned by <span class="tt">if_nametoindex()</span>).</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error conditions</dt><dd><ul>
<li>The socket is invalid or closed.</li>
<li>The specified interface index is not valid on this host.</li>
<li>The underlying <span class="tt">setsockopt(IPV6_MULTICAST_IF)</span> call fails (e.g., <span class="tt">ENOTSOCK</span>, <span class="tt">EINVAL</span>, <span class="tt">ENOPROTOOPT</span>; Windows: <span class="tt">WSAENOTSOCK</span>, <span class="tt">WSAEINVAL</span>, <span class="tt">WSAENOPROTOOPT</span>).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the option cannot be applied. The exception carries the OS error code and a descriptive message produced by <span class="tt">SocketErrorMessage(...)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This setting is <b>per-socket</b> and influences only <b>multicast</b> egress selection for IPv6. It does not affect unicast routing nor which local interfaces receive multicast—reception depends on group membership on each socket.</li>
<li>On Windows, interface <b>names</b> are not accepted for <span class="tt">IPV6_MULTICAST_IF</span>; provide a <b>numeric</b> index. On POSIX, you may convert an interface name via <span class="tt">if_nametoindex()</span>.</li>
<li>If the socket was created with <span class="tt">IPV6_V6ONLY</span> enabled, this setting applies only to the IPv6 path; it does not influence IPv4 multicast egress.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="#ga0303c931f324a501e2502df58b8a9232">setMulticastInterfaceIPv4(in_addr)</a> — select the IPv4 multicast egress.</li>
<li>setMulticastInterface(const std::string&amp;) — convenience wrapper that accepts human-friendly identifiers.</li>
<li><a class="el" href="#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> / <a class="el" href="#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL()</a> — control/query multicast scope.</li>
<li><a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> / <a class="el" href="#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> — control/query local delivery of this socket’s own multicast.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// POSIX: choose IPv6 egress by interface name</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = if_nametoindex(<span class="stringliteral">&quot;eth0&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (idx == 0) { <span class="keywordflow">throw</span> <a class="code hl_class" href="classjsocketpp_1_1SocketException.html">SocketException</a>(<span class="stringliteral">&quot;Unknown interface: eth0&quot;</span>); }</div>
<div class="line">sock.setMulticastInterfaceIPv6(idx);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Windows (or any platform): choose egress by numeric index</span></div>
<div class="line">sock.setMulticastInterfaceIPv6(12);  <span class="comment">// where 12 is the adapter&#39;s IPv6 index</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reset to default IPv6 multicast egress</span></div>
<div class="line">sock.setMulticastInterfaceIPv6(0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga145c0c5a7e075ac0bdda7f30e860c717" name="ga145c0c5a7e075ac0bdda7f30e860c717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga145c0c5a7e075ac0bdda7f30e860c717">&#9670;&#160;</a></span>setMulticastLoopback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setMulticastLoopback </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable multicast loopback for this socket. </p>
<p>Controls whether <b>multicast datagrams transmitted by this socket</b> are delivered back to the local host (“looped back”). This affects only <b>local delivery</b>; it does not influence what remote receivers get.</p>
<ul>
<li><b>IPv4:</b> maps to <span class="tt">IP_MULTICAST_LOOP</span>.</li>
<li><b>IPv6:</b> maps to <span class="tt">IPV6_MULTICAST_LOOP</span>.</li>
</ul>
<p>Semantics (effective for packets <em>sent by this socket</em>):</p><ul>
<li><span class="tt">enable == true</span> (loopback on): the kernel may deliver a local copy of each outbound multicast to sockets on the same host that have joined the group (including this socket, if it has joined).</li>
<li><span class="tt">enable == false</span> (loopback off): the kernel suppresses local delivery of those packets on this host—no local socket will receive the copies of <em>this socket’s</em> outbound multicast frames.</li>
</ul>
<p>This setting is <b>per-socket</b> and applies to subsequent sends until changed. It does <b>not</b> affect unicast traffic, and it does <b>not</b> force other sockets to receive or drop multicast that originates elsewhere.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><span class="tt">true</span> to enable local loopback of this socket’s multicast transmissions; <span class="tt">false</span> to suppress local loopback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The underlying descriptor is a valid datagram (UDP) socket created for <span class="tt">AF_INET</span> or <span class="tt">AF_INET6</span>.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The socket’s multicast loopback policy is updated. Future multicast sends from this socket follow the new policy; in-flight packets are unaffected.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Platform mapping</dt><dd><ul>
<li><b>IPv4:</b> <span class="tt">setsockopt(fd, IPPROTO_IP,  IP_MULTICAST_LOOP,  &amp;flag, sizeof(flag))</span></li>
<li><b>IPv6:</b> <span class="tt">setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &amp;flag, sizeof(flag))</span></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error conditions</dt><dd><ul>
<li>The socket is invalid or closed.</li>
<li>The socket family cannot be determined or is unsupported on this platform.</li>
<li>The underlying <span class="tt">setsockopt</span> fails (e.g., <span class="tt">ENOTSOCK</span>, <span class="tt">ENOPROTOOPT</span>, <span class="tt">EINVAL</span>, or Windows equivalents <span class="tt">WSAENOTSOCK</span>, <span class="tt">WSAENOPROTOOPT</span>, <span class="tt">WSAEINVAL</span>).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If the option cannot be set for any of the reasons above. The exception includes the OS error code and a descriptive message from <span class="tt">SocketErrorMessage(...)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Typical default is <b>enabled</b> (1) on most stacks, but it is implementation-defined; call <a class="el" href="#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> to confirm.</li>
<li>Disabling loopback is useful when a sender also listens on the same group and you want to avoid processing your own announcements.</li>
<li>This control concerns <b>local delivery</b> only; it has no impact on what remote hosts receive.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="#ga67d056eeb49ad2f3fb831e9653c23b6e">getMulticastLoopback()</a> — query the current loopback flag.</li>
<li><a class="el" href="#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL(int)</a> / <a class="el" href="#ga55f73b7c90f7f6b507c69eead5cfc10f">getMulticastTTL()</a> — control and query the default multicast scope (TTL/hop-limit).</li>
<li><a class="el" href="#ga0303c931f324a501e2502df58b8a9232">setMulticastInterfaceIPv4(in_addr)</a> / setMulticastInterfaceIPv6(unsigned) — choose the outgoing interface for multicast.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: avoid receiving our own announcements</span></div>
<div class="line"><a class="code hl_class" href="classjsocketpp_1_1MulticastSocket.html">MulticastSocket</a> sock;</div>
<div class="line">sock.<a class="code hl_function" href="group__udp.html#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;eth0&quot;</span>);</div>
<div class="line">sock.<a class="code hl_function" href="group__udp.html#ga7937b05ccae7d059b4fcfa4b6383c75c">joinGroup</a>(<span class="stringliteral">&quot;239.1.2.3&quot;</span>);</div>
<div class="line"> </div>
<div class="line">sock.<a class="code hl_function" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback</a>(<span class="keyword">false</span>);   <span class="comment">// suppress local copies of our sends</span></div>
<div class="line">sock.sendTo(<span class="stringliteral">&quot;239.1.2.3&quot;</span>, 5000, payload);</div>
<div class="ttc" id="aclassjsocketpp_1_1MulticastSocket_html"><div class="ttname"><a href="classjsocketpp_1_1MulticastSocket.html">jsocketpp::MulticastSocket</a></div><div class="ttdoc">Cross-platform multicast UDP socket class (IPv4/IPv6).</div><div class="ttdef"><b>Definition</b> MulticastSocket.hpp:75</div></div>
<div class="ttc" id="agroup__socketopts_html_ga145c0c5a7e075ac0bdda7f30e860c717"><div class="ttname"><a href="#ga145c0c5a7e075ac0bdda7f30e860c717">jsocketpp::SocketOptions::setMulticastLoopback</a></div><div class="ttdeci">void setMulticastLoopback(bool enable)</div><div class="ttdoc">Enable or disable multicast loopback for this socket.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:425</div></div>
<div class="ttc" id="agroup__udp_html_ga7937b05ccae7d059b4fcfa4b6383c75c"><div class="ttname"><a href="group__udp.html#ga7937b05ccae7d059b4fcfa4b6383c75c">jsocketpp::MulticastSocket::joinGroup</a></div><div class="ttdeci">void joinGroup(const std::string &amp;groupAddr, const std::string &amp;iface)</div><div class="ttdoc">Join a multicast group on an optional interface (string-friendly).</div><div class="ttdef"><b>Definition</b> MulticastSocket.cpp:173</div></div>
<div class="ttc" id="agroup__udp_html_gaf0d5d684dcbfcf62907482ae3ac98948"><div class="ttname"><a href="group__udp.html#gaf0d5d684dcbfcf62907482ae3ac98948">jsocketpp::MulticastSocket::setMulticastInterface</a></div><div class="ttdeci">void setMulticastInterface(const std::string &amp;iface)</div><div class="ttdoc">Select the default outgoing interface for multicast transmissions.</div><div class="ttdef"><b>Definition</b> MulticastSocket.cpp:20</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga147307de53a210acda7c64dc1540c40e" name="ga147307de53a210acda7c64dc1540c40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga147307de53a210acda7c64dc1540c40e">&#9670;&#160;</a></span>setMulticastTTL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setMulticastTTL </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ttl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default multicast hop limit / TTL for this socket. </p>
<p>Sets the per-socket <em>default</em> scope for <b>multicast</b> transmissions:</p><ul>
<li>For IPv4 sockets, maps to <span class="tt">IP_MULTICAST_TTL</span> (time-to-live).</li>
<li>For IPv6 sockets, maps to <span class="tt">IPV6_MULTICAST_HOPS</span> (hop limit).</li>
</ul>
<p>The value controls how far outbound <b>multicast</b> packets may travel:</p><ul>
<li><span class="tt">0</span> confines delivery to the local host (no transmission beyond the sender).</li>
<li><span class="tt">1</span> confines delivery to the local link / subnet.</li>
<li>Higher values permit traversal across additional multicast routers up to the limit.</li>
</ul>
<p>This setting applies to subsequent multicast sends on this socket until changed again. It does <b>not</b> affect unicast traffic—use <span class="tt">IP_TTL</span> / <span class="tt">IPV6_UNICAST_HOPS</span> for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl</td><td>Hop limit (IPv6) or TTL (IPv4), in the range <span class="tt">[0, 255]</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The underlying socket must be a valid IPv4 (<span class="tt">AF_INET</span>) or IPv6 (<span class="tt">AF_INET6</span>) socket.</li>
<li>The socket is intended for multicast transmission (typically a datagram/UDP socket).</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The socket’s default multicast TTL / hop limit is updated; subsequent multicast transmissions use this value unless a per-message override is supplied via ancillary data (e.g., <span class="tt">IP_MULTICAST_TTL</span> / <span class="tt">IPV6_HOPLIMIT</span> control messages).</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Platform mapping</dt><dd><ul>
<li><b>IPv4:</b> <span class="tt">setsockopt(fd, IPPROTO_IP,  IP_MULTICAST_TTL,  ...)</span></li>
<li><b>IPv6:</b> <span class="tt">setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, ...)</span></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error conditions</dt><dd><ul>
<li><span class="tt">ttl</span> is outside <span class="tt">[0, 255]</span>.</li>
<li>The socket is invalid or closed.</li>
<li>The socket family is unsupported for multicast TTL/hops on the current platform.</li>
<li>The underlying <span class="tt">setsockopt</span> call fails (e.g., <span class="tt">ENOTSOCK</span>, <span class="tt">EINVAL</span>, <span class="tt">ENOPROTOOPT</span>, or their Windows equivalents such as <span class="tt">WSAENOTSOCK</span>, <span class="tt">WSAEINVAL</span>, <span class="tt">WSAENOPROTOOPT</span>).</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>If <code class="param">ttl</code> is out of range, the socket state is invalid, or the operating system rejects the option. The exception contains the OS error code and a descriptive message produced by <span class="tt">SocketErrorMessage(...)</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This is a <b>per-socket default</b>. If your application uses <span class="tt">sendmsg</span> with ancillary data to specify a hop limit/TTL per packet, those per-message values take precedence.</li>
<li>Changing this value concurrently with active sends may produce a mix of old and new limits across packets that are in-flight during the update; set it during initialization for deterministic behavior.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related options</dt><dd><ul>
<li><a class="el" href="#ga145c0c5a7e075ac0bdda7f30e860c717">setMulticastLoopback(bool)</a> — controls whether the socket receives its own multicast transmissions.</li>
<li><a class="el" href="#ga0303c931f324a501e2502df58b8a9232">setMulticastInterfaceIPv4(in_addr)</a> / setMulticastInterfaceIPv6(unsigned) — choose the outgoing interface for multicast.</li>
<li>Unicast scope: <span class="tt">IP_TTL</span> / <span class="tt">IPV6_UNICAST_HOPS</span> (not affected by this function).</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example: restrict multicast to the local link and send</span></div>
<div class="line"><a class="code hl_class" href="classjsocketpp_1_1MulticastSocket.html">MulticastSocket</a> sock;               <span class="comment">// or your UDP-capable socket wrapper</span></div>
<div class="line">sock.<a class="code hl_function" href="group__udp.html#gaf0d5d684dcbfcf62907482ae3ac98948">setMulticastInterface</a>(<span class="stringliteral">&quot;eth0&quot;</span>); <span class="comment">// choose an egress interface</span></div>
<div class="line">sock.<a class="code hl_function" href="#ga147307de53a210acda7c64dc1540c40e">setMulticastTTL</a>(1);            <span class="comment">// 1 = link-local only</span></div>
<div class="line">sock.<a class="code hl_function" href="group__udp.html#ga7937b05ccae7d059b4fcfa4b6383c75c">joinGroup</a>(<span class="stringliteral">&quot;239.1.2.3&quot;</span>);        <span class="comment">// join if you also receive on this socket</span></div>
<div class="line">sock.sendTo(<span class="stringliteral">&quot;239.1.2.3&quot;</span>, 5000, dataSpan);</div>
<div class="ttc" id="agroup__socketopts_html_ga147307de53a210acda7c64dc1540c40e"><div class="ttname"><a href="#ga147307de53a210acda7c64dc1540c40e">jsocketpp::SocketOptions::setMulticastTTL</a></div><div class="ttdeci">void setMulticastTTL(int ttl)</div><div class="ttdoc">Set the default multicast hop limit / TTL for this socket.</div><div class="ttdef"><b>Definition</b> SocketOptions.cpp:394</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga5f2dffc2949b06b1d945e590bce7f05b" name="ga5f2dffc2949b06b1d945e590bce7f05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f2dffc2949b06b1d945e590bce7f05b">&#9670;&#160;</a></span>setNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setNonBlocking </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nonBlocking</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables non-blocking mode on the socket. </p>
<p>This method configures the I/O blocking behavior of the socket. In <b>non-blocking mode</b>, system calls such as <span class="tt">read()</span>, <span class="tt">write()</span>, <span class="tt">connect()</span>, and <span class="tt">accept()</span> return immediately if they cannot proceed, rather than blocking the calling thread. This enables asynchronous or event-driven designs where the application explicitly manages readiness.</p>
<p>In <b>blocking mode</b> (the default), these calls block the thread until they complete, time out (if configured), or fail.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1105"></a>
🔀 Platform Behavior</h3>
<ul>
<li><b>POSIX</b>: Uses <span class="tt">fcntl()</span> to set or clear the <span class="tt">O_NONBLOCK</span> flag.</li>
<li><b>Windows</b>: Uses <span class="tt"><a class="el" href="namespacejsocketpp.html#a771a44f3967222b2e3221ed3120220af">ioctlsocket()</a></span> with the <span class="tt">FIONBIO</span> control code.</li>
<li><b>Effect</b>: Changes apply immediately and persist for the life of the socket.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1107"></a>
📦 Applicable Socket Types</h3>
<p>This operation is available on all socket types in this library:</p><ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (TCP client)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> (listening/acceptor)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> (UDP)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span> (UNIX domain stream/datagram)</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1109"></a>
⏱️ Behavior Summary by Operation</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation  </th><th class="markdownTableHeadNone">In Blocking Mode  </th><th class="markdownTableHeadNone">In Non-Blocking Mode  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">connect()</span>  </td><td class="markdownTableBodyNone">Blocks until connected or timeout  </td><td class="markdownTableBodyNone">Returns immediately; may require polling <span class="tt">write</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">read()</span>  </td><td class="markdownTableBodyNone">Waits for data or EOF  </td><td class="markdownTableBodyNone">Returns <span class="tt">-1</span> with <span class="tt">EWOULDBLOCK</span> if no data  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">write()</span>  </td><td class="markdownTableBodyNone">Waits for buffer availability  </td><td class="markdownTableBodyNone">Returns <span class="tt">-1</span> if buffer full  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">accept()</span>  </td><td class="markdownTableBodyNone">Waits for pending connection  </td><td class="markdownTableBodyNone">Returns <span class="tt">-1</span> with <span class="tt">EWOULDBLOCK</span> if none available  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">recvfrom()</span>  </td><td class="markdownTableBodyNone">Waits for incoming datagram  </td><td class="markdownTableBodyNone">Returns <span class="tt">-1</span> if no datagram received  </td></tr>
</table>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1111"></a>
✅ Use Cases</h3>
<ul>
<li>Event-driven I/O (with <span class="tt">select</span>, <span class="tt">poll</span>, <span class="tt">epoll</span>, or <span class="tt">kqueue</span>)</li>
<li>GUI or game loops that must avoid blocking the main thread</li>
<li>High-performance servers handling thousands of concurrent clients</li>
<li>Real-time systems with custom scheduling and retry logic</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1113"></a>
Example: Enable non-blocking mode on a client socket</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1Socket.html">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line">sock.setNonBlocking(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!sock.waitReady(<span class="keyword">true</span>, 3000)) {</div>
<div class="line">    <span class="keywordflow">throw</span> TimeoutException(<span class="stringliteral">&quot;Connection timed out&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassjsocketpp_1_1Socket_html"><div class="ttname"><a href="classjsocketpp_1_1Socket.html">jsocketpp::Socket</a></div><div class="ttdoc">TCP client connection abstraction (Java-like interface).</div><div class="ttdef"><b>Definition</b> Socket.hpp:93</div></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nonBlocking</td><td><span class="tt">true</span> to enable non-blocking mode, <span class="tt">false</span> to restore blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid (<span class="tt">EBADF</span>)</li>
<li>Platform-specific system calls fail</li>
<li>Permissions or capabilities are insufficient</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This setting only affects the current socket instance. It does <b>not</b> affect sockets returned by <span class="tt">accept()</span> (you must call <span class="tt"><a class="el" href="#ga5f2dffc2949b06b1d945e590bce7f05b" title="Enables or disables non-blocking mode on the socket.">setNonBlocking()</a></span> on each accepted socket).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga56fa4549b175d2913b64a43f1ecd2409" title="Queries whether the socket is currently in non-blocking mode.">getNonBlocking()</a> </dd>
<dd>
waitReady() To wait for readiness in non-blocking mode </dd>
<dd>
<a class="el" href="#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a> For timeout control in blocking mode </dd></dl>

</div>
</div>
<a id="ga04df6377e302cc0cedff070517021950" name="ga04df6377e302cc0cedff070517021950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04df6377e302cc0cedff070517021950">&#9670;&#160;</a></span>setOption() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setOption </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>optName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a low-level socket option using a structured or binary value. </p>
<p>This overload of <span class="tt"><a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a></span> configures advanced socket options that require passing complex values via a memory buffer, such as <span class="tt">struct linger</span>, protocol-specific flags, or platform-defined structures.</p>
<p><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> options allow advanced users to customize performance, transport behavior, and resource usage. This method is applicable to all supported socket types:</p>
<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (TCP stream sockets)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> (listening TCP sockets)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> (UDP)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span> (UNIX domain stream or datagram)</li>
</ul>
<p>It supports options at various protocol levels, including:</p><ul>
<li><span class="tt">SOL_SOCKET</span> for generic socket behavior</li>
<li><span class="tt">IPPROTO_TCP</span> for TCP-specific options</li>
<li><span class="tt">IPPROTO_UDP</span>, <span class="tt">IPPROTO_IP</span>, etc.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1023"></a>
🧩 Use Cases</h3>
<ul>
<li>Configure linger behavior with <span class="tt">SO_LINGER</span> using <span class="tt">struct linger</span></li>
<li>Apply platform-specific options that require binary data</li>
<li>Set multicast interface (<span class="tt">IP_MULTICAST_IF</span>) or IPv6 options</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1025"></a>
Example: Set <span class="tt">SO_LINGER</span> to linger for 5 seconds on close</h3>
<div class="fragment"><div class="line">linger lin;</div>
<div class="line">lin.l_onoff = 1;</div>
<div class="line">lin.l_linger = 5;</div>
<div class="line">socket.setOption(SOL_SOCKET, SO_LINGER, &amp;lin, <span class="keyword">sizeof</span>(linger));</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1027"></a>
⚠️ ServerSocket-specific Notes</h3>
<ul>
<li>Only affects the passive/listening socket itself.</li>
<li>Accepted sockets must be configured separately.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1028"></a>
📡 DatagramSocket-specific Notes</h3>
<ul>
<li>Can be used for multicast, broadcast, timeouts, etc.</li>
<li>Accepts raw buffers for protocol-level socket options.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1029"></a>
🧿 UnixSocket-specific Notes</h3>
<ul>
<li>Common options include <span class="tt">SO_PASSCRED</span>, <span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDTIMEO</span></li>
<li>TCP-specific options (e.g., <span class="tt">TCP_NODELAY</span>) are not supported.</li>
</ul>
<hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Protocol level (e.g., <span class="tt">SOL_SOCKET</span>, <span class="tt">IPPROTO_TCP</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optName</td><td>Option name (e.g., <span class="tt">SO_LINGER</span>, <span class="tt">IP_TOS</span>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Pointer to a buffer containing the option value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of the buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li><span class="tt">setsockopt()</span> fails due to invalid parameters or unsupported option</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is intended for structured or binary values. For simple integer options, use <span class="tt"><a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption(int, int, int)</a></span> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption(int, int, int)</a> </dd>
<dd>
getOption(int, int, void*, socklen_t*) </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man2/setsockopt.2.html">https://man7.org/linux/man-pages/man2/setsockopt.2.html</a> </dd></dl>

</div>
</div>
<a id="ga1b7061a0f4d13e8d33d3065b8ad4998b" name="ga1b7061a0f4d13e8d33d3065b8ad4998b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b7061a0f4d13e8d33d3065b8ad4998b">&#9670;&#160;</a></span>setOption() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setOption </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>optName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a low-level socket option on the underlying socket. </p>
<p>This method configures a socket option using the system-level <span class="tt">setsockopt()</span> interface. <a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a> options allow advanced users to fine-tune behavior related to performance, protocol semantics, reliability, and resource usage.</p>
<p>This API is available on all socket types provided by the library, including:</p><ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (TCP stream sockets)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span> (listening sockets)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> (UDP)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span> (UNIX domain stream or datagram sockets)</li>
</ul>
<p>It supports options at multiple protocol levels, such as <span class="tt">SOL_SOCKET</span>, <span class="tt">IPPROTO_TCP</span>, and <span class="tt">IPPROTO_UDP</span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1014"></a>
🔧 Common Use Cases</h3>
<ul>
<li>Enable address reuse (<span class="tt">SO_REUSEADDR</span>) for TCP/UDP servers</li>
<li>Enable TCP keepalive (<span class="tt">SO_KEEPALIVE</span>) for long-lived connections</li>
<li>Tune send/receive buffer sizes (<span class="tt">SO_SNDBUF</span>, <span class="tt">SO_RCVBUF</span>)</li>
<li>Disable Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>) for latency-sensitive TCP clients</li>
<li>Enable broadcast mode (<span class="tt">SO_BROADCAST</span>) on UDP sockets</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1016"></a>
⚠️ ServerSocket-specific Notes</h3>
<ul>
<li>Setting options on a <b>listening socket</b> only affects the acceptor socket.</li>
<li>Options do <b>not</b> propagate to client sockets returned by <span class="tt">accept()</span>.</li>
<li>Common use: <span class="tt">SO_REUSEADDR</span> before <span class="tt">bind()</span>.</li>
</ul>
<div class="fragment"><div class="line">serverSocket.setOption(SOL_SOCKET, SO_REUSEADDR, 1);</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1018"></a>
📡 DatagramSocket-specific Notes</h3>
<ul>
<li>Useful for enabling <span class="tt">SO_BROADCAST</span>, tuning buffer sizes, or applying timeouts (<span class="tt">SO_RCVTIMEO</span>, <span class="tt">SO_SNDTIMEO</span>)</li>
<li>For connected UDP sockets, options affect the single remote peer.</li>
<li>For unconnected sockets, they apply to all traffic.</li>
</ul>
<div class="fragment"><div class="line">datagramSocket.setOption(SOL_SOCKET, SO_BROADCAST, 1);</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1020"></a>
🧿 UnixSocket-specific Notes</h3>
<ul>
<li>Although not TCP/IP-based, many <span class="tt">SOL_SOCKET</span> options apply:<ul>
<li><span class="tt">SO_RCVBUF</span>, <span class="tt">SO_SNDBUF</span> (buffer tuning)</li>
<li><span class="tt">SO_PASSCRED</span> (credential passing)</li>
<li><span class="tt">SO_RCVTIMEO</span>, <span class="tt">SO_SNDTIMEO</span> (timeouts)</li>
</ul>
</li>
<li>TCP-level options like <span class="tt">TCP_NODELAY</span> are <b>not supported</b>.</li>
</ul>
<div class="fragment"><div class="line">unixSocket.setOption(SOL_SOCKET, SO_SNDBUF, 65536);</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The protocol level at which the option resides (e.g., <span class="tt">SOL_SOCKET</span>, <span class="tt">IPPROTO_TCP</span>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optName</td><td>The name of the socket option (e.g., <span class="tt">SO_REUSEADDR</span>, <span class="tt">TCP_NODELAY</span>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integer value to assign to the option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li><span class="tt">setsockopt()</span> fails due to unsupported option or platform error</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>getOption(int, int) For querying current option values </dd>
<dd>
<a class="el" href="#ga04df6377e302cc0cedff070517021950" title="Sets a low-level socket option using a structured or binary value.">setOption(int, int, const void*, socklen_t)</a> For structured or binary options </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man2/setsockopt.2.html">https://man7.org/linux/man-pages/man2/setsockopt.2.html</a> </dd></dl>

</div>
</div>
<a id="ga69fdecc0aaaef4bbd2826c448a8bbe1d" name="ga69fdecc0aaaef4bbd2826c448a8bbe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69fdecc0aaaef4bbd2826c448a8bbe1d">&#9670;&#160;</a></span>setReceiveBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setReceiveBufferSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the socket's receive buffer size (SO_RCVBUF). </p>
<p>Configures the size of the kernel-level receive buffer for the underlying socket. This buffer controls how much data the operating system can queue before the application reads from the socket. Increasing this value can reduce packet loss and improve throughput under high load or network delay.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1059"></a>
Applicability</h3>
<p>This method is valid for all supported socket types:</p><ul>
<li><b>TCP (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>)</b>: Recommended for high-latency or high-throughput connections.</li>
<li><b>UDP (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</b>: Critical for avoiding packet drops in high-volume flows.</li>
<li><b>UNIX domain sockets</b>: Supported on most platforms.</li>
<li><b><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></b>: Affects the passive socket itself, not accepted clients.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1060"></a>
Platform Behavior</h3>
<ul>
<li><b>Linux</b>: The kernel typically doubles the requested size to account for internal overhead.</li>
<li><b>Windows</b>: Value may be rounded to OS-specific granularity.</li>
<li><b>macOS/BSD</b>: Follows BSD semantics; may enforce stricter limits.</li>
<li>In all cases, system-wide limits apply (e.g., <span class="tt">/proc/sys/net/core/rmem_max</span> on Linux).</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1061"></a>
Example</h3>
<div class="fragment"><div class="line">datagramSocket.setReceiveBufferSize(256 * 1024); <span class="comment">// Set 256 KB buffer</span></div>
<div class="line"><span class="keywordtype">int</span> actual = datagramSocket.getReceiveBufferSize();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;OS applied buffer size: &quot;</span> &lt;&lt; actual &lt;&lt; <span class="stringliteral">&quot; bytes\n&quot;</span>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Desired receive buffer size in bytes. Actual value may be adjusted by the OS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid or uninitialized</li>
<li>The call to <span class="tt">setsockopt()</span> fails</li>
<li>The requested size exceeds system limits</li>
<li>Insufficient permissions to increase buffer limits</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always call this after socket creation and before heavy I/O. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2eaf2835ebba5587c238a0bd6c2be188" title="Retrieves the current receive buffer size (SO_RCVBUF) of the socket.">getReceiveBufferSize()</a> </dd>
<dd>
<a class="el" href="#ga8279b0c70f6a0fddf73d84aac691422b" title="Sets the socket&#39;s send buffer size (SO_SNDBUF).">setSendBufferSize()</a> </dd>
<dd>
setInternalBufferSize() </dd></dl>

</div>
</div>
<a id="gab358ea7ed49e95717b1e9438251b3d9a" name="gab358ea7ed49e95717b1e9438251b3d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab358ea7ed49e95717b1e9438251b3d9a">&#9670;&#160;</a></span>setReuseAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setReuseAddress </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the <span class="tt">SO_REUSEADDR</span> socket option. </p>
<p>This option controls whether the socket is permitted to bind to a local address and port that is already in use or in the <span class="tt">TIME_WAIT</span> state. It is commonly used in both server and client contexts, and is applicable to TCP, UDP, and Unix domain sockets.</p>
<p>Internally, this method invokes: </p><div class="fragment"><div class="line">setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, ...)</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md1053"></a>
Platform Behavior</h3>
<ul>
<li><b>POSIX (Linux, BSD, macOS):</b><ul>
<li>Permits multiple sockets to bind the same address/port as long as all use <span class="tt">SO_REUSEADDR</span>.</li>
<li>Commonly used with multicast UDP, and for servers that need to restart quickly.</li>
</ul>
</li>
<li><b>Windows:</b><ul>
<li>Allows rebinding to a port in <span class="tt">TIME_WAIT</span>, but does <b>not</b> allow simultaneous binds.</li>
<li>Microsoft recommends <span class="tt">SO_EXCLUSIVEADDRUSE</span> for exclusive ownership, but <span class="tt">SO_REUSEADDR</span> works for most cases.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1054"></a>
Protocol Use Cases</h3>
<ul>
<li><b>TCP Server Sockets</b>: Enables re-binding to a port immediately after shutdown.</li>
<li><b>TCP Client Sockets</b>: Useful when binding to a fixed local port to reconnect rapidly.</li>
<li><b>UDP Sockets</b>:<ul>
<li>Allows multiple sockets to bind to the same port, often required for multicast listeners.</li>
<li>Useful in P2P setups where port reuse is desired across short-lived sessions.</li>
</ul>
</li>
<li><b>Unix Domain Sockets</b>:<ul>
<li>On some platforms, <span class="tt">SO_REUSEADDR</span> may be ignored or unnecessary for <span class="tt">AF_UNIX</span>, since file system semantics already handle path reusability. However, setting it is harmless and may be supported by your platform for consistency.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1055"></a>
Example</h3>
<div class="fragment"><div class="line">socket.setReuseAddress(<span class="keyword">true</span>); <span class="comment">// Enable port/path reuse before calling bind()</span></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>This method must be called <b>after socket creation</b> and <b>before bind()</b>. Improper use can lead to security issues or interference between applications.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">on</td><td>If <span class="tt">true</span>, enables address reuse; if <span class="tt">false</span>, disables it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if the socket is invalid or the option cannot be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8e8783ada3142cd6c3b275e01b7b12f2" title="Queries whether the socket is currently configured to allow address reuse.">getReuseAddress()</a> </dd>
<dd>
bind() </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/socket.7.html">https://man7.org/linux/man-pages/man7/socket.7.html</a> </dd></dl>

</div>
</div>
<a id="ga05c3ae5067a7d83965249d00c5d564c3" name="ga05c3ae5067a7d83965249d00c5d564c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05c3ae5067a7d83965249d00c5d564c3">&#9670;&#160;</a></span>setReusePort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setReusePort </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the <span class="tt">SO_REUSEPORT</span> socket option. </p>
<p>This method configures the <span class="tt">SO_REUSEPORT</span> option, which allows multiple sockets to bind to the <b>same IP address and port combination</b>, enabling parallelism in multi-threaded or multi-process applications. Unlike <span class="tt">SO_REUSEADDR</span>, which allows re-binding during <span class="tt">TIME_WAIT</span>, <span class="tt">SO_REUSEPORT</span> permits <b>simultaneous binding</b> by multiple sockets.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1167"></a>
🌍 Applicability</h3>
<ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>: ✅ Enables load-balanced accept loops across threads or processes</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>: ✅ Permits shared reception on a multicast port (platform-dependent)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>: ✅ Technically allowed, but rarely used in clients</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>: ❌ Not supported; this method is not compiled on unsupported platforms</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1169"></a>
🔀 Platform Support</h3>
<ul>
<li>✅ Linux (kernel ≥ 3.9)</li>
<li>✅ BSD-based systems (FreeBSD, macOS)</li>
<li>❌ Windows: Not available — this method is excluded at compile time</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1171"></a>
Example: Enable shared port binding</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#if defined(SO_REUSEPORT)</span></div>
<div class="line">    serverSocket.setReusePort(<span class="keyword">true</span>);</div>
<div class="line">    serverSocket.bind(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 8080);</div>
<div class="line">    serverSocket.listen();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><span class="tt">true</span> to allow multiple sockets to bind the same port (<span class="tt">SO_REUSEPORT = 1</span>), or <span class="tt">false</span> to disable the shared binding behavior (<span class="tt">SO_REUSEPORT = 0</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li>The system call fails (<span class="tt">setsockopt()</span> error)</li>
<li>The option is used improperly (e.g., after <span class="tt">bind()</span>)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This option must be set <b>before</b> calling <span class="tt">bind()</span>. Behavior is undefined if changed after binding.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0472e21ad70ac9b778aac3d6177577ca" title="Checks whether the SO_REUSEPORT option is currently enabled on the socket.">getReusePort()</a> </dd>
<dd>
<a class="el" href="#gab358ea7ed49e95717b1e9438251b3d9a" title="Enables or disables the SO_REUSEADDR socket option.">setReuseAddress()</a> </dd>
<dd>
<a href="https://lwn.net/Articles/542629/">https://lwn.net/Articles/542629/</a> </dd></dl>

</div>
</div>
<a id="ga8279b0c70f6a0fddf73d84aac691422b" name="ga8279b0c70f6a0fddf73d84aac691422b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8279b0c70f6a0fddf73d84aac691422b">&#9670;&#160;</a></span>setSendBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setSendBufferSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the socket's send buffer size (SO_SNDBUF). </p>
<p>Configures the size of the kernel-level send buffer for this socket. This buffer controls how much data the operating system can queue for transmission before blocking the sender or returning a partial write. Larger buffers help improve throughput, especially in high-bandwidth or high-latency network environments.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1065"></a>
Applicability</h3>
<p>This method is valid for all socket types:</p><ul>
<li><b>TCP (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>)</b>: Helps reduce application-level blocking and improves write throughput.</li>
<li><b>UDP (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</b>: Allows higher burst rate; excess data is dropped if full.</li>
<li><b>UNIX domain sockets</b>: Supported for local IPC buffering on most systems.</li>
<li><b><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></b>: Setting this has no meaningful effect on passive sockets.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1066"></a>
Platform Behavior</h3>
<ul>
<li><b>Linux</b>: Kernel may double the size for internal overhead; limited by <span class="tt">/proc/sys/net/core/wmem_max</span>.</li>
<li><b>Windows</b>: Rounded to system-specific page sizes or segment alignment.</li>
<li><b>BSD/macOS</b>: Honors the request up to system-imposed limits.</li>
<li>All platforms may silently apply a different size than requested — verify with <span class="tt"><a class="el" href="#gaeb5f9d1ae3f1b7b9fdb94335b10723f6" title="Retrieves the current send buffer size (SO_SNDBUF) of the socket.">getSendBufferSize()</a></span>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1067"></a>
Example</h3>
<div class="fragment"><div class="line">socket.setSendBufferSize(128 * 1024); <span class="comment">// 128 KB buffer</span></div>
<div class="line"><span class="keywordtype">int</span> actual = socket.getSendBufferSize();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Effective send buffer: &quot;</span> &lt;&lt; actual &lt;&lt; <span class="stringliteral">&quot; bytes\n&quot;</span>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Desired send buffer size in bytes. The actual buffer size may be adjusted by the system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid or uninitialized</li>
<li>The call to <span class="tt">setsockopt()</span> fails</li>
<li>The requested size exceeds system-imposed limits</li>
<li>Insufficient privileges are present</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applies to future sends only; does not affect buffered data already enqueued. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaeb5f9d1ae3f1b7b9fdb94335b10723f6" title="Retrieves the current send buffer size (SO_SNDBUF) of the socket.">getSendBufferSize()</a> </dd>
<dd>
<a class="el" href="#ga69fdecc0aaaef4bbd2826c448a8bbe1d" title="Sets the socket&#39;s receive buffer size (SO_RCVBUF).">setReceiveBufferSize()</a> </dd>
<dd>
setInternalBufferSize() </dd></dl>

</div>
</div>
<a id="ga97706ddf21aab33a18db00bd0b8eb65d" name="ga97706ddf21aab33a18db00bd0b8eb65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97706ddf21aab33a18db00bd0b8eb65d">&#9670;&#160;</a></span>setSocketFd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setSocketFd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a></td>          <td class="paramname"><span class="paramname"><em>sock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the socket descriptor used by this object. </p>
<p>This method sets the internal socket file descriptor used by the <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> interface. It is typically called by derived classes after the socket has been moved, reassigned, or otherwise changed during the object's lifetime.</p>
<p>This does <b>not</b> open, close, or validate the socket descriptor. It simply updates the internal <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a></span> used by methods such as <span class="tt"><a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a></span> and <span class="tt"><a class="el" href="#ga6a5264b995eb2a1143f45c5de6ad92c3" title="Retrieves the current value of a low-level socket option.">getOption()</a></span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1180"></a>
When to Use</h3>
<ul>
<li>After a move constructor or move assignment updates the underlying socket</li>
<li>After explicitly re-binding or re-creating a socket file descriptor</li>
<li>When adapting an externally provided descriptor (e.g., from <span class="tt">accept()</span> or <span class="tt">socketpair()</span>)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1181"></a>
Example: Move assignment</h3>
<div class="fragment"><div class="line"><a class="code hl_variable" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131">_sockFd</a> = rhs._sockFd;</div>
<div class="line"><a class="code hl_function" href="#ga97706ddf21aab33a18db00bd0b8eb65d">setSocketFd</a>(<a class="code hl_variable" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131">_sockFd</a>); <span class="comment">// keeps SocketOptions base class in sync</span></div>
<div class="ttc" id="aclassjsocketpp_1_1SocketOptions_html_a44b54c91017594a7695bf315778fb131"><div class="ttname"><a href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131">jsocketpp::SocketOptions::_sockFd</a></div><div class="ttdeci">SOCKET _sockFd</div><div class="ttdoc">Underlying socket file descriptor.</div><div class="ttdef"><b>Definition</b> SocketOptions.hpp:2488</div></div>
<div class="ttc" id="agroup__socketopts_html_ga97706ddf21aab33a18db00bd0b8eb65d"><div class="ttname"><a href="#ga97706ddf21aab33a18db00bd0b8eb65d">jsocketpp::SocketOptions::setSocketFd</a></div><div class="ttdeci">void setSocketFd(const SOCKET sock) noexcept</div><div class="ttdoc">Updates the socket descriptor used by this object.</div><div class="ttdef"><b>Definition</b> SocketOptions.hpp:2281</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>The new socket file descriptor to associate with this object. May be <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> to mark the socket as uninitialized or closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method does not perform error checking. It is the caller's responsibility to ensure the provided descriptor is valid and consistent with the derived class state.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6a5264b995eb2a1143f45c5de6ad92c3" title="Retrieves the current value of a low-level socket option.">getOption()</a> </dd>
<dd>
<a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a> </dd>
<dd>
<a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a> </dd></dl>

</div>
</div>
<a id="ga707a637112e5ec1309da4e6dfe2fddb3" name="ga707a637112e5ec1309da4e6dfe2fddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707a637112e5ec1309da4e6dfe2fddb3">&#9670;&#160;</a></span>setSoLinger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setSoLinger </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>seconds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the socket's linger behavior (<span class="tt">SO_LINGER</span>) during close. </p>
<p>This method sets the <span class="tt">SO_LINGER</span> socket option, which controls how the socket behaves when it is closed and unsent data remains in the transmission buffer. It determines whether <span class="tt">close()</span> will return immediately (discarding unsent data), or block until the data is transmitted or a timeout expires.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1071"></a>
🔁 Applicability</h3>
<ul>
<li>✅ <b>TCP (<span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>)</b>: Fully supported; governs graceful vs. abortive close behavior.</li>
<li>✅ <b>UNIX stream sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>)</b>: Supported on most platforms.</li>
<li>⚠️ <b>UDP or UNIX datagram sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</b>: Technically accepted by some systems, but <span class="tt">SO_LINGER</span> has <b>no effect</b> (ignored by the kernel).</li>
<li>⚠️ <b><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a> (listening)</b>: Affects only the listening socket itself; accepted sockets must be configured separately.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1072"></a>
Behavior</h3>
<ul>
<li><b>Linger enabled (<span class="tt">enable == true</span>)</b>:<ul>
<li>The OS will try to send remaining data on close.</li>
<li>If data cannot be sent within <span class="tt">seconds</span>, the socket is closed forcibly.</li>
<li>A timeout of <span class="tt">0</span> causes an <b>abortive close</b> (TCP RST is sent immediately).</li>
</ul>
</li>
<li><b>Linger disabled (<span class="tt">enable == false</span>)</b> (default):<ul>
<li><span class="tt">close()</span> returns immediately.</li>
<li>Unsent data may be discarded depending on system behavior.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1073"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Wait up to 5 seconds for graceful shutdown</span></div>
<div class="line">socket.setSoLinger(<span class="keyword">true</span>, 5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Immediately discard unsent data on close (send TCP RST)</span></div>
<div class="line">socket.setSoLinger(<span class="keyword">true</span>, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Standard non-blocking close behavior</span></div>
<div class="line">socket.setSoLinger(<span class="keyword">false</span>, 0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Whether to enable lingering behavior on close. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seconds</td><td>Linger timeout (in seconds). Only meaningful if <span class="tt">enable == true</span>.<ul>
<li>Must be ≥ 0. <span class="tt">0</span> means abortive close.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li><span class="tt">setsockopt()</span> fails</li>
<li>The operation is not supported on the socket type (platform-dependent)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga15ba6d555b0f3b7809c746f827398c5e" title="Retrieves the current SO_LINGER configuration of the socket.">getSoLinger()</a> </dd>
<dd>
shutdown() </dd>
<dd>
close()</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Behavior is OS-specific. On POSIX, applies only to stream-oriented sockets. On Windows, similar semantics apply via Winsock. </dd></dl>

</div>
</div>
<a id="ga5ad18e598507d04059bdaff086b01721" name="ga5ad18e598507d04059bdaff086b01721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ad18e598507d04059bdaff086b01721">&#9670;&#160;</a></span>setSoRecvTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setSoRecvTimeout </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>millis</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the socket receive timeout (<span class="tt">SO_RCVTIMEO</span>) in milliseconds. </p>
<p>This method configures how long a blocking read operation may wait for incoming data before timing out. It affects all socket types that perform blocking I/O, including:</p><ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (e.g., <span class="tt">read()</span>, <span class="tt">readExact()</span>, <span class="tt">readUntil()</span>)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> (e.g., <span class="tt">receiveFrom()</span>)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span> (e.g., <span class="tt">read()</span> or IPC reads)</li>
</ul>
<p>A timeout of <span class="tt">0</span> disables the timeout entirely, causing read operations to block indefinitely until data is available, the connection is closed, or an error occurs. A negative timeout is invalid and will result in an exception.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1085"></a>
🔀 Platform Behavior</h3>
<ul>
<li><b>Windows</b>: The timeout is passed as an <span class="tt">int</span> in milliseconds.</li>
<li><b>POSIX</b>: The timeout is passed as a <span class="tt">struct timeval</span> (<span class="tt">seconds</span> + <span class="tt">microseconds</span>).</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1087"></a>
Example: Set a 3-second receive timeout</h3>
<div class="fragment"><div class="line">socket.setSoRecvTimeout(3000);  <span class="comment">// Timeout after 3000 ms if no data arrives</span></div>
<div class="line">std::string line = socket.readUntil(<span class="charliteral">&#39;\n&#39;</span>);</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">millis</td><td>Timeout in milliseconds. Must be ≥ 0. Use <span class="tt">0</span> to disable the timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li>The timeout is negative</li>
<li><span class="tt">setsockopt()</span> fails due to unsupported option or system-level error</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaee02a4007c38decf8925319b9f3e5f2" title="Retrieves the socket receive timeout (SO_RCVTIMEO) in milliseconds.">getSoRecvTimeout()</a> </dd>
<dd>
<a class="el" href="#ga7107a9da459b00bf39ec2fe4d3e83396" title="Sets the socket send timeout (SO_SNDTIMEO) in milliseconds.">setSoSendTimeout()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/socket.7.html">https://man7.org/linux/man-pages/man7/socket.7.html</a> </dd></dl>

</div>
</div>
<a id="ga7107a9da459b00bf39ec2fe4d3e83396" name="ga7107a9da459b00bf39ec2fe4d3e83396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7107a9da459b00bf39ec2fe4d3e83396">&#9670;&#160;</a></span>setSoSendTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setSoSendTimeout </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>millis</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the socket send timeout (<span class="tt">SO_SNDTIMEO</span>) in milliseconds. </p>
<p>This method configures how long a blocking send operation (e.g., <span class="tt">write()</span>, <span class="tt">writeAll()</span>) may block before timing out. It affects all socket types that support writing:</p><ul>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span> (TCP stream writes)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> (UDP send operations)</li>
<li><span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span> (interprocess writes)</li>
</ul>
<p>A timeout of <span class="tt">0</span> disables the timeout entirely, allowing send operations to block indefinitely until buffer space is available. A negative timeout is invalid and will result in an exception.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1090"></a>
🔀 Platform Behavior</h3>
<ul>
<li><b>Windows</b>: Timeout is set as a plain <span class="tt">int</span> in milliseconds.</li>
<li><b>POSIX</b>: Timeout is specified via a <span class="tt">struct timeval</span> with second/microsecond precision.</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1092"></a>
Example: Set a 5-second send timeout</h3>
<div class="fragment"><div class="line">socket.setSoSendTimeout(5000);  <span class="comment">// Timeout if write blocks for more than 5 seconds</span></div>
<div class="line">socket.writeAll(request);</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">millis</td><td>Timeout in milliseconds. Must be ≥ 0. Use <span class="tt">0</span> to disable the timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid</li>
<li>The timeout is negative</li>
<li><span class="tt">setsockopt()</span> fails due to system-level error or unsupported option</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1bef2499ed5c13367dc73752484298c0" title="Retrieves the socket send timeout (SO_SNDTIMEO) in milliseconds.">getSoSendTimeout()</a> </dd>
<dd>
<a class="el" href="#ga5ad18e598507d04059bdaff086b01721" title="Sets the socket receive timeout (SO_RCVTIMEO) in milliseconds.">setSoRecvTimeout()</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/socket.7.html">https://man7.org/linux/man-pages/man7/socket.7.html</a> </dd></dl>

</div>
</div>
<a id="ga2087f337f22de16821132208b94b1441" name="ga2087f337f22de16821132208b94b1441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2087f337f22de16821132208b94b1441">&#9670;&#160;</a></span>setSoTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::ServerSocket::setSoTimeout </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>timeoutMillis</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the logical timeout (in milliseconds) for accepting client connections. </p>
<p>This timeout applies to methods like <span class="tt"><a class="el" href="group__tcp.html#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a></span> and <span class="tt"><a class="el" href="group__tcp.html#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a></span>, and determines how long the server socket will wait for a client connection before timing out.</p>
<p>Unlike <span class="tt">Socket::setSoTimeout()</span>, this method does <b>not</b> call <span class="tt">setsockopt()</span> and does <b>not</b> affect the underlying socket descriptor. Instead, it is used internally to control the behavior of <span class="tt">select()</span> during accept operations.</p>
<dl class="section note"><dt>Note</dt><dd>Use:<ul>
<li>Negative value: wait indefinitely (blocking behavior)</li>
<li>Zero: poll mode (non-blocking)</li>
<li>Positive value: wait up to the specified milliseconds</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeoutMillis</td><td>Timeout value in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7829c558cb7bf5e0a46d882df82acc19" title="Get the logical timeout (in milliseconds) for accept operations.">getSoTimeout()</a> </dd>
<dd>
<a class="el" href="group__tcp.html#gac645e511797a5c5cffd1ee490ece0e96" title="Accept an incoming client connection, respecting the configured socket timeout and applying tuning op...">accept()</a> </dd>
<dd>
<a class="el" href="group__tcp.html#ga6eff2e5c775318cfd2813ee72e716571" title="Attempt to accept an incoming client connection, returning std::nullopt on timeout instead of throwin...">tryAccept()</a> </dd>
<dd>
<a class="el" href="group__tcp.html#ga61c1904213b0971817ec917fd2a01ccf" title="Waits for the server socket to become ready to accept an incoming connection.">waitReady()</a> </dd></dl>

</div>
</div>
<a id="ga9839dd8837c7519a627f28b3a4c7a513" name="ga9839dd8837c7519a627f28b3a4c7a513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9839dd8837c7519a627f28b3a4c7a513">&#9670;&#160;</a></span>setTcpNoDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jsocketpp::SocketOptions::setTcpNoDelay </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables Nagle’s algorithm (<span class="tt">TCP_NODELAY</span>) on TCP sockets. </p>
<p>This method configures the <span class="tt">TCP_NODELAY</span> option, which controls the behavior of <b>Nagle's algorithm</b> for stream-oriented TCP sockets (<span class="tt">SOCK_STREAM</span>). Nagle's algorithm aims to reduce network congestion by delaying small outgoing packets until previous ones are acknowledged — effectively "coalescing" writes.</p>
<p>Disabling Nagle’s algorithm (i.e., setting <span class="tt">TCP_NODELAY = 1</span>) allows small packets to be sent immediately, which is ideal for latency-sensitive applications. Enabling it (i.e., setting <span class="tt">TCP_NODELAY = 0</span>) improves throughput by batching writes, but introduces potential delays.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1123"></a>
💡 Use Cases</h3>
<ul>
<li><b>Latency-sensitive applications</b>:<ul>
<li>Games, remote control, real-time messaging, RPC</li>
<li>Disabling Nagle (<span class="tt">on = true</span>) minimizes delay in sending small payloads</li>
</ul>
</li>
<li><b>Bulk transfer or high-throughput services</b>:<ul>
<li>Enabling Nagle (<span class="tt">on = false</span>) reduces packet count and improves network efficiency</li>
</ul>
</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1125"></a>
🔀 Platform Behavior</h3>
<ul>
<li>Universally available on TCP/IP sockets (<span class="tt">AF_INET</span>, <span class="tt">AF_INET6</span> with <span class="tt">SOCK_STREAM</span>)</li>
<li><b>POSIX</b>: Uses <span class="tt">setsockopt()</span> with <span class="tt">IPPROTO_TCP</span> and <span class="tt">TCP_NODELAY</span></li>
<li><b>Windows</b>: Uses Winsock with same option names</li>
<li>Has <b>no effect</b> on:<ul>
<li>UDP sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>)</li>
<li>UNIX domain sockets (<span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>)</li>
<li>Non-TCP protocols or non-stream sockets</li>
</ul>
</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md1127"></a>
Example: Disable Nagle’s algorithm to reduce latency</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjsocketpp_1_1Socket.html">Socket</a> sock(<span class="stringliteral">&quot;example.com&quot;</span>, 443);</div>
<div class="line">sock.connect();</div>
<div class="line"> </div>
<div class="line">sock.setTcpNoDelay(<span class="keyword">true</span>);  <span class="comment">// Disable Nagle — send immediately</span></div>
<div class="line">sock.write(<span class="stringliteral">&quot;small interactive packet&quot;</span>);</div>
</div><!-- fragment --><hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">on</td><td>If <span class="tt">true</span>, disables Nagle's algorithm (<span class="tt">TCP_NODELAY = 1</span>), enabling immediate sends. If <span class="tt">false</span>, enables Nagle's algorithm (<span class="tt">TCP_NODELAY = 0</span>) to batch small writes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></td><td>if:<ul>
<li>The socket is invalid or closed</li>
<li>The option is unsupported on the current socket type</li>
<li>The <span class="tt">setsockopt()</span> call fails due to system error or permission issue</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this method on a non-TCP socket will raise an exception. You can catch <span class="tt"><a class="el" href="classjsocketpp_1_1SocketException.html" title="Represents socket-related errors in the jsocketpp library.">SocketException</a></span> to handle cross-socket behavior gracefully.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga05137fbdc55ab065739e220b7a4f41c0" title="Queries whether Nagle&#39;s algorithm (TCP_NODELAY) is currently disabled.">getTcpNoDelay()</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">https://en.wikipedia.org/wiki/Nagle%27s_algorithm</a> </dd>
<dd>
<a href="https://man7.org/linux/man-pages/man7/tcp.7.html">https://man7.org/linux/man-pages/man7/tcp.7.html</a> </dd></dl>

</div>
</div>
<a id="ga9e263722ea800db82c34769d8f49be3a" name="ga9e263722ea800db82c34769d8f49be3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e263722ea800db82c34769d8f49be3a">&#9670;&#160;</a></span>SocketOptions() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::SocketOptions::SocketOptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor (deleted) for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a> base class. </p>
<p>This constructor is explicitly deleted to prevent the creation of uninitialized <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> objects. Subclasses like <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>, or <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span> must initialize the socket handle explicitly via constructor arguments or system calls.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1004"></a>
Rationale</h3>
<ul>
<li>Prevents misuse of base class in isolation</li>
<li>Enforces proper ownership semantics for <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a></span></li>
<li>Ensures all derived types have valid or explicitly invalid sockets</li>
</ul>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> opt; <span class="comment">// ❌ Compilation error (deleted constructor)</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab6fea2ad1b8aac819f3726ab8846527b" title="Initializes the socket option interface with a specific socket descriptor.">SocketOptions(SOCKET)</a> Constructor with explicit socket handle </dd>
<dd>
close(), <a class="el" href="#ga97706ddf21aab33a18db00bd0b8eb65d" title="Updates the socket descriptor used by this object.">setSocketFd()</a>, <a class="el" href="#gaced4c6dc799564ece9ce4e6766b1d794" title="Retrieves the native socket handle (file descriptor or OS-level handle).">getSocketFd()</a> </dd></dl>

</div>
</div>
<a id="gab6fea2ad1b8aac819f3726ab8846527b" name="gab6fea2ad1b8aac819f3726ab8846527b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6fea2ad1b8aac819f3726ab8846527b">&#9670;&#160;</a></span>SocketOptions() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::SocketOptions::SocketOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a></td>          <td class="paramname"><span class="paramname"><em>sock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the socket option interface with a specific socket descriptor. </p>
<p>Constructs a <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> object that uses the provided socket file descriptor for all subsequent <span class="tt"><a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a></span> and <span class="tt"><a class="el" href="#ga6a5264b995eb2a1143f45c5de6ad92c3" title="Retrieves the current value of a low-level socket option.">getOption()</a></span> calls. This constructor is intended to be used by derived socket classes (e.g., <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1UnixSocket.html" title="Cross-platform abstraction for Unix domain sockets.">UnixSocket</a></span>) to delegate option-handling responsibilities without duplicating system-specific logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>A valid socket descriptor (e.g., from <span class="tt">socket()</span>, <span class="tt">accept()</span>, etc.), or <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span> if the object is not yet initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is the responsibility of the derived class to ensure that the socket descriptor remains valid for the lifetime of the <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> object.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This class does not manage or close the socket descriptor. It assumes the derived class owns and controls the lifetime of the socket.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga97706ddf21aab33a18db00bd0b8eb65d" title="Updates the socket descriptor used by this object.">setSocketFd()</a> </dd>
<dd>
<a class="el" href="#ga1b7061a0f4d13e8d33d3065b8ad4998b" title="Sets a low-level socket option on the underlying socket.">setOption()</a> </dd>
<dd>
<a class="el" href="#ga6a5264b995eb2a1143f45c5de6ad92c3" title="Retrieves the current value of a low-level socket option.">getOption()</a> </dd></dl>

</div>
</div>
<a id="ga64de913573af3ff3cb6f40bcb71c1ba0" name="ga64de913573af3ff3cb6f40bcb71c1ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64de913573af3ff3cb6f40bcb71c1ba0">&#9670;&#160;</a></span>SocketOptions() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::SocketOptions::SocketOptions </td>
          <td>(</td>
          <td class="paramtype">const SocketOptions &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (deleted) for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>. </p>
<p>The copy constructor is explicitly deleted to prevent accidental copying of <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> instances. Since the class wraps a native socket handle (<span class="tt"><a class="el" href="namespacejsocketpp.html#ac484f9eb8a74658aa491da1d1bc15eda">SOCKET</a></span>), copying it would result in multiple objects referring to the same socket, leading to unsafe behavior such as double-closing or unexpected side effects.</p>
<p>All derived socket classes in the library (e.g., <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>) are also non-copyable to preserve strict ownership semantics and RAII guarantees.</p>
<dl class="section note"><dt>Note</dt><dd>Use move semantics (<span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>(<a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>&amp;&amp;)</span>) to transfer ownership explicitly.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> a(sockFd);</div>
<div class="line"><a class="code hl_function" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> b = a; <span class="comment">// ❌ Compilation error (copy constructor is deleted)</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga244a62ac8b74854e58066a242976793d" title="Move constructor for SocketOptions.">SocketOptions(SocketOptions&amp;&amp;)</a> noexcept </dd></dl>

</div>
</div>
<a id="ga244a62ac8b74854e58066a242976793d" name="ga244a62ac8b74854e58066a242976793d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga244a62ac8b74854e58066a242976793d">&#9670;&#160;</a></span>SocketOptions() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jsocketpp::SocketOptions::SocketOptions </td>
          <td>(</td>
          <td class="paramtype">SocketOptions &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor for <a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a>. </p>
<p>Transfers the socket handle (<span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a></span>) and internal state from another <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> instance. After the move, the source object is left in a valid but unspecified state (typically with <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a></span> set to <span class="tt"><a class="el" href="namespacejsocketpp.html#a3ddf4938a63ed33a5e2f7d2625cb4405">INVALID_SOCKET</a></span>).</p>
<p>This enables safe and efficient transfer of socket ownership in derived classes, such as <span class="tt"><a class="el" href="classjsocketpp_1_1Socket.html" title="TCP client connection abstraction (Java-like interface).">Socket</a></span>, <span class="tt"><a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a></span>, or <span class="tt"><a class="el" href="classjsocketpp_1_1ServerSocket.html" title="TCP server socket abstraction for cross-platform C++ networking.">ServerSocket</a></span>, without invoking unnecessary system calls or duplicating file descriptors.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1005"></a>
Rationale</h3>
<ul>
<li>Enables move semantics for socket objects</li>
<li>Prevents accidental use-after-move by invalidating the source <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html#a44b54c91017594a7695bf315778fb131" title="Underlying socket file descriptor.">_sockFd</a></span></li>
<li>Supports RAII-friendly container usage (e.g., <span class="tt">std::vector&lt;<a class="el" href="classjsocketpp_1_1DatagramSocket.html" title="Cross-platform UDP socket class with Java-style interface.">DatagramSocket</a>&gt;</span>)</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>After the move, the source object should not be used for socket operations.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> a(sockFd);</div>
<div class="line"><a class="code hl_function" href="#ga9e263722ea800db82c34769d8f49be3a">SocketOptions</a> b = std::move(a); <span class="comment">// ✅ Transfers socket handle to b</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac396d98978063f302938aa9ee80bf634" title="Move assignment operator for SocketOptions.">operator=(SocketOptions&amp;&amp;)</a> noexcept </dd></dl>

</div>
</div>
<a id="ga74663905817ec41a5b3a7f3d7a16550d" name="ga74663905817ec41a5b3a7f3d7a16550d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74663905817ec41a5b3a7f3d7a16550d">&#9670;&#160;</a></span>~SocketOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual jsocketpp::SocketOptions::~SocketOptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor for safe polymorphic destruction. </p>
<p>Ensures that derived classes can be safely destroyed through a pointer to <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span>. This is important for preventing resource leaks and undefined behavior when using socket option interfaces polymorphically (e.g., in unit tests or abstraction layers).</p>
<p>This destructor does <b>not</b> perform any cleanup of the socket descriptor itself, as <span class="tt"><a class="el" href="classjsocketpp_1_1SocketOptions.html" title="Public base class for raw socket option access via setsockopt() and getsockopt().">SocketOptions</a></span> does not own or manage the socket lifecycle. Derived classes are responsible for closing or releasing the socket if needed.</p>
<dl class="section note"><dt>Note</dt><dd>Declared <span class="tt">virtual</span> to support inheritance and polymorphism. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
